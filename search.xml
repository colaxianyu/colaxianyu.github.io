<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八股</title>
    <url>/2025/03/07/2025-03-07-%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="c">C++</h1>
<h2 id="简述c语言的特点">简述C++语言的特点</h2>
<ol type="1">
<li>在兼容C语言的基础上，支持多种范式，例如面向对象、泛型、函数式编程等</li>
<li>C++可以直接操作内存，且零成本抽象，配合模板，元编程等技术，不仅可以实现良好的底层控制，且运行效率高</li>
<li>C++更安全，通过RAII机制自动管理资源，减少内存泄漏风险</li>
<li>C++是一个不断发展的语言，C++11引入了右值，移动语义等特性，c++20引入了module、concept、ranges等特性</li>
</ol>
<h2 id="说说c语言和c的区别">说说C语言和C++的区别</h2>
<ol type="1">
<li>C是一门面向过程的语言，C++是一门面向对象为主，支持多范式编程的语言</li>
<li>C++的安全性更高，C语言更倾向手动管理内存，C++更倾向通过RAII（智能指针、容器）自动管理资源生命周期。</li>
<li>C++的函数支持函数重载，且利用虚函数支持动态多态</li>
<li>C++提供了更为强大的STL标准库</li>
</ol>
<h2 id="说说-c中-struct-和-class-的区别">说说 C++中 struct 和 class
的区别</h2>
<ol type="1">
<li>C++对C中的struct进行了扩展，C中的struct不能有成员函数，无法进行访问控制，不支持继承</li>
<li>C++中的strcut默认public访问权限，class默认private访问权限，包括private、protect和public三种访问权限，在继承关系中，struct默认公有继承，class默认私有继承</li>
<li>C++中的struct常用于数据聚合，例如POD类型，class常用于更复杂的对象封装</li>
</ol>
<h2
id="说说include头文件的顺序以及双引号和尖括号的区别">说说include头文件的顺序以及双引号""和尖括号&lt;&gt;的区别</h2>
<ol type="1">
<li>尖括号的头文件是系统文件，双引号的头文件是自定义文件</li>
<li>尖括号头文件的查找路径是编译器设置的头文件路径-&gt;系统变量；双引号头文件的查找路径是头文件目录-&gt;编译器设置的头文件目录-&gt;系统变量</li>
</ol>
<h2
id="导入c函数的关键字是什么c编译时和c有什么不同">导入C函数的关键字是什么，C++编译时和C有什么不同？</h2>
<ol type="1">
<li>C++通过extern关键字导入C函数，通过extern
"C"引入的C函数会按照C语言的规定进行编译</li>
<li>编译的区别主要在函数上，C++由于支持函数重载，编译时不仅包括函数名，还包括参数类型，命名空间等信息，而C语言编译时通常只包括函数名</li>
</ol>
<h2
id="简述c从代码到可执行二进制文件的过程">简述C++从代码到可执行二进制文件的过程</h2>
<p>C++从源代码到二进制文件经历的过程包括：<br />
1. 预处理，展开#include头文件，处理#define宏和#ifdef条件宏，过滤注释 2.
编译，进行词法/语法分析，语义分析，生成目标代码并优化 3.
汇编，讲目标代码转换为二进制代码 4.
链接，合并多个目标文件及库，生成可执行文件，链接阶段可以分为静态链接和动态链接，静态链接在链接阶段就把要调用的函数链接到可执行文件中，动态链接是在执行过程中寻找要链接的函数</p>
<h2 id="说说-static关键字的作用">说说 static关键字的作用</h2>
<ol type="1">
<li>对于全局变量，其生命周期不变，依然持续到程序结束，存储位置不变，依然为静态存储区，但作用域改变，从可被其他源文件通过extern引用变为只能在本文件可见，用于避免命名冲突</li>
<li>对于局部变量，其生命周期延长至程序结束，存储位置从栈区变为静态存储区，作用域不变，依然是语句块内可见</li>
<li>对于函数，类似于全局变量，只能在本文件中可见</li>
<li>对于成员变量，该变量属于类本身，而不属于实例化的类对象，所有类对象都共享该变量，现在可以通过inline在类内完成初始化</li>
<li>对于成员函数，类似与静态成员变量，属于类本身，而不属于实例化的类对象，静态成员函数只能使用静态成员变量，调用其他静态成员函数，不可以是虚函数</li>
</ol>
<h2 id="说说数组和指针的区别">说说数组和指针的区别</h2>
<ol type="1">
<li>数组是一段连续的内存块，包含元素的类型和长度信息；指针是一个保存地址的变量，仅包含类型信息。在c++类型系统中属于不同的复合类型</li>
<li>数组名是一个可隐式转换为常量指针的标识符，无法进行赋值，而指针变量可以进行赋值，对数组名的引用得到的是数组指针，对指针的引用得到的是指针变量的地址</li>
<li>指针的大小在32为系统下固定为4字节，64位系统下位8字节</li>
<li>数组在传参过程中会发生类型退化，退化为指针变量</li>
</ol>
<h2 id="简单说下函数指针">简单说⼀下函数指针</h2>
<ol type="1">
<li>函数指针是一个指向函数的指针变量</li>
<li>在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。函数指针最常用的地方是做回调函数</li>
</ol>
<h2
id="野wild指针与悬空dangling指针有什么区别如何避免">野(wild)指针与悬空(dangling)指针有什么区别？如何避免？</h2>
<ol type="1">
<li>野指针是未初始化的指针，悬空指针是指向已被释放的内存或失效对象的指针</li>
<li>避免的手段通常包括，初始化或资源释放后及时置nullptr，尽量使用智能指针</li>
</ol>
<h2 id="说说内联函数和宏函数的区别">说说内联函数和宏函数的区别</h2>
<ol type="1">
<li>宏定义的函数并非真正的函数，只是预处理阶段的字符串展开，没有类型检查</li>
<li>内联函数是真正的函数，具有类型检查，是一种编译期的优化，编译器会在内联的位置直接插入代码，避免函数调用带来的开销，内联函数通常是函数体内容简单的函数</li>
<li>inline关键字仅作为内联建议，一个函数是否为内联函数最终由编译器决议，C++17扩展了inline关键字的功能，inline函数允许函数定义出现在多个翻译单元</li>
</ol>
<h2 id="说说运算符i和i的区别">说说运算符i++和++i的区别</h2>
<ol type="1">
<li>++i返回的是一个左值，i++返回的是一个右值</li>
<li>以int a = i++; int b = ++i;
这个例子中，a是先赋值为i，然后i自增，b是被赋值为i自增后的结果</li>
<li>无优化的情况下，++i效率更高，在优化之后（RVO）效率差别不大</li>
</ol>
<h2 id="new-delete-malloc-free-区别">new / delete ，malloc / free
区别</h2>
<ol type="1">
<li>new和delete是C++运算符，支持重载，而malloc和free是C库函数，不可重载</li>
<li>new执行了两个过程，第一步是分配未初始化的内存空间，第二步是调用构造函数进行初始化，失败会抛出异常。delete也有两个过程，首先调用析构函数完成析构，最后调用解分配函数释放内存</li>
<li>malloc分配的内存大小需要手动计算，返回的指针需要进行强转，失败时返回null</li>
</ol>
<h2 id="说说const和define的区别"> 说说const和define的区别</h2>
<ol type="1">
<li>const用于定义常量，define可以用于定义宏，也可以用于定义常量</li>
<li>当用于定义常量时，const常量是具有类型的，会进行类型检查，遵循C++的作用域规则，在编译期进行处理，const常量可能会分配相应的内存，也可能会被优化为立即数</li>
<li>define常量是无类型的，也没有类型检查，在预处理阶段进行处理，不涉及内存分配，只是简单的进行宏展开</li>
</ol>
<h2
id="说说const-int-a-int-const-a-int-const-a-int-const-a-const-int-const-a分别是什么有什么特点">说说const
int *a, int const *a, int *const a, int *const a, const int *const
a分别是什么，有什么特点</h2>
<ol type="1">
<li>const int a定义了一个整型常量</li>
<li>const int* a定义了一个指针，其指向的内容是一个整型常量</li>
<li>int const* a同const int* a</li>
<li>int *const a定义了一个常量指针，指向一个整型数据</li>
<li>const int *const a定义了一个常量指针，指向一个整型常量</li>
</ol>
<h2
id="c有几种传值方式之间的区别是什么">C++有几种传值方式，之间的区别是什么？</h2>
<ol type="1">
<li>C++有值传递，指针传递和引用传递三种方式，对于值传递，形参是实参的副本，所以修改形参不会影响实参。</li>
<li>对于指针传递，传递的是指针的值，形参和实参指向同一内存，在不改变指针的值的情况下，解引用修改数据会影响实参。</li>
<li>对于引用传递，分为左值引用和右值引用，
左值引用是实参的一个别名，修改左值引用会影响到实参，右值引用主要用于接收右值实参，实现移动语义和完美转发</li>
</ol>
<h2 id="简述一下堆和栈的区别">简述一下堆和栈的区别</h2>
<ol type="1">
<li>在管理方式上，栈由编译器进行分配与释放，内存连续，分配速度快；堆由开发者手动管理分配与释放，分配可能碎片化</li>
<li>在生命周期方面，栈变量随作用域结束自动销毁，堆对象需要手动释放，否则会导致资源泄漏</li>
<li>在结构上，栈严格遵守先进后出，由于内存连续，缓存命中率会更高，堆分配通常地址不连续，易碎片化</li>
</ol>
<h2 id="简述c的内存管理">简述C++的内存管理</h2>
<ol type="1">
<li>C++的内存可以分为栈区，堆区，静态存储区，常量存储区和自由存储区</li>
<li>栈区主要用于存放局部变量和函数参数，由编译器进行管理</li>
<li>静态存储区用于存放静态变量和全局变量，分为初始化和未初始化两个区域</li>
<li>常量存储区用于存放常量</li>
<li>堆区用于存放动态分配的对象，自由存储区是C++中的一个抽象概念，当使用缺省的new和delete时，自由存储区和堆区共享同一块内存，但如果重载new运算符，自由存储区可以脱离堆</li>
</ol>
<h2 id="内存泄露及解决办法">内存泄露及解决办法</h2>
<ol type="1">
<li>内存泄漏是指没有及时回收动态分配的内存，常见的造成内存泄漏的行为有使用new和malloc，没有正确使用delete和free释放资源；存在继承关系时，父类析构函数非虚，导致资源不能及时释放；windows句柄资源使用后没有释放</li>
<li>可以通过使用智能指针，RAII技术来避免出现内存泄漏问题，当出现内存泄漏时，可以使用Dmalloc、Leaky等工具来进行检查</li>
</ol>
<h2 id="简述一个程序有哪些section">简述一个程序有哪些section</h2>
<ol type="1">
<li>通常包括.text段，.data段，.bss段，堆区，共享区，栈区等组成</li>
<li>.text段通常用于存放二进制代码</li>
<li>.data段用于存放用于存放已初始化的全局变量和静态变量</li>
<li>.bss段用于存放未初始化的全局变量和静态变量</li>
<li>对于可执行程序，栈区用于存放局部变量和函数参数，对于用于存放动态分配的资源，栈区从高地址向低地址增长，堆区从低地址向高地址增长</li>
</ol>
<h2 id="简述一下程序启动的过程">简述一下程序启动的过程</h2>
<ol type="1">
<li>操作系统首先会创建新进程，并分配虚拟地址空间，然后加载器将代码段(.text)，已初始化的数据段(.data)映射到内存，然后.bss段清零，完成内存布局初始化</li>
<li>对于静态链接库，直接嵌入可执行文件；对于动态链接库，加载器读取可执行文件的导入表，确定每一个依赖的动态链接库，对于基址与预设不符的，查询重定位表进行重定位，将导出函数的实际地址写入IAT表，供程序调用</li>
<li>C
runtime库进行初始化，初始化堆管理器，调用全局对象的构造函数，并注册全局对象的析构函数</li>
<li>进入程序入口main或WinMain，开始执行</li>
</ol>
<h2
id="简述一下面向对象以及面向对象的三大特征">简述一下面向对象，以及面向对象的三大特征</h2>
<ol type="1">
<li>面向对象是一种以对象为核心的编程范式，将数据和操作数据的方法封装为类，利用实例化的对象解决问题。相较于面向过程式自上而下的编码方式，面向对象可以提高代码的复用性，扩展性和维护性，</li>
<li>面向对象的三大特征是封装、继承和多态</li>
<li>封装是指将数据和操作数据的方法封装到一起，利用访问权限修饰符控制外部访问</li>
<li>继承是指子类继承父类的属性和方法，提高代码复用性，C++中支持private，protected和public三种继承类型，在private继承下，父类的所有成员都变为private，子类无法访问，在protected继承下，父类的public成员变为protected属性，子类可以访问，但外部对象无法访问，在public继承下，父类的成员属性不发生变化</li>
<li>多态是指可以通过父类指针调用子类的方法，子类可以通过重写父类的虚函数进行扩展。面向对象中的多态通常是指运行时的多态，通过虚表实现动态绑定，C++中还存在静态多态，通常是指函数重载和模板</li>
<li>现代oop提倡组合优于继承，更推荐使用继承+组合的形式来提高编码的灵活性，减少耦合</li>
</ol>
<h2 id="简述一下-c-的重载和重写并说一下它们是怎么实现的">简述一下 C++
的重载和重写，并说一下它们是怎么实现的</h2>
<ol type="1">
<li>函数重载是指可以在同一作用域内定义参数列表的不同的同名函数，编译器通过“Name
Mangling”技术，利用函数名和参数列表生成唯一符号，在编译期间通过实参信息进行决议，匹配最佳函数，参数的类型，顺序和个数参与决议过程，返回值不参与</li>
<li>重写是指派生类中重新定义了父类中除函数体外完全相同的虚函数，该函数在父类中必须是虚函数，不能是static函数，重写的函数访问修饰符可以与父类不同，可以通过final阻止进一步重写。其核心机制是通过虚函数表和虚表指针实现的，如果类存在虚函数，则编译器会为该类生成一个虚函数表，虚函数表中存放着虚函数的函数指针，在构造时完成虚表指针的初始化，指向该类的虚函数表（虚函数表类共享，而不属于某个对象）。当派生类继承了具有虚函数的基类时，首先会拷贝基类的虚函数表，如果派生类重写了虚函数，就替换为重写后的虚函数地址，如果派生类自身也有虚函数，则追加到虚函数表中</li>
</ol>
<h2 id="简述一下c中所有的构造函数">简述一下C++中所有的构造函数</h2>
<ol type="1">
<li>C++中常见的构造函数有，默认构造函数，一般构造函数，拷贝构造函数，移动构造函数，委托构造函数，继承构造函数和转换构造函数</li>
<li>默认构造函数也称为无参构造函数，当没有显式定义构造函数时，编译器会自动生成默认构造函数，一般构造函数是有参数的构造函数</li>
<li>拷贝构造函数用于实现同类型的拷贝，默认实现是浅拷贝</li>
<li>移动构造函数接收右值引用，转移资源的所有权</li>
<li>委托构造函数可以让一个构造函数调用其他同类构造函数，减少重复代码，集中初始化逻辑</li>
<li>继承构造函数用于继承基类构造函数，避免重复编写基类构造函数</li>
<li>转换构造函数是单参数构造函数（或含默认值的多参数构造），允许隐式类型转换</li>
<li>根据零/三/五法则，若定义了析构函数，拷贝构造，拷贝赋值，移动构造，移动赋值之一，通常需要定义全部</li>
</ol>
<h2
id="说说一个类默认会生成哪些函数">说说一个类，默认会生成哪些函数</h2>
<ol type="1">
<li>默认会生成默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符</li>
<li>当用户定义了析构函数时，会抑制移动构造函数，移动赋值运算符的生成</li>
</ol>
<h2 id="说说-c-类对象的初始化顺序有多重继承情况下的顺序">说说 C++
类对象的初始化顺序，有多重继承情况下的顺序</h2>
<ol type="1">
<li>在创建派生类对象时，有限调用基类构造函数，如果类中有其他成员类，再调用成员类的构造函数</li>
<li>对于多继承的情况，按多继承的顺序调用基类构造函数，不受初始化列表顺序影响。对于成员类，按成员类的定义顺序调用构造函数，不受初始化列表顺序影响</li>
<li>调用派生类的构造函数</li>
</ol>
<h2 id="说说c的四种强制类型转换">说说C++的四种强制类型转换</h2>
<ol type="1">
<li>C++的强制类型转换有static_cast，dynamic_cast，const_cast，reinterpret_cast四种</li>
<li>static_cast是带有类型安全检查的类型转换，建议将大部分隐式类型转换替换为static_cast</li>
<li>dynamic_cast专用于派生类之间的转换，在down
cast转换过程中是安全的，对于类型不一致的转换，转换结果将返回空指针，由于需要run
time information，存在一定的开销</li>
<li>const_cast专用于const属性的转换，可以用于增加或去除const属性</li>
<li>reinterpret_cast会从内存布局上对数据重新进行解释，无限制，但可移植性差，危险度高
## 说说为什么要虚析构，为什么不能虚构造</li>
<li>虚析构是为了保证派生类可以正确释放自身资源，如果析构函数非虚，在使用基类指针管理派生类对象进行析构时，只会调用基类的析构函数，导致派生类资源无法正确释放，导致资源泄漏</li>
<li>构造函数的调用先于虚函数表的建立，故虚构造是错误的</li>
</ol>
<h2
id="简述一下什么是常函数有什么作用">简述一下什么是常函数，有什么作用</h2>
<ol type="1">
<li>常函数是指参数列表后带const的成员函数，其特点是常函数只能调用其他常函数，且不能修改成员变量（用mutable修饰的除外）</li>
</ol>
<h2
id="说说什么是虚继承解决什么问题如何实现">说说什么是虚继承，解决什么问题，如何实现？</h2>
<ol type="1">
<li>虚继承是一种用于解决多重继承环境下菱形继承问题的一种机制，虚继承通过在继承基类时使用virtual关键字实现，确保在多重继承时，基类仅被最终派生类实例化一次，避免数据冗余和二义性</li>
<li>在内存布局上，虚基类的实例被放置在最终派生类的末尾，被所有虚继承的类共享，编译器为每一个虚继承的派生类插入虚基类指针（或使用虚基类表，虚基类表保存虚基类相对当前对象的偏移），指向虚基类实例的位置，访问虚基类的成员时统一通过指针间接访问，确保唯一性，但存在一定的开销</li>
<li>虚基类的构造函数由最终派生类直接调用</li>
</ol>
<h2
id="简述一下虚函数和纯虚函数以及实现原理">简述一下虚函数和纯虚函数，以及实现原理</h2>
<ol type="1">
<li>虚函数的作用主要是为了实现动态多态，当使用父类指针调用子类成员函数时，通过虚函数表和晚绑定，实现了相同函数不同功能的作用</li>
<li>纯虚函数是成员函数参数列表后又=0的函数，包含纯虚函数的类是一个抽象类，无法被实例化，继承了纯虚函数的派生类必须定义抽象类中的每一个纯虚函数，否则也无法实例化</li>
<li>纯虚函数和虚函数都可以提供默认实现，但调用纯虚函数的默认实现必须显式调用（class::function）
##  请问构造函数中的能不能调用虚方法</li>
<li>可以在构造函数中调用虚方法，但方法的行为可能与直觉不符，因为在构造函数执行期间，对象的动态类型为当前正在构造的类型，所以调用的是基类的虚函数。</li>
<li>当构造函数中调用的是纯虚函数时，如果纯虚函数没有提供默认实现，将会报错</li>
</ol>
<h2
id="请问拷贝构造函数的参数是什么传递方式为什么">请问拷贝构造函数的参数是什么传递方式，为什么</h2>
<p>拷贝构造函数的参数必须是引用传递，如果是值传递，那么在传参过程中需要构建临时对象，而构建临时对象又需要调用拷贝构造函数，这就导致了无限递归的现象</p>
<h2 id="简述一下拷贝赋值和移动赋值">简述一下拷贝赋值和移动赋值</h2>
<ol type="1">
<li>拷贝赋值的参数为左值引用，移动赋值的参数是右值引用</li>
<li>拷贝赋值通常是为了实现深拷贝，避免资源泄露，移动赋值是资源所有权的转移</li>
</ol>
<h2 id="仿函数了解吗有什么作用">仿函数了解吗？有什么作用</h2>
<ol type="1">
<li>仿函数也称为函数对象，是一个能像普通函数一样使用的类，通过重载()运算符实现，仿函数的优势在于可以利用成员变量记录上下文信息</li>
<li>lambda函数本质上是一个匿名函数对象，当lambda函数的捕获列表为空时，会生成一个转换函数，是其可以转换为函数指针</li>
</ol>
<h2 id="c-中哪些函数不能被声明为虚函数">C++
中哪些函数不能被声明为虚函数</h2>
<ol type="1">
<li>c++中普通函数，构造函数，静态成员函数，友元函数和模板成员函数不能被声明为虚函数</li>
<li>普通函数只能重载，与重写无关，属于静态多态，故不能成为虚函数</li>
<li>构造函数的功能是完成初始化，
虚表指针的初始化就发生在构造函数阶段，如果构造函数是虚函数，那么就需要查虚函数表，此时就产生了逻辑矛盾，故不能为虚函数</li>
<li>静态成员函数为类所有，所有实例化对象共享统一静态成员函数，无this指针，无法通过虚表机制实现多态</li>
<li>友元函数是类外的普通函数，只是可以访问类内的private成员，不支持继承，所以不能为虚函数</li>
<li>模板成员函数，虚表需要在编译期确定，而模板成员在实例化时才会生成代码，故不能为虚函数</li>
</ol>
<h2
id="说说new和delete的实现原理delete是如何知道释放内存的大小的">说说new和delete的实现原理，delete是如何知道释放内存的大小的</h2>
<ol type="1">
<li>new通过调用operator
new，分配内存后调用构造函数，delete则是先调用析构函数，后回收内存</li>
<li>delete是如何知道释放内存的大小的，在分配内存时通常会分配更多一点的内存用于保存元数据，元数据中会记录分配的内存大小，对于new[]和delete[]，元数据中还会记录数组的长度，这样在delete[]就会按逆序依次调用析构函数</li>
</ol>
<h2
id="说说什么是对象复用什么是零拷贝">说说什么是对象复用，什么是零拷贝</h2>
<ol type="1">
<li>对象复用是一种用于避免对象反复构造和销毁的技术，通过将对象保存到对象池中即可实现对象复用，避免资源浪费</li>
<li>零拷贝是指避免CPU将数据从一块内存中拷贝到另一块内存中，C++中的emplace_back就属于零拷贝技术</li>
</ol>
<h2 id="说说指针和引用">说说指针和引用</h2>
<ol type="1">
<li>指针和引用分属C++类型系统中不同的复合类型，指针是一个保存地址的变量，引用是一个别名，引用可以看作是指针的语法糖</li>
<li>指针可以置空，引用不可以，指针可以改变指向的数据，引用不可以</li>
<li>从编译角度看，在编译时会将指针和引用添加到符号表，符号表中记录了变量名和变量对应的地址。对于指针来说，符号表上记录了指针变量的地址，而对于引用来说，符号表上记录引用对象的地址</li>
</ol>
<h2
id="说说类如何实现只静态分配和只动态分配">说说类如何实现只静态分配和只动态分配</h2>
<ol type="1">
<li>重载new和delete运算符为private属性即可实现只静态分配</li>
<li>将构造函数和析构函数设置为protected属性即可实现只动态分配</li>
</ol>
<h2
id="说一说函数查找和重载解析的过程">说一说函数查找和重载解析的过程</h2>
<ol type="1">
<li>函数调用可以分为两种形式，一种是非限定调用，即只使用函数名的调用；另一种是限定调用，即作用域运算符（::）和成员访问符(./-&gt;)</li>
<li>函数的查找的过程也就分为了非限定调用函数的查找和限定调用函数的查找，对于非限定调用函数，会从当前作用域逐层向外查找（局部作用域，外层函数作用域，类作用域，命名空间作用域，全局作用域），并且进行参数依赖查找，即会额外搜索参数类型所属的命名空间或类（基本类型不涉及ADL），优先级关系为当前作用域，ADL扩展的作用域，外层作用域；对于限定函数的查找，只搜索指定作用，不会触发ADL</li>
<li>重载解析，重载解析的关键在于构建函数调用候选集和匹配决议，首先通过函数查找规则来构建候选集，然后通过优先级规则来匹配具体的函数。优先级最高的是参数精准匹配，其次是参数存在类型提升，然后是参数存在类型转换（标准转换大于用户自定义转换）</li>
</ol>
<h2 id="说说volatile的作用">说说volatile的作用</h2>
<ol type="1">
<li>volatile主要有三大特性，分别是易变性，不可优化性和顺序性</li>
<li>易变性是指该值可能被意料之外的因素修改（例如其他线程），要求编译器每次都从内存中读取</li>
<li>不可优化性是指不让编译器直接对变量进行优化（例如常量传播，无用代码消除等）</li>
<li>顺序性是指保证volatile变量之间的顺序性</li>
<li>值得一提的是volatile并不保证原子性</li>
</ol>
<h2 id="解释下-c-中类模板和模板类的区别">解释下 C++
中类模板和模板类的区别</h2>
<p>类模板是一个模板，是一个生成类的蓝图，本身并不是一个类；而模板类是一个类，是类模板实例化的一个结果</p>
<h2 id="说说auto和decltype">说说auto和decltype</h2>
<ol type="1">
<li>auto的作用是自动推导变量的类型，根据初始化表达式推断变量的类型，因此atuo变量必须具有初始化表达式，auto推导不会保留const属性和引用属性</li>
<li>decltype的作用是推导表达式的类型，且保留所有修饰符，decltype的推导是不求值的。如果推导的对象是变量名，那么直接推导变量的类型。对于复杂表达式，根据值类别推导，具体来说，如果表达式的结果是左值，那么推导的结果是T&amp;，如果表达式的结果是右值，那么推导的结果是T</li>
</ol>
<h2
id="为什么成员列表初始化速度比函数体内的初始化速度块">为什么成员列表初始化速度比函数体内的初始化速度块</h2>
<p>因为成员列表初始化直接匹配成员的构造函数，而函数体内的初始化本质是调用构造赋值，故速度更快</p>
<h2
id="构造函数和析构函数应不应该抛出异常">构造函数和析构函数应不应该抛出异常</h2>
<ol type="1">
<li>构造函数可以抛出异常，但需要正确处理，因为构造函数抛出异常时，对象构造不完全，不会调用析构函数</li>
<li>析构函数不应该抛出异常，若析构函数在栈展开（处理异常）过程中抛出异常，C++
会调用 <code>std::terminate</code>，直接终止程序 # STL ## 请说说 STL
的基本组成部分</li>
<li>STL由6部分组成，分别是容器，算法，迭代器，
仿函数，适配器，分配器</li>
<li>容器是一种数据结构，以模板类的形式提供，包括序列容器，关联容器和无序容器</li>
<li>算法是用于操作容器的模板函数，屏蔽了数据结构与数据类型的区别</li>
<li>迭代器提供了访问容器中元素的方法，包括输入迭代器，输出迭代器，前向迭代器双向迭代器和随机访问迭代器</li>
<li>仿函数是函数对象，行为上类似于函数调用，通过重载括号实现</li>
<li>适配器是⽤来修饰容器，仿函数或迭代器接⼝的东⻄</li>
<li>分配器用于管理对象的创建与销毁，内存的分配与释放</li>
</ol>
<h2 id="说说-stl-中-map-hashtable-deque-list-的实现原理">说说 STL 中 map
hashtable deque list 的实现原理</h2>
<ol type="1">
<li>map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表</li>
<li>map内部实现了一个红黑树，由于红黑树是一个二叉搜索树，故内部数据是有序的</li>
<li>hashtable采用了函数映射的思想，可以实现快速的查找</li>
<li>deque内部是一个双向队列，元素在内存中连续存放，随机存取任何元素都在常数时间完成</li>
<li>list内部实现的是一个双向链表，元素在内存不连续存放</li>
</ol>
<h2 id="请你来介绍一下-stl-的分配器">请你来介绍一下 STL 的分配器</h2>
<ol type="1">
<li>分配器的核心职责有两个部分，一是内存的分配和释放，二是对象的构造和析构</li>
<li>分配器通过allocate和deallocate管理内存，通过construct和destroy完成对象的构造与析构</li>
</ol>
<h2 id="stl-容器用过哪些查找的时间复杂度是多少为什么">STL
容器用过哪些，查找的时间复杂度是多少，为什么</h2>
<ol type="1">
<li>常用STL容器有vector，deque，list，set，map，unordered_set，unordered_map等</li>
<li>vector的增删时间复杂度为O(N)，查找的时间复杂度为O(1)</li>
<li>deque的增删时间复杂度为O(N)，查找的时间复杂度为O(1)</li>
<li>list的增删时间复杂度为O(1)，查找的时间复杂度为O(N)</li>
<li>map和set的增删查找时间复杂度均为O(NlogN)</li>
<li>unordered_map、unordered_set的增删查找时间复杂度，最好时为O(1)，最坏为O(N)</li>
</ol>
<h2 id="说说解决哈希冲突的方法">说说解决哈希冲突的方法</h2>
<ol type="1">
<li>解决哈希冲突常用的方法有线性探测，开链，再散列，二次探测等方法</li>
<li>线性探测是指发生冲突时向后依次查找，找到表尾部就返回表头，直到找到空位</li>
<li>开链是指每个位置维护一个链表，如果计算后位置相同则放入链表中</li>
<li>再散列是指发生冲突后用另一种哈希算法再计算一个地址，直到没有冲突</li>
</ol>
<h2 id="说说迭代器失效问题">说说迭代器失效问题</h2>
<ol type="1">
<li>迭代器失效是因为对容器操作后容器内部的存储结构发生了变化导致的</li>
<li>常见的迭代器失效情况有，vector中erase一个元素后，该元素之后的所有迭代器失效，迭代器失效的原因在于，删除元素后，vector为了保证数据的连续性需要把后续的元素依次前移一个位置</li>
</ol>
<h1 id="操作系统">操作系统</h1>
<h2
id="说说进程线程和协程的联系与区别">说说进程，线程和协程的联系与区别</h2>
<ol type="1">
<li>进程是资源分配的基本单位，程序运行时可能会创建一个进程，也可能创建多个进程。进程切换的开销较大，需要由用户态切换至内核态，同时需要切换虚拟内存空间，内核栈，硬件上下文等内容，开销较大</li>
<li>线程是资源调度的基本单位，每一个进程都有一个唯一的主线程，主线程和进程是相互依存的关系，当主线程结束时，进程也会结束，线程的切换开销相对较小，需要由用户态切换至内核态，仅保存少量寄存器内容</li>
<li>协程是一个轻量级的线程，线程内部调度的基本单位，由于协程切换不需要进入内核态，故切换开销最小</li>
</ol>
<h2 id="说说外中断和内中断是什么">说说外中断和内中断是什么</h2>
<ol type="1">
<li>外中断是由cpu执行指令之外的事件引起的，例如IO中断，代表设备的输入输出任务已完成，需要处理器发送下一阶段的任务</li>
<li>内中断也称为异常，是由cpu执行指令引起的，例如除0异常，地址越界等，
可以分为 陷阱（Trap），故障（Fault）和终止（Abort）三类</li>
</ol>
<h2 id="说说进程调度算法">说说进程调度算法</h2>
<ol type="1">
<li>常见的进程调度算法包括，先来先服务，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列等算法</li>
<li>先来先服务时一种非抢占式的调度算法，有利于长作业，不利于短作业。而短作业优先任务则刚好相反，缺点是可能会出出现长作业饿死的情况</li>
<li>最短剩余时间优先是一种抢占式调度算法，当有新的作业到达时，会与当前作业的剩余时间进行对比，由此决定哪一个线程被挂起</li>
<li>时间片轮转是将所有进程按序存入队列中，然后将CPU时间分配给队首的进程，当时间片结束时发起时钟中断，当前进程送往队尾</li>
<li>优先级调度是根据进程优先级进行调度的算法，而多级反馈队列综合了前面的多种调度算法</li>
</ol>
<h2 id="说说linux下的进程通信方式">说说Linux下的进程通信方式</h2>
<ol type="1">
<li>可以通过消息队列，共享内存，信号，信号量，套接字和管道6种方式通信</li>
<li>消息队列是一个消息链表，存放在内核中，消息队列独立于收发进程</li>
<li>共享内存是指映射一段可供其他进程访问的内存</li>
<li>信号量是一个计数器，用于控制多个进程对资源的访问，常用于同步和互斥访问的情况</li>
<li>信号用于通知进程某个时间的发生</li>
<li>套接字常用于不同主机之间的进程通信</li>
<li>管道可以分为无名管道和有名管道，是一种半双工的通信方式，数据单向流通，其中无名管道只能用于具有亲缘关系的进程通信（父子进程或者兄弟进程），而有名管道可以用于无关进程之间的通信</li>
</ol>
<h2 id="说说动态分区算法">说说动态分区算法</h2>
<ol type="1">
<li>常见的动态分区算法由首次适配算法，最佳适配算法，最坏适配算法和邻近适配算法</li>
<li>首次适配算法是指每次都从低地址开始查找，直到找到第一个满足大小的分区</li>
<li>最佳适配算法是指优先使用满足大小但最小的分区</li>
<li>最坏适配算法是指使用最大的空闲分区</li>
<li>临近适配算法是指，每次都从上一次查找结束的位置开始搜索满足大小的分区</li>
</ol>
<h2 id="说说虚拟技术">说说虚拟技术</h2>
<ol type="1">
<li>常见的虚拟技术有时分复用和空分复用两种</li>
<li>时分复用的应用例如并发，空分复用的应用例如虚拟内存</li>
</ol>
<h2 id="说说虚拟内存的作用">说说虚拟内存的作用</h2>
<ol type="1">
<li>虚拟内存的目的是为了将物理内存映射为逻辑内存，让程序获得更多的可用内存</li>
<li>实现内存隔离，不同的进程拥有各自的虚拟内存空间，防止数据被篡改</li>
<li>避免内存碎片，物理内存可能不连续，但虚拟内存是连续的</li>
</ol>
<h2 id="说一说常见的几种锁">说一说常见的几种锁</h2>
<ol type="1">
<li>包括读写锁，互斥锁，条件变量和自旋锁</li>
<li>读写锁是允许同时读，不允许同时写，且写者优先于读者</li>
<li>互斥锁则是一次只能由一个线程持有互斥锁，其他线程只能等待，用于线程互斥</li>
<li>条件变量则是用于线程同步，常与互斥锁配合使用，避免出现竞态条件</li>
<li>自旋锁是指，当程序获取锁失败时，不会直接放弃cpu时间，而是一直循环尝试获得锁，一般用于加锁时间很短的场景</li>
</ol>
<h2 id="说一说内存交换">说一说内存交换</h2>
<ol type="1">
<li>内存交换是指将内存中暂时不用的进程或数据整体移至磁盘交换区，腾出内存空间供其他进程使用，需要时再换回内存</li>
</ol>
<h2
id="说说地址变换中有快表和没快表的流程">说说地址变换中，有快表和没快表的流程</h2>
<ol type="1">
<li>当没有快表时，首先计算页号和页内偏移，然后检查页号合法性，合法就查询页表，找到对应的块号即可访问物理地址</li>
<li>当存在快表时，检查完页号合法性后会查询块表，如果快表命中则可以从块表中直接获取到块号</li>
</ol>
<h2 id="说说malloc申请内存的流程">说说malloc申请内存的流程</h2>
<ol type="1">
<li>malloc申请内存主要依赖两个系统调用，分别是brk和mmap</li>
<li>当申请的内存少于128KB时，如果申请的内存小于64B时从fast_bins中获取空闲块，fast_bins是一个单链表，每一个空闲块的大小都是64B；如果申请的内存大于64B小于512B时，从small_bins中挑选合适的空闲块，small_bins是多个单链表，每个单链表管理大小相同的空闲块，单链表管理的空闲块大小按一定步长递增；当申请的内存大于512B小于128KB时，从large_bins中获取空闲块；如果没有合适的空闲块，则调用brk，通过抬高.data数据段最高处的指针获取新的虚存</li>
<li>当申请的内存大于128kb时，调用mmap通过搜索空闲的虚拟内存获取可操作的堆内存</li>
</ol>
<h2
id="说说守护进程僵尸进程和孤儿进程">说说守护进程，僵尸进程和孤儿进程</h2>
<ol type="1">
<li>孤儿进程是指父进程结束，但父进程的一个或多个子进程还在运行，这些子进程此时会成为孤儿进程，被init进程接管</li>
<li>僵尸进程是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程</li>
<li>守护进程是一种运行在后台且生存期较长的特殊进程，它独立于控制台，常用于处理一些系统级别的任务</li>
</ol>
<h2 id="说说怎么处理僵尸进程">说说怎么处理僵尸进程</h2>
<ol type="1">
<li>一种方式是使用signal通知内核对子进程的结束不关系，由内核回收</li>
<li>另一种方式是在父进程中调用wait或waitpid</li>
</ol>
<h2 id="说说常见的磁盘调度算法">说说常见的磁盘调度算法</h2>
<ol type="1">
<li>先来先服务算法，按请求顺序调度，公平，但寻道时间可能较长</li>
<li>最短寻道时间优先，优先调度距离当前磁头最近的磁道，可能会导致饥饿</li>
<li>电梯扫描算法，按一个方向进行调度，直到该方向没有磁盘请求，不存在饥饿问题</li>
</ol>
<h2 id="说说抖动现象">说说抖动现象</h2>
<ol type="1">
<li>抖动现象是指刚换出的页面立刻又要换入内存，刚换入的页面立刻又要换出，造成这一现象的原因通常是分配的物理块少于频繁使用的页面数</li>
</ol>
<h2
id="说说死锁产生的必要条件以及如何解除死锁">说说死锁产生的必要条件，以及如何解除死锁</h2>
<ol type="1">
<li>死锁产生的必要条件包括4个，互斥条件，不剥夺条件，请求和保持条件，循环等待条件</li>
<li>常见的方法有死锁的检测与恢复，利用资源分配图检查是否存在死锁，恢复则可通过抢占式恢复，回滚恢复和杀死进程恢复；死锁的预防，该方法通过破坏死锁的四个必要条件完成；死锁的避免，常用的方法有银行家算法</li>
</ol>
<h2
id="说受什么是内部碎片什么是外部碎片">说受什么是内部碎片，什么是外部碎片</h2>
<ol type="1">
<li>内部碎片常见于固定分配方式，即分配的内存区域有一部分没有用上</li>
<li>外部碎片常见于动态分配方式，即内存的有些空闲区较小，难以利用上，外部碎片可以通过紧凑技术解决</li>
</ol>
<h2
id="说说冯诺依曼结构以及分别对应现代计算机的哪几个模块">说说冯诺依曼结构，以及分别对应现代计算机的哪几个模块</h2>
<ol type="1">
<li>冯诺依曼结构包括输入设备，输出设备，存储器，控制器，运算器这几部分</li>
<li>输入设备对应键盘，输出设备对应显示器，存储器对应内存，控制器对应南桥北桥，运算器对应cpu</li>
</ol>
<h2
id="说说什么是大端小端如何判断大端小端">说说什么是大端小端，如何判断大端小端</h2>
<ol type="1">
<li>大端存储是指数据高位存在低字节部分，符合人们的阅读习惯，小端存储则相反，数据低位存在低字节部分</li>
<li>可以通过int i =
1;然后用一个char指针取变量i首地址的数据，如果等于0是大端存储，如果是1就是小端存储</li>
</ol>
<h2 id="说说进入内核态的方式">说说进入内核态的方式</h2>
<ol type="1">
<li>通常有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</li>
</ol>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="说说路由协议">说说路由协议</h2>
<ol type="1">
<li>路由可以分为静态路由和动态路由，静态路由由管理员手动维护，动态路由则根据路由协议维护</li>
<li>路由选择的必要步骤包括：1）向其他路由器传递路由信息。2）接收其他路由器的路由信息。3）根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表。4）根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由信息的形式告知其它路由器</li>
<li>常见的路由协议包括RIP，IGRP，OSPF协议等</li>
</ol>
<h2 id="说说dns查询服务器的基本流程">说说DNS查询服务器的基本流程</h2>
<ol type="1">
<li>当打开浏览器输入一个网址的时候，首先会检查本地host文件，查询是否由这个地址映射关系，当没有找到时，会向本地DNS服务器发送DNS请求，如果在本地DNS服务器的缓存中查询到了结果，则直接返回结果</li>
<li>当本地DNS服务器没有查询到结果时，向DNS根服务器发送请求，根服务器会返回域服务器地址，然后本机向域服务器发起请求，然后域服务器会返回域名解析服务器的地址，最后本机向域名解析服务器发送请求获得最终的IP地址，然后本地host文件缓存这个映射关系</li>
</ol>
<h2
id="说说tcp三次握手和四次挥手的过程">说说TCP三次握手和四次挥手的过程</h2>
<ol type="1">
<li>第一次握手：建立连接时，客户端向服务器发送SYN包（seq =
x），请求建立连接，等待确认</li>
<li>第二次握手：服务器端收到客户端的SYN包，回一个ACK包（ack =
x+1），确认收到，然后发送一个SYN包（seq = y）给客户端</li>
<li>第三次握手，客户端收到服务器端发送的SYN和ACK包，回一个ACK包（ack =
y+1），告诉服务器端收到，此时连接建立成功，开始传输数据</li>
<li>第一次挥手，客户端发送FIN包（fin =
1）给服务器端，请求终止连接，此时客户端不再发送数据，但是可以接收数据</li>
<li>第二次挥手，服务器端收到FIN包，回一个ACK包给客户端，但此时还没有断开连接，等待剩余数据传送结束</li>
<li>第三次挥手，服务器端等待数据传送结束后，向客户端发送FIN包，表明可以断开连接</li>
<li>第四次挥手，客户端收到后，回一个ACK包表示收到，进入TIME_WAIT状态，等待2MSL后如果没有数据发来，正式断开连接</li>
</ol>
<h2 id="说说tcp和udp的区别">说说TCP和UDP的区别</h2>
<ol type="1">
<li>TCP是有连接的，可靠的，TCP协议保证数据按序发送，按序到达，提供超时重传保证可靠性，并且提供流量控制和拥塞控制，TCP连接是一对一的</li>
<li>UDP是无连接的，不可靠的，只是尽力交付，UDP支持一对一，多对多和一对多的通信</li>
</ol>
<h2 id="说说mac地址和ip地址">说说MAC地址和IP地址</h2>
<ol type="1">
<li>MAC地址是物理设备表示，IP地址是</li>
</ol>
<h2 id="说说tcp中常见的拥塞控制算法">说说TCP中常见的拥塞控制算法</h2>
<ol type="1">
<li>有慢启动拥塞控制和快恢复快重传算法</li>
</ol>
<h2
id="说说如果三次握手时候每次握手信息对方没收到会怎么样分情况介绍">说说如果三次握手时候每次握手信息对方没收到会怎么样，分情况介绍</h2>
<h2
id="说说什么是-msl为什么客户端连接要等待2msl的时间才能完全关闭">说说什么是
MSL，为什么客户端连接要等待2MSL的时间才能完全关闭</h2>
<h2 id="说说什么是-tcp-粘包和拆包">说说什么是 TCP 粘包和拆包</h2>
<h2 id="说说浏览器从输入-url-到展现页面的全过程">说说浏览器从输入 URL
到展现页面的全过程</h2>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>逆向之植物大战僵尸（一）</title>
    <url>/2023/02/21/2023-02-21-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>植物大战僵尸是一款很适合逆向入门的游戏，而设计的辅助主要实现了下面几个功能：<br />
1. 无限阳光和无限金币<br />
2. 取消植物放置的CD<br />
3. 同一个位置可以重复放置植物</p>
<h3 id="无限阳光">无限阳光</h3>
<h4 id="静态基址与动态地址">静态基址与动态地址</h4>
<ol type="1">
<li><p>静态基址：是指静态基址中的内容，不会因程序的重新启动而改变，只有在程序重新编译后才会变动</p></li>
<li><p>动态地址：是指地址中的内容，会因程序的重新启动而变动的地址，也就是说，当前状态下，地址中保存的信息是我们所需的信息，但程序重新启动后，该地址中的内容就不再是我们所需的信息了</p></li>
</ol>
<span id="more"></span>
<h4 id="寻找阳光动态地址">寻找阳光动态地址</h4>
<ol type="1">
<li>首先通过CE附加植物大战僵尸进程，因为阳光是一个精确的数值50，所以可以选择exact
value来进行搜索，首次搜索会得到很多相关的结果</li>
</ol>
<figure>
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光1.png"
alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure>
<ol start="2" type="1">
<li>收集一个阳光后，改变数值为75并再次搜索，此时搜索到唯一的一个结果</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-%E9%98%B3%E5%85%892.png" />
为了验证这个结果是否正确，我们可以手动修改地址中的数值</p>
<p>如何判断这个地址是否是静态基址，若CE标识的地址为绿色，则该地址为静态基址，而此处的地址并不是绿色的，所以这是个动态地址，因此我们需要寻找基址</p>
<h4 id="寻找基址">寻找基址</h4>
<ol type="1">
<li>我们已经找到了阳光的动态地址，那么如何寻找基址，思路是，阳光每次变动就意味着一定有一条指令修改了这个地址中的值，那么我们可以下一个内存写入断点，看看哪条指令写入了这个地址，所以我们再CE中选中这个地址，右键找到find
out what writes to this address</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光3.png" /></p>
<p>之后我们收集一个阳光，发现得到了一条指令，我们双击打开</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光4.png" /></p>
<p>此时我们可以知道，ecx的值0x19，也就是25，写入了阳光地址标识的内存中，因此阳光的地址
= eax + 0x5560，该地址内存放了当前阳光的具体数值，其中eax =
0x17326B58，而0x5560为偏移地址</p>
<ol start="2" type="1">
<li>此时我们猜想，内存中有没有一个位置存放了0x17326B58这个值，因此我们可以使用CE，并以16进制搜索0x17326B58，发现很多搜索结果，首先可以排除地址在0x00400000以下的内容，这部分是不进行映射的，以便捕获异常的空指针引用，因此我们找到第一个大于0x00400000的地址，这个值通常是我们需要的，即0x0290A938</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光5.png" /></p>
<p>此时我们可以知道0x0290A938这个地址内保存了0x17326B58这个值，但是0x0290A938这个地址仍是个动态地址，所以我们还需要进一步寻找基址</p>
<p>此时我们用CE下个内存访问断点，查看哪条指令访问了0x0290A938这个地址内的值，可以看到4个结果，我们点进第一个指令发现0x0290A938
= edi + 0x768，其中edi = 0290A1D0，0x768也是偏移地址</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光6.png" /></p>
<p>那么同理我们可以看看内存中哪里存放了0290A1D0，得到如下结果</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光7.png" /></p>
<p>这时我们看到几个绿色的地址，这就代表这些地址就是静态基址，我们选择第一个，可以看到其地址为0x6A9EC0，这就是我们需要的静态基址，那么如何通过静态基址找到最后的阳光地址呢</p>
<ol type="1">
<li>现在梳理一下这个过程
<ul>
<li>阳光的动态地址 = 0x17326B58 +
0x5560，而0x17326B58存在地址为0x0290A938的内存中，即[0x0290A938] =
0x17326B58</li>
<li>地址0x0290A938 = 0290A1D0 +
0x768，而0290A1D0存在地址为静态基址为0x6A9EC0的内存中，即[0x6A9EC0] =
0x0290A1D0</li>
<li>所以我们可以得到，阳光地址 = [[0x6A9EC0] + 0x768] + 0x5560</li>
</ul></li>
</ol>
<p>之后我们在CE中验证我们的结果，选择add address manually</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光8.png" /></p>
<p>之后选择Point，因为此处包含两个偏移地址，因此再点击add
offset，然后填入我们找到的基址与偏移地址</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光9.png" /></p>
<p>最终我们可以看到，这个地址内，存的就是当前阳光的数值，修改后，游戏内的阳光也随之改变，且重启游戏后，该地址仍然存的是阳光的数值</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-21-阳光10.png" /></p>
<h4 id="实现无限阳光的功能">实现无限阳光的功能</h4>
<p>的到进程空间中阳光的地址，并向阳光地址处写入所需阳光数，即可实现无限阳光的功能，具体实现细节就不做赘述，给出核心代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将寻找地址功能封装成GetThirdLevelAddress()函数，方便后续寻找金币地址</span></span><br><span class="line">DWORD sunAddress = <span class="built_in">GetThirdLevelAddress</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义阳光数量</span></span><br><span class="line">DWORD dwSun = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入             </span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, (LPVOID)sunAddress, (LPCVOID)&amp;dwSun, <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD), &amp;pid)          </span><br></pre></td></tr></table></figure>
<p>金币地址的寻找大同小异，这里也不再赘述，这样我们就完成了无限阳光与无限金币的功能</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2022/02/16/2022-02-16-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p><strong>二分查找的思路非常简单，但在实际写算法的过程中发现有很多细节还需要多加理解，比如</strong></p>
<p>① 为什么有时right = nums.size()，有时却是right = nums.size() -
1<br />
② while循环中的条件，为什么有时是&lt;=，有时是&lt;<br />
③ 在区间划分时，为什么有时left = mid + 1，right = mid - 1; 有时却是left
= mid + 1,right = mid</p>
</blockquote>
<span id="more"></span>
<hr />
<p>以最简单的二叉搜索为例 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找的基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="comment">// 取mid的另一种形式</span></span><br><span class="line">        <span class="comment">// mid = (left + right) / 2与mid = left + (right - left) / 2</span></span><br><span class="line">        <span class="comment">// 在形式上是等价的，区别是前者存在溢出的可能</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;    </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == targrt)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="区间与循环终止的条件">区间与循环终止的条件</h2>
<h3 id="区间">区间</h3>
<ol type="1">
<li><strong>两种比较常见的区间形式</strong>
<ul>
<li>两端都是闭区间：[left，right]，即<strong>right = nums.size() -
1</strong></li>
<li>左闭右开：[left，right)，即<strong>right =
nums.size()</strong>（右边界在数组中越界）</li>
</ul></li>
<li><strong>left = mid + 1，right = mid - 1与left = mid + 1，right =
mid两种划分区间的方式有何区别</strong>
<ul>
<li>对于两端都是闭区间的[left，right]，因为mid已经搜索过，也就是将整个区间分为了三个部分，即[left，mid
- 1]、[mid]、[mid + 1，right]，此时<strong>left = mid + 1，right = mid -
1</strong></li>
<li>对于左闭右开的[left，right)，因为mid已经搜索过，区间也分为了三个部分，为了保持区间形式的一致性，此时的三个区间应该是[left，mid)、[mid]、[mid
+ 1，right)，故<strong>left = mid + 1，right = mid</strong></li>
<li>同理，对于左开右闭的(left，right]，三个区间应该是(left，mid -
1]、[mid]、(mid，right]，故<strong>left = mid，right = mid -
1</strong></li>
</ul></li>
</ol>
<h3 id="循环终止条件">循环终止条件</h3>
<ol type="1">
<li><strong>为什么有时是&lt;=，有时是&lt;</strong>
<ul>
<li>对于<strong>left &lt;= right</strong>，当循环结束时，left = right +
1，无论区间形式是[right，left]，还是[left，right)，此时整个序列都已经搜索完毕，待搜索区间为空（但后者会出现错误）</li>
<li>对于<strong>left &lt; right</strong>，当循环结束时，left =
right，区间形式是[left，left]或[left，left)
<ul>
<li>也就是说对于两端都是闭区间的[left，right]形式，当循环结束时，整个序列并没有搜索完毕，剩下了一个[left，left]尚未搜索，此时并不能直接返回，需要再做处理</li>
<li>而对于左闭右开的[left，right)形式，当循环结束时，整个序列已经搜索完毕（不会出现错误）</li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于left &lt; right，且是[left, right]形，需要补充</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="具体使用">具体使用</h3>
<ol type="1">
<li><strong>是否可以随意搭配使用</strong>
<ul>
<li>不可以，正如上面所说，<strong>对于循环结束条件为left &lt;=
right</strong>与<strong>左闭右开的[left，right)形式</strong>组合使用时，无论采取何种划分区间的方式，总是会出现错误</li>
</ul></li>
<li><strong>以nums = {0，2，4，5}为例分析</strong>
<ul>
<li>当target在数组中确实存在时（如target = 2），此时可以正常工作</li>
<li>当 <span class="math inline">\(\displaystyle target
\le  5\)</span>但不等于数组中的任一一个值时（如target = 3或target = -1）
<ul>
<li>以<strong>left = mid + 1，right =
mid</strong>方式划分区间，此时会造成while死循环，原因是区间收缩的<strong>最后一步</strong>总是右边界向左收缩，即right
= mid，导致left = right恒成立，故无法跳出循环</li>
<li>以<strong>left = mid + 1，right = mid -
1</strong>方式划分区间，此时可以正常工作</li>
</ul></li>
<li>当 <span class="math inline">\(\displaystyle target
&gt;  5\)</span>时（如target = 7）
<ul>
<li>以<strong>left = mid + 1，right =
mid</strong>方式划分区间，可以正常工作</li>
<li>以<strong>left = mid + 1，right = mid -
1</strong>方式划分区间，此时会造成数组越界，原因是区间收缩的过程<strong>一直是</strong>左边界向右收缩，即left
= mid + 1，最终收缩到left =
right，而区间形式是[left，right)的，此时无法在right处取到数据，故数组越界</li>
</ul></li>
</ul></li>
<li><strong>如何解决</strong>
<ul>
<li>上面已经分析了，只有<strong>循环结束条件为left &lt;=
right</strong>与<strong>左闭右开的[left，right)形式</strong>组合使用时会出错，那么只需要避免使用这种组合即可，也就是有3中正确的组合方式
<ul>
<li><strong>循环结束条件为left &lt;=
right</strong>与<strong>两端都是闭区间的[left，right]形式</strong>组合</li>
<li><strong>循环结束条件为left &lt;
right</strong>与<strong>左闭右开的[left，right)形式</strong>组合</li>
<li><strong>循环结束条件为left &lt;
right</strong>与<strong>两端都是闭区间的[left，right]形式</strong>组合（循环结束会剩下[left，left]需要单独处理，因此最好是使用前两种固定组合）</li>
</ul></li>
</ul></li>
</ol>
<h2 id="二分查找的进阶运用">二分查找的进阶运用</h2>
<p>除了基础的使用二分查找在有序序列中搜索一个数，还有两种进阶的使用方式，代码也需要做一些小的修改</p>
<h3 id="寻找左边界">寻找左边界</h3>
<ol type="1">
<li><strong>假如有一个有序序列[1, 2, 2, 2, 3,
4]，现在要找到第一个’2‘所在位置的下标</strong>
<ul>
<li>一个容易想到的办法是顺序遍历这个有序序列，就能轻松的找到一个’2‘的下标</li>
<li>另一个办法就是使用二分查找来减少搜索的次数，但用上述的二分查找代码，我们得到并不是第一个’2‘的下标1，而是第二个’2‘的下标2，故此时需要对二分查找进行一定的改进</li>
</ul></li>
<li><strong>怎么改进代码</strong>
<ul>
<li>在之前提到，对于<strong>循环结束条件为left &lt;
right</strong>的形式，循环结束时，left =
right，而<strong>左闭右开的[left，right)</strong>形式，能保证在循环结束时完整的遍历整个序列，因此，最终需要确定的就是如何划分区间</li>
<li>一个关键的地方在于，普通的查找，只要找到target就立刻返回（即存在nums[mid]
=
target就返回），但此时为了查找左边界就不应该这么操作，而是应该收缩右边界，即<strong>right
=
mid</strong>，此时二分查找会继续搜索[left，right)是否还有满足要求的target，最终找到左边界</li>
</ul></li>
<li><strong>代码与例题</strong>
<ul>
<li>例题：<a
href="https://leetcode-cn.com/problems/first-bad-version/">leetcode
278.第一个错误版本</a>（原理相同）</li>
<li>代码</li>
</ul></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeftBoundary</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> left </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;    </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == targrt)&#123;</span><br><span class="line">            right = mid;    <span class="comment">// 收缩右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>
<h3 id="寻找右边界">寻找右边界</h3>
<ol type="1">
<li><strong>怎么改进代码</strong>
<ul>
<li>根据寻找左边界的思想，不难想到，当找到target时，不立刻返回，而是收缩左边界，为了保证<strong>左闭右开的[left，right)</strong>形式，应该令<strong>left
= mid + 1</strong>，需要注意的是，因为是左边界收缩到left =
right，而right是开区间，故<strong>实际的右边界是right - 1（或left -
1）</strong></li>
</ul></li>
<li><strong>代码与例题</strong>
<ul>
<li>例题：指定一个target，要求找到其在非降序的数组nums中的插入位置的下标，要求插入后还要保持非降序的特性（例如target
= 3， nums[1, 2, 2, 2, 4, 5]，此时应该返回下标4）</li>
<li>代码</li>
</ul></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RightBoundary</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> left </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;    </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == targrt)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;    <span class="comment">// 收缩右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;        <span class="comment">// 实际的右边界是left - 1</span></span><br><span class="line">                        <span class="comment">// 但插入位置是右边界之后的位置，故直接返回left即可</span></span><br></pre></td></tr></table></figure>
<h3 id="tips">Tips</h3>
<ol type="1">
<li><p>二分查找的使用并不严格要求所求序列有序，如：<a
href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852.
山脉数组的峰顶索引</a></p></li>
<li><p>二分查找的重点在于理解，并明确所求，如何时是查找左边界，何时是查找有边界，对于两种常见的组合形式</p>
<ul>
<li><strong>循环结束条件为left &lt;=
right</strong>与<strong>两端都是闭区间的[left，right]形式</strong>组合</li>
<li><strong>循环结束条件为left &lt;
right</strong>与<strong>左闭右开的[left，right)形式</strong>组合</li>
</ul></li>
</ol>
<p>最后都可以完成<strong>利用二分查找搜索数</strong>、<strong>寻找左边界</strong>、<strong>寻找右边界</strong>的功能，不同的组合只需要根据不同的应用场合做一定的边界处理即可</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>逆向之植物大战僵尸（三）</title>
    <url>/2023/02/27/2023-02-27-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p><a
href="https://colaxianyu.github.io/2022/02/27/2022-2-27-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%BA%8C%EF%BC%89">上一章</a>我们实现了植物无CD的功能，主要使通过定位CDTimers间接定位到了if判断的位置，并通过使用nop填充jle指令，改变了程序的执行流程，使其总是运行植物不处于CD状态中的代码</p>
<p>现在我们希望实现另一个功能，即在同一个位置能够重复的放置植物</p>
<h3 id="同一格重复放置植物">同一格重复放置植物</h3>
<h4 id="思路">思路</h4>
<ol type="1">
<li><p>思路一：我们假设放置植物是通过一个二维数组记录的，当二维数组中记录如-1之类的值时，代表位置空闲，可以放置植物，当数组中记录植物编号时，代表位置被占用，不可放置，该思路需要我们能定位到该二维数组，在放置植物时保证二维数组中的值不变，使该位置为空位置</p></li>
<li><p>思路二：在我们放置植物时，我们需要一个if判断，用于判断该位置是否可放植物，若可放置，则阳光会减少放置植物所需的cost，即该思路需要我们定位一个cmp指令，即</p></li>
</ol>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(可以放置植物)&#123;</span><br><span class="line">    阳光减少</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>通过对比我们可以发现思路二更简单，且方法与上一章实现植物无CD相同，同时，阳光在内存中的位置，我们在第一章中也已经定位到，因此使用思路二能使我们更快的定位到CMP位置，</li>
</ol>
<h4 id="定位是否可以放置跳转">定位是否可以放置跳转</h4>
<ol type="1">
<li>我们已经知道，若在一个空位置放置植物，阳光会减少相应的cost，因此我们在阳光的内存处下一个内存写入断点，之后在一个空位放置向日葵，可以发现CE显示了一条指令，我们双击该指令观察esi的值，发现其中的值正是放置向日葵后的阳光数</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-植物cost.png" /></p>
<ol start="2" type="1">
<li>我们记下该指令的地址，用x64Dbg附加游戏，找到该指令并在此处下一个断点，在游戏中再放一个向日葵，使游戏执行到该处，我们可以看到该指令之后将会返回至另一个位置，在堆栈窗口中，我们可以看到其返回的具体地址</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-堆栈中.png" /></p>
<ol start="3" type="1">
<li>跟进到返回后的位置，我们将该call假设为阳光减少call，我们发现该call周围有大量的跳转指令，且整个代码段中都有大量跳转指令，因此我们无法判断代码段中的哪个跳转指令，此时我们需要一个方法来筛选哪些跳转指令是我们需要关注的</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-阳光call.png" /></p>
<ol start="4" type="1">
<li>一个可行的方法是，我们向上找到该代码段的起始位置，并下一个断点，在游戏中我们先在空闲位置放置一个向日葵，此时程序会断在代码段起始位置，我们单步调试，在每一个跳转指令处记录其是否跳转，以0标记不跳转，1标记跳转，直至该代码段结束</li>
</ol>
<figure>
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-空闲跳.png"
alt="2022-03-01-空闲跳" />
<figcaption aria-hidden="true">2022-03-01-空闲跳</figcaption>
</figure>
<p>之后我们返回游戏，选择向日葵，将其放置在一个有植物的位置，再次单步调试跟进每一个跳转指令，寻找发生变化的跳转指令，之后我们定位到该跳转指令发生了变化</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-非空闲跳转.png" /></p>
<ol type="1">
<li>为了印证该跳转是不是决定了该位置为空位置，我们先在此处下个断点，然后修改其执行流程，因为此次放置非空位置，若修改后可以在同一位置重复放置植物，则成功，若不能重复放置，方便我们从此处再对后续的跳转指令进行对比，这里我们将ZF标志位置为1，je指令从不跳转变为跳转</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-改ZF.png" /></p>
<ol start="6" type="1">
<li>运行游戏，此时我们发现向日葵重复放置在了同一位置，因此该跳转使得我们可以实现重复放置的功能，即跳转则可放，不跳转则不可放，且通过分析反汇编我们不难得出，跳转指令之前的call实现了判断位置是否为空的功能</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-判空.png" /></p>
<ol start="7" type="1">
<li>如果要让跳转指令一直跳转，我们可以将其改为jmp无条件跳转指令，此时回到游戏我们就已经实现了重复种植的功能</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-01-改为jmp.png" /></p>
<h4 id="实现重复放置功能">实现重复放置功能</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JMP 0x00410754的硬编码，硬编码的操作码部分为偏移地址</span></span><br><span class="line">buffer[<span class="number">0</span>] = <span class="number">0xE9</span>;</span><br><span class="line">buffer[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line">buffer[<span class="number">2</span>] = <span class="number">0x09</span>;</span><br><span class="line">buffer[<span class="number">3</span>] = <span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">5</span>] = <span class="number">0x90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充至原je跳转指令处</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess_, (LPVOID)<span class="number">0x0040FE2F</span>, (LPCVOID)buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), &amp;pid_)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>PE文件解析（二）</title>
    <url>/2024/07/03/2024-07-03-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>之前已经对PE文件的总体结构进行了解析，但PE文件中的很多重要的数据还存放在各类数据表中，因此我们还需要对这些表信息进行解析，这里主要包块输入表与输入地址表、输出表、重定位表、资源表五个部分</p>
<h3 id="输入表与输入地址表">输入表与输入地址表</h3>
<h4 id="什么是输入表">什么是输入表</h4>
<p>可执行文件使用来自其他DLL的代码与数据的行为称为输入，当PE文件载入内存时，Windows加载器的工作之一就是找到这些输入的函数与数据，并让文件可以使用这些代码与数据的正确地址，而这个过程正是通过输入表（Import
Table）完成的，输入表中保存了输入的函数名和这些函数所在的DLL名称</p>
<span id="more"></span>
<h4 id="什么是输入地址表">什么是输入地址表</h4>
<p>当我们调用DLL中的函数时，调用者程序无法得知这些函数的实际地址，因为这些函数的实际地址只有当PE文件载入内存中时才得以确定，所以我们采取了一种间接调用的形式，即在内存中仅保留函数名（或序号），通过此方法告知Windows加载器，我们需要这样的一个函数，当PE文件载入内存后，Windows加载器便将相关DLL载入内存，同时将函数名替换成函数实际所处的地址，而记录这些中间函数信息并最终被替换成实际地址的结构即为输入地址表IAT，记住这个转换过程，之后我们会做详细讲解</p>
<h4 id="输入表的结构">输入表的结构</h4>
<p>在了解什么是输入表、什么是输入地址表之后，我们了解下它们载入内存前的大致结构
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-输入表.png" /></p>
<p>我们发现图中一共包含了4张表，分别是输入表IMAGE_IMPORT_DESCRIPTOR、输入名称表（INT）、输入地址表（IAT）、函数表IMAGE_IMPORT_BY_NAME，现在我们分别给出这四个表在winnt.h的具体定义</p>
<p>输入表 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            </span><br><span class="line">        DWORD   OriginalFirstThunk;         </span><br><span class="line">    &#125; DUMMYUNIONNAME;                       <span class="comment">// INT表的RVA</span></span><br><span class="line">    DWORD   TimeDateStamp;                  </span><br><span class="line">    DWORD   ForwarderChain;                 </span><br><span class="line">    DWORD   Name;                           <span class="comment">// DLL名字的RVA</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// IAT表的RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR</span><br></pre></td></tr></table></figure></p>
<ul>
<li>OriginalFirstThunk：指向输入名称表INT的RVA，INT是一个IMAGE_THUNK_DATA结构的数组，数组以一个全0内容来标识数组的结束</li>
<li>TimeDateStamp：32位时间标记</li>
<li>ForwarderChain：当程序使用一个DLL中的API，而该API又使用其他DLL中的API时使用，通常为0</li>
<li>Name：DLL名字的RVA</li>
<li>FirstThunk：指向输入地址表IAT的RVA，与INT类似，IAT也是一个IMAGE_THUNK_DATA结构的数组</li>
</ul>
<p>IMAGE_THUNK_DATA的结构 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      </span><br><span class="line">        DWORD Function;             </span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        </span><br><span class="line">    &#125; u1;                                   </span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
每个IMAGE_THUNK_DATA都对应一个输入函数，由于是一个联合结构，所以其本质是一个大小为4字节的数，但该数在不同时刻具有不同含义</p>
<ul>
<li>当该数的最高位为1时，表示该函数以序号方式输入，此时低31位就是该函数的序号</li>
<li>当该数的最高位为0时，表示该函数以名称方式输入，此时整个32位就代表一个指向IMAGE_IMPORT_BY_NAME的RVA</li>
</ul>
<p>IMAGE_IMPORT_BY_NAME的结构 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Hint：本函数在其所驻留的DLL中输出表的序号，但该值不是必须的，一些链接器直接将其置为0</li>
<li>Name：输入函数函数名的变长数组，以0结尾</li>
</ul>
<h3 id="输入表如何工作">输入表如何工作</h3>
<h4 id="原理">原理</h4>
<p>我们之前提到IAT表承担了将函数名转换成实际地址的功能，其实这就是输入表的主要功能，即载入时替换IAT表中的内容，一旦替换工作完成，那么整个输入表的替他部分就不关键了，程序依靠IAT表中的内容就可以正常运行</p>
<p>我们现在来看PE文件载入内存后输入表的结构，我们可以发现IAT此时不再指向IMAGE_IMPORT_BY_NAME表，其中的内容被填入了函数的实际地址
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-载入后输入表.png" /></p>
<p>具体的工作流程是</p>
<ul>
<li>①PE装载器先通过INT表找出每个IMAGE_IMPORT_BY_NAME结构指向的函数地址</li>
<li>②装载器用函数真正的入口地址来替代IAT中的值</li>
</ul>
<p>也就是说在实际的程序中，当我们调用一个DLL中的函数，其采用了一种间接调用的形式call
dword ptr
[xxxxxxx]，这个xxxxx就是IAT表的地址，当载入内存前，[xxxxxx]指向了IMAGE_IMPORT_BY_NAME中的对应的函数，而载入内存后[xxxxxx]就指向了函数的实际地址，这就是转换工作在程序中的体现</p>
<h4 id="实例">实例</h4>
<p>为了解释这一过程，我们通过一个例子来理解其中的转换过程，例如此处我们的程序使用了一个TestDLL.dll中的Plus函数，首先我们在反汇编程序中观察反汇编代码，可以发现我们我们并不是call了一个绝对地址，而是call了ds:[0x402000]内存里的内容，我们在内存窗口里观察到0x402000处的4字节信息为0x10001050
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-反汇编.png" /></p>
<p>之后我们跟进call中，可以发现来到了Plus函数内部，而地址正是0x10001050，也就是说调用Plus函数是以一种间接调用的形式实现的，且ds:[0x402000]中存了Plus函数载入内存后的实际地址0x10001050
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-DllTest.png" /></p>
<p>此时程序已经载入内存，而我们需要查看其载入内存前ds:[0x402000]的内容，因为该程序的ImageBase为0x400000，那么RVA
=
0x2000，将其转换为FOA即是0x1200，现在我们打开16进制编辑器，找到此处观察发现里面存了一个RVA偏移值0x2778（指向IMAGE_IMPORT_BY_NAME中的对应的函数）
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-Plus偏移.png" /></p>
<p>我们将0x2778转换为其对应的FOA，即0x1978，我们来到该处可以看到这里记录了函数的名字
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-Plus具体位置.png"
alt="2022-03-09-Plus具体位置" /></p>
<p>现在我们已经分析完了输入表的整个工作流程，通过PE
tools我们可以查看完整的输入表信息</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-Plus.png" /></p>
<p>需要注意的是，我们的程序使用了多少个DLL，就会有多少个输入表，且输入表也是以一个全0的结构作为判空标识的，最后，我们用一个简单的图来回顾整个过程</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-09-总结.png" /></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>PE文件解析（一）</title>
    <url>/2024/07/01/2024-07-01-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="基本概念">基本概念</h3>
<h4 id="什么是pe文件">什么是PE文件</h4>
<ol type="1">
<li>PE文件的全程：Portable Executable，即可移植的可执行文件</li>
<li>常见的PE文件：EXE文件、DLL文件、OCX文件、SYS文件、COM文件</li>
<li>PE文件通常是指32位的，而64位的PE文件通常称为PE32+、PE+、PE64</li>
</ol>
<h4
id="文件偏移地址虚拟地址与相对虚拟地址">文件偏移地址、虚拟地址与相对虚拟地址</h4>
<ol type="1">
<li>文件偏移地址：PE文件存储在磁盘中时，某个数据的位置相对于文件头部的偏移量，通常将其称为文件偏移地址（File
Offset Address）或物理地址（RAW Offset）</li>
<li>虚拟地址：在Windows系统中，PE文件会被系统加载器映射到内存中，而每个PE文件都有其自己的独立的虚拟空间，这个虚拟空间的内存地址就被称为虚拟地址（Virtual
Address）</li>
<li>相对虚拟地址：当PE文件映射到内存之后，某个数据相对于文件载入点地址（即基地址，ImageBase）的偏移量，通常称其为相对虚拟地址（Relative
Virtual Address），虚拟地址与相对虚拟地址存在如下关系：虚拟地址(VA) =
基地址(ImageBase) + 相对虚拟地址(RVA)</li>
</ol>
<span id="more"></span>
<h4 id="pe结构图">PE结构图</h4>
<ol type="1">
<li><p>PE文件框架结构 <img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-PE框架结构.png" /></p></li>
<li><p>PE文件的详细结构 <img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-详细结构.PNG" /></p></li>
<li><p>PE文件磁盘结构与内存结构（对齐原因） <img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-PE内存映像.png" /></p></li>
</ol>
<h3 id="pe-headers解析">PE Headers解析</h3>
<p>首先需要明确的是，严格意义上的PE文件头是指<strong>IMAGE_NT_HEADERS</strong>，但为了方便解析，此处将</p>
<ul>
<li>IMAGE_DOS_HEADER（DOS头）</li>
<li>IMAGE_NT_HEADERS（NT头）</li>
<li>IMAGE_FILE_HEADER（映像文件头）</li>
<li>IMAGE_OPTIONAL_HEADER（可选映像头）</li>
<li>IMAGE_SECTION_HEADER（区块表）</li>
</ul>
<p>这五个部分都视作PE的头部部分一并进行解析</p>
<h4 id="image_dos_header">IMAGE_DOS_HEADER</h4>
<p>MS-DOS头部，大小为64字节，每个PE文件都是以一个DOS程序开始的，且DOS可以识别出一个文件是不是一个有效的执行体，若其首部的e_magic被置为0x5A4D（即ASCII的
"MZ"，该值对应于winnt.h文件中的一个宏定义，IMAGE_DOS_SIGNATURE），那么该文件就是一个DOS可执行文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      </span><br><span class="line">    WORD   e_magic;                     <span class="comment">// DOS可执行文件标记 &quot;MZ&quot;</span></span><br><span class="line">    WORD   e_cblp;                      </span><br><span class="line">    WORD   e_cp;                        </span><br><span class="line">    WORD   e_crlc;                      </span><br><span class="line">    WORD   e_cparhdr;                   </span><br><span class="line">    WORD   e_minalloc;                  </span><br><span class="line">    WORD   e_maxalloc;                  </span><br><span class="line">    WORD   e_ss;                        </span><br><span class="line">    WORD   e_sp;                        </span><br><span class="line">    WORD   e_csum;                      </span><br><span class="line">    WORD   e_ip;                        <span class="comment">// DOS代码入口IP</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// DOS代码入口CS</span></span><br><span class="line">    WORD   e_lfarlc;                    </span><br><span class="line">    WORD   e_ovno;                      </span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    </span><br><span class="line">    WORD   e_oemid;                     </span><br><span class="line">    WORD   e_oeminfo;                   </span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  </span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 偏移地址，指向IMAGE_NT_HEADERS，&quot;PE00&quot;(0x00004550)</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER</span><br></pre></td></tr></table></figure>
<p>其中比较重要的两个字段分别是e_magic与e_lfanew，前者的作用已经解释过，而e_lfanew是真正的PE文件头IMAGE_NT_HEADERS的相对偏移(lfanew
= long file address of new exe)</p>
<p>用十六进制编辑器打开exe文件可以发现，起始位置e_magic字段的值为"MZ"，而e_lfanew的值为"0x000000F0"，在相对文件起始位置0x000000F0的位置我们可以找到真正的PE文件头标记"PE00"</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-dos头.png" /></p>
<p>我们可以观察到在e_lfanew和真正的PE头之间还有一些数据，这部分数据被称为DOS
stub（即DOS块），DOS
stub实际上是一个有效的exe，在不支持PE文件格式的操作系统中，它将显示一个错误提示，即"This
program cannot be run in DOS mode"，DOS
stub的数据大多由编译器自动生成，可根据自己的需要修改其中的内容，我们将IMAGE_DOS_HEADER与DOS
stub合称为DOS文件头</p>
<h4 id="image_nt_headers">IMAGE_NT_HEADERS</h4>
<p>紧跟着DOS
stub的就是真正的PE文件头了，这部分也被称为NT映像头，在一个有效PE文件中，其Signature字段被置为0x00004550（即ASCII的"PE00"，该值对应于winnt.h文件中的一个宏定义，IMAGE_NT_SIGNATURE），而紧跟在Signature字段之后的就是IMAGE_FILE_HEADER映像文件头，在此之后紧跟的是IMAGE_OPTIONAL_HEADER可选映像头</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;                                  <span class="comment">// PE文件标识</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                     </span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;           </span><br><span class="line">&#125; IMAGE_NT_HEADERS32</span><br></pre></td></tr></table></figure>
<p>在十六进制编辑器中，NT影响头的结构如下图所示，首个字段即为"PE00"标记，紧跟其后红色框所示部分就是映像文件头，紧跟映像文件头之后的蓝色框所示的部分就是可选映像头</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-NT头.png" /></p>
<h4 id="image_file_header">IMAGE_FILE_HEADER</h4>
<p>映像文件头中包含PE文件的一些基本信息，大小为20字节，其中较为重要的两个字段为NumberOfSections字段与SizeOfOptionalHeader字段，前者指出了区块Section的数量（同时也指明了IMAGE_SECTION_HEADER区块表的数量，因为每一个区块表记录了对应区块的相关信息），后者指出了IMAGE_OPTIONAL_HEADER可选映像头的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;                          <span class="comment">// 运行平台</span></span><br><span class="line">    WORD    NumberOfSections;                 <span class="comment">// 区块数</span></span><br><span class="line">    DWORD   TimeDateStamp;                    <span class="comment">// 文件创建的日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;             <span class="comment">// 指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;                  <span class="comment">// 符号表中的符号的个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;             <span class="comment">// 可选映像头的大小</span></span><br><span class="line">    WORD    Characteristics;                  <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER</span><br></pre></td></tr></table></figure>
<p>这里对字段进行详细的解释：<br />
1.
Machine：可执行文件的目标CPU类型，因为不同平台上指令集不同，因此需要该字段标识运行的平台，如Inter
i386及其之后的处理器，该字段的值都为0x14C<br />
2. NumberOfSections：区块数<br />
3.
TimeDateStamp：文件创建的时间，将该值翻译为易读字符串需要使用_ctime函数<br />
4.
PointerToSymbolTable：COFF符号表的文件偏移位置（FOA），现较为少见<br />
5.
NumberOfSymbols：如果有文件符号表，其指出了文件符号表中符号的数目<br />
6.
SizeOfOptionalHeader：可选映像头的大小，其大小通常依赖于文件是32位还是64位的，若是32位文件，这个值默认为0x00E0，若是64位文件，这个值默认为0x00F0，这表示了选映像头大小的最小值，因此该值是可以修改的<br />
7.
Characteristics：文件属性，其结果为若干个有效值的和，有效值在winnt.h定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// 不存在重定位信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// 文件可执行 若为0，通常是链接时出问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// 行号信息被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// 符号信息被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Aggressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// 应用程序可以处理超过2GB的地址，因为大部分数据库服务器需要很大的内存，而NT仅提供2GB给应用程序，因此从NT SP3开始，可以通过设置此参数，使应用程序分配2 ~ 3GB区域的地址（此部分原本为系统内存区）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// 处理器的低位字节是相反的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 目标平台为32为机器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// .DBG文件的调试信息被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// 如果映像文件在可移动介质中，则先复制到交换文件中再运行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// 如果映像文件在网络中，则先复制到交换文件后再运行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// 系统文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// DLL文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// 文件只能运行在单处理上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// 处理器的高位字节是相反的</span></span></span><br></pre></td></tr></table></figure>
<h4 id="image_optional_header">IMAGE_OPTIONAL_HEADER</h4>
<p>虽然称为可选映像头，但该结构是必不可少的，其中定义了更多的数据，32位下最小大小为E0
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;                            <span class="comment">// 标志字</span></span><br><span class="line">    BYTE    MajorLinkerVersion;               <span class="comment">// 链接器主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;               <span class="comment">// 连接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;                       <span class="comment">// 所有含有代码的区块的大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData;            <span class="comment">// 所有初始化数据区块大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;          <span class="comment">// 所有未初始化数据区块大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;              <span class="comment">// 程序执行入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;                       <span class="comment">// 代码区块起始RVA</span></span><br><span class="line">    DWORD   BaseOfData;                       <span class="comment">// 数据区块起始RVA</span></span><br><span class="line">    DWORD   ImageBase;                        <span class="comment">// 程序默认载入基地址</span></span><br><span class="line">    DWORD   SectionAlignment;                 <span class="comment">// 内存中块的对齐值</span></span><br><span class="line">    DWORD   FileAlignment;                    <span class="comment">// 磁盘文件中块的对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;      <span class="comment">// 操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;      <span class="comment">// 操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;                <span class="comment">// 用户自定义主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;                <span class="comment">// 用户自定义次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;            <span class="comment">// 所需子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;            <span class="comment">// 所需子系统此版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;                <span class="comment">// 保留，通常设置为0</span></span><br><span class="line">    DWORD   SizeOfImage;                      <span class="comment">// 映像载入内存后的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;                    <span class="comment">// DOS头、PE文件头、区块表的总大小</span></span><br><span class="line">    DWORD   CheckSum;                         <span class="comment">// 映像校验和</span></span><br><span class="line">    WORD    Subsystem;                        <span class="comment">// 文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics;               <span class="comment">// 显示DLL特性的旗标</span></span><br><span class="line">    DWORD   SizeOfStackReserve;               <span class="comment">// 初始化时栈的大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;                <span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;                <span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;                 <span class="comment">// 初始化时实际保留的堆大小</span></span><br><span class="line">    DWORD   LoaderFlags;                      <span class="comment">// 调试相关，默认值为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;              <span class="comment">// 数据目录项的数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];       <span class="comment">// 数据目录表数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32</span><br></pre></td></tr></table></figure></p>
<p>这里对一些较为关键的字段进行详细的解释：<br />
1.
Magic：标志字，ROM映像为0x107，32位可执行映像为0x010B，64位可执行映像位0x020B<br />
2.
SizeOfCode：所有含有IMAGE_SCN_CNT_CODE属性的区块的总大小，必须是FileAlignment的整数倍，由编译器填写，通常情况下，大多数文件只有一个Code块，所以该字段与.text块的大小匹配<br />
3.
SizeOfUninitializedData：所有未初始化数据区块大小，装载程序需要在虚拟地址空间中位这些数据分配空间，这些块在磁盘文件中不占空间，在程序开始运行时没有指定值，未初始化数据通常在.bss块中<br />
4.
AddressOfEntryPoint：程序执行入口RVA。对于DLL，这个入口点在进程初始化和关闭时与线程创建和销毁时被调用，在大多数可执行文件中，这个地址不直接指向Main、WinMain或DllMain，而是指向运行时的库代码，并由它来调用上述函数<br />
5.
ImageBase：程序默认载入基地址，如果PE文件在这个地址载入，加载器将会跳过应用基址重定位的步骤<br />
6.
SectionAlignment：载入内存时，内存中块的对齐值，也就是说每个区块被载入的地址必定是本字段指定数值的整数倍，默认的对齐尺寸是目标CPU的页尺寸（通常是0x10000，也就是4KB）<br />
7.
FileAlignment：磁盘文件中块的对齐值，区块在磁盘文件中存储的首地址必定是本字段指定数值的整数倍，对于x86可执行文件，这个值常为0x200或0x1000，这是为了保证块总是从磁盘的扇区开始，该值必须是2的幂<br />
8.
SizeOfImage：映像载入内存后的总大小，即从ImageBase到最后一个块结束，且按照<strong>SectionAlignment</strong>对齐的大小<br />
9.
SizeOfHeaders：DOS头、PE文件头、区块表的总大小，按<strong>FileAlignment</strong>对齐<br />
10.
CheckSum：映像校验和，CheckSumMappedFile函数可以计算该值，通常情况下，普通的EXE文件该值为0，但内核模式的驱动程序和系统DLL必须有一个校验和<br />
11. NumberOfRvaAndSizes：数据目录项的数量，该值至今一直为16<br />
12.
DataDirectory[16]：数据目录数组，由数个相同的IMAGE_DATA_DIRECTORY结构组成，其具体的结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;         <span class="comment">// 数据块的RVA</span></span><br><span class="line">    DWORD   Size;                   <span class="comment">// 数据块的大小</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY</span><br></pre></td></tr></table></figure>
<p>数据目录表成员的结构如下所示</p>
<table>
<thead>
<tr>
<th style="text-align: center;">序号</th>
<th style="text-align: center;">表名</th>
<th style="text-align: center;">结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Export Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_EXPORT</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Import Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_IMPORT</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Resources Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">Exception Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">Security Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_SECURITY</td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">Base Relocation Table</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">Debug</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_DEBUG</td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td style="text-align: center;">Copyright</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_COPYRIGHT</td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;">Global Ptr</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
</tr>
<tr>
<td style="text-align: center;">9</td>
<td style="text-align: center;">Thread Local Storage (TLS)</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_TLS</td>
</tr>
<tr>
<td style="text-align: center;">10</td>
<td style="text-align: center;">Load Configuration</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
</tr>
<tr>
<td style="text-align: center;">11</td>
<td style="text-align: center;">Bound Import</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
</tr>
<tr>
<td style="text-align: center;">12</td>
<td style="text-align: center;">Import Address Table (IAT)</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_IAT</td>
</tr>
<tr>
<td style="text-align: center;">13</td>
<td style="text-align: center;">Delay Import</td>
<td style="text-align: center;">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
</tr>
<tr>
<td style="text-align: center;">14</td>
<td style="text-align: center;">COM Descriptor</td>
<td
style="text-align: center;">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
</tr>
<tr>
<td style="text-align: center;">15</td>
<td style="text-align: center;">保留，必须为0</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h4 id="image_section_header">IMAGE_SECTION_HEADER</h4>
<p>区块表中记录了区块的具体信息，每个区块表分别指向了不同的区块实体，紧跟在
IMAGE_OPTIONAL_HEADER 之后，每个区块表大小都是40字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];      <span class="comment">// 8字节大小的块名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;                                     <span class="comment">// 实际被使用的区块的大小，未对齐</span></span><br><span class="line">    DWORD   VirtualAddress;                     <span class="comment">// 该块装载到内存中的RVA</span></span><br><span class="line">    DWORD   SizeOfRawData;                      <span class="comment">// 在磁盘中区块的大小，已对齐</span></span><br><span class="line">    DWORD   PointerToRawData;                   <span class="comment">// 该块在磁盘中的偏移FOA</span></span><br><span class="line">    DWORD   PointerToRelocations;               <span class="comment">// 在EXE中无意义，在OBJ文件中表示本块重定位信息表的偏移</span></span><br><span class="line">    DWORD   PointerToLinenumbers;               <span class="comment">// 调试信息，行号表在文件中的偏移</span></span><br><span class="line">    WORD    NumberOfRelocations;                <span class="comment">// 在EXE中无意义，在OBJ文件中表示本块在重定位表中重定位数量</span></span><br><span class="line">    WORD    NumberOfLinenumbers;                <span class="comment">// 该块在行号表中的行号数量</span></span><br><span class="line">    DWORD   Characteristics;                    <span class="comment">// 块属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER</span><br></pre></td></tr></table></figure>
<p>块属性中的一些重要字段值如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="comment">// 包含代码，通常与0x10000000一起设置</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="comment">// 包含已初始化数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="comment">// 包含未初始化数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE            0x02000000  <span class="comment">// 该块可被丢弃，因为它一旦被载入，进程就不再需要它了，常见的可丢弃块是.reloc（重定位块）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_SHARED                 0x10000000  <span class="comment">// 该块为共享块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="comment">// 该块可执行，通常当0x00000020标志被设置时，该标志也被设置</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="comment">// 该块可读，可执行文件中总是设置该标志</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="comment">// 该块可写，若PE文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行</span></span></span><br></pre></td></tr></table></figure>
<p>在十六进制编辑器中的区块表信息如下图所示，可以观察到该exe文件包含4个区块表，其中四个区块的信息名称分别为</p>
<ul>
<li>.text</li>
<li>.rdata</li>
<li>.data</li>
<li>.rsrc</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-05-区块表.png" /></p>
<h3 id="区块解析">区块解析</h3>
<p>首先需要注意的是，区块名称只是为了方便辨识，但对于操作系统来说是无关紧要的，如当寻找输出表、输入表信息时，不应该默认到.text和.rdata区块中寻找，而是要严格依据数据目录数组DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]中的信息进行查找，常见区块如下</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">.text</td>
<td
style="text-align: center;">默认的代码区块，其中的内容全是指令代码</td>
</tr>
<tr>
<td style="text-align: center;">.data</td>
<td
style="text-align: center;">默认的读、写区块，<strong>全局变量、静态变量</strong>通常放在此处</td>
</tr>
<tr>
<td style="text-align: center;">.rdata</td>
<td
style="text-align: center;">默认的只读数据区块，程序较少用到该块中的数据，但至少有两种情况会用到，一是在Microsoft链接器产生的exe文件中，用于存放调试目录；二是用于存放说明字符串，如果程序的DEF文件中指定了DESCRIPTION，字符串就会在出现在该块中</td>
</tr>
<tr>
<td style="text-align: center;">.idata</td>
<td
style="text-align: center;">输入表，包含其他外来DLL的函数及数据信息，通常将其合并到其他区块中，如.rdata</td>
</tr>
<tr>
<td style="text-align: center;">.edata</td>
<td
style="text-align: center;">输出表，当创建一个输出API或数据的可执行文件时（如DLL），链接器会创建一个.exp文件，.exp文件将会包含一个.edata区块，并加入到最后的可执行文件中，通常将.edata合并到其他块中，如.text区块中</td>
</tr>
<tr>
<td style="text-align: center;">.rsrc</td>
<td
style="text-align: center;">资源，包含模块的全部资源，例如图标、菜单、位图等，该区块是只读的，无论如何都不应该命名为为.rsrc以外的名字，也不能被合并到其他区块中</td>
</tr>
<tr>
<td style="text-align: center;">.reloc</td>
<td
style="text-align: center;">可执行文件的基址重定位，通常只是DLL需要，而exe不需要，通常在Release模式下，链接器不会给exe文件加上基址重定位</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>逆向之植物大战僵尸（二）</title>
    <url>/2023/02/24/2023-02-24-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>回顾一下<a
href="https://colaxianyu.github.io/2022/02/21/2022-2-21-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%B8%80%EF%BC%89">上一章</a>实现无限阳光的方法，我们首先猜想有一个变量存储了当前阳光的值，即在内存中有一块空间存储了阳光的值，只需要找到该空间，再将期望的阳光数写入该空间即可实现无限阳光的功能，通过CE多次搜索阳光，我们最终通过基址
+ 2次间址的形式定位到了阳光的具体地址</p>
<h3 id="取消植物放置cd">取消植物放置CD</h3>
<h4 id="思路">思路</h4>
<p>现在我们实现取消植物放置CD的功能，可以猜想有一个变量存放了某个植物的放置CD，而另一个变量存放了CD计时器，然后通过一个函数判断，当<strong>CD计时器从0开始增长到大于等于CD时</strong>或<strong>CD计时器从CD值开始减少到0时</strong>，可以再次放置植物，即</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> plantCD = xxx</span><br><span class="line"><span class="keyword">int</span> CDTimers = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CDTimers增加</span></span><br><span class="line"><span class="keyword">if</span>(CDTimers &gt;= plantCD)&#123;     </span><br><span class="line">     可以放置植物;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CDTimers减少</span></span><br><span class="line">CDTimers = plantCD</span><br><span class="line"><span class="keyword">if</span>(CDtimer &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    可以放置植物;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此猜想上我们不难发现两种实现思路：<br />
1. 方法一是置植物CD为0<br />
2. 方法二是让if判断能一直成立</p>
<p>对于方法一，因为每个植物都有其独立的CD，要搜索每一个植物的CD值工作量相对较大，且我们并不知道植物CD的具体数值，在搜索中也较为困难，且在搜索到植物CD后还需要再定位其静态基址</p>
<p>对于方法二，无论植物CD是多少，能否放置植物都依赖于函数的判断，如果我们能定位到该if判断的位置，那么我们就能通过修改程序执行的流程，使其无条件的执行可以放置植物的代码</p>
<p>因此我们的思路就是：
首先找到CDTimers，然后定位if判断的位置，修改程序执行的流程</p>
<h4 id="寻找cdtimers">寻找CDTimers</h4>
<ol type="1">
<li>因为我们无法确定CDTimers的初始值，所以在CE的搜索方式中我们选择未知初始值，并点击First
Scan</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-搜索.png" /></p>
<ol start="2" type="1">
<li>我们以向日葵作为对象，此时放置向日葵，并选择changed
value，然后再次搜索</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-再次搜索.png" /></p>
<ol start="3" type="1">
<li>我们发现CE得到了非常多的搜索结果，此时游戏处于暂停阶段，CDTimers并未改变，所以我们可以在CE中选择unchanged
value，并多次搜索过滤大量无关数据</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-多次搜索过滤.png" /></p>
<ol start="4" type="1">
<li>此时搜索结果减少的量已经很少了，此时我们让游戏继续一段时间，此时CDTimers的值改变，因此再CE中再次选择changed
value并搜索</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-再次精准搜索.png" /></p>
<ol start="5" type="1">
<li>我们重复步骤3和4，直至搜索到少量结果（向日葵CD结束可再放置一次重复搜索）</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-最终结果.png" /></p>
<ol start="6" type="1">
<li>我们发现最后一个结果的值172比较符合我们的猜想，并发现在游戏进行时，该值不断增大，此时向日葵处于不可放置的状态，那么该值是否会增大到某一个界限后导致向日葵可以重新安放呢，为印证猜想，我们在此处将该值改为1000</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-修改可疑值.png" /></p>
<p>我们发现此时向日葵恢复了可放置的状态，猜想正确，该值就是CDTimers</p>
<h4 id="定位if判断的位置">定位If判断的位置</h4>
<ol type="1">
<li>我们知道当植物处于不可放置状态时，CDTimers的值会不断增加，因此我们可以得知必定有一条指令像该内存写入了数据，因此我们可以对CDTimer下一个内存写入断点</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-内存写入断点.png" /></p>
<ol start="2" type="1">
<li>此时我们选择show
disassembler可以看到如下内容，我们发现该值增加后存入了eax寄存器，而之后eax与内存中[edi+0x24]处的值进行了对比，我们猜测该CMP指令就是我们要找的if判断指令，我们记下该CMP指令的地址</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-反汇编.png" /></p>
<ol start="3" type="1">
<li>用x64Dbg附加植物大战僵尸进程（若附加失败可关闭CE后再尝试附加），之后我们在x64Dbg中通过地址找到CMP指令，并在该处下断点，是程序运行到CMP指令处</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-调试器.png" /></p>
<ol start="4" type="1">
<li>此时我们单步执行一次，发现跳转指令jle执行，而此时向日葵是处于无法安置状态的，如果该CMP就是我们需要的if判断，那么可以推测出，若跳转执行，则植物仍在CD，不可放置；若跳转不执行，则植物没有CD，可以放置</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-jle指令.png" /></p>
<ol start="5" type="1">
<li>为验证猜想，我们可以改变程序的执行流程，即让jle指令不跳转，因为jle跳转与否是由标志寄存器（ZF
== 1 || SF != OF）决定，此时SF !=
OF，跳转执行，因此我们将SF的值该为0，此时跳转就不会执行，之后我们运行程序，可以观察到植物的CD取消</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-改执行流程.png" /></p>
<ol start="6" type="1">
<li>此时我们可以确定该CMP就是我们需要的if判断，而其结果决定了jle指令是否跳转，若我们让jle指令永不跳转，那就实现了植物放置无CD的功能，因此我们在x64Dbg中将jle指令用nop填充并取消断点，回到游戏中，我们发现放置植物之后将不会有CD，功能实现成功</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-02-26-nop.png" /></p>
<h4 id="实现取消cd功能">实现取消CD功能</h4>
<p>其过程就是用代码的形式将jle指令用nop填充 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nop指令的机器码，保证与原jle指令长度相同</span></span><br><span class="line">buffer[<span class="number">0</span>] = <span class="number">0x90</span>;</span><br><span class="line">buffer[<span class="number">1</span>] = <span class="number">0x90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在jle指令地址处，用nop填充</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess_, (LPVOID)<span class="number">0x00487296</span>, (LPCVOID)buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), &amp;pid_)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>PE文件解析（四）</title>
    <url>/2024/07/21/2024-07-21-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="资源表">资源表</h3>
<p>资源表的结构相对复杂，采用了类似磁盘目录结构的方式保存，通常目录有3层，第1层目录类似于一个文件系统的根目录，指出了整个资源表中有多少种不同的类型（如光标、菜单、快捷键等）；第2层目录指明了当前类型的资源中，有多少个资源；而第3层目录被称为资源代码页</p>
<p>为了便于理解，先给出一张资源表的树形结构图</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-资源表树形.png" /></p>
<span id="more"></span>
<h4 id="资源目录结构">资源目录结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;        <span class="comment">//资源属性，但通常为0</span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 资源建立时间</span></span><br><span class="line">    WORD    MajorVersion;           <span class="comment">// 资源的版本，但通常为0</span></span><br><span class="line">    WORD    MinorVersion;           </span><br><span class="line">    WORD    NumberOfNamedEntries;   <span class="comment">// 使用名字的资源条目的个数</span></span><br><span class="line">    WORD    NumberOfIdEntries;      <span class="comment">// 使用ID的资源条目个数</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY</span><br></pre></td></tr></table></figure>
<p>其中最关键的属性是NumberOfNamedEntries和NumberOfIdEntries，他们指出了本目录种目录项的总和（即资源类型的总个数）</p>
<h4 id="资源目录入口结构">资源目录入口结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;</span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name;</span><br><span class="line">        WORD    Id;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;</span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY</span><br></pre></td></tr></table></figure>
<p>可以看到其中有两个union结构，我们可以简单的理解为，资源目录入口结构包含两个属性Name（ID）、OffsetToData，根据情况的不同，他们有不同的含义</p>
<ul>
<li>Name（ID）属性：定义了目录项的名称或ID，当最高位（NameIsString）为0时，表示该属性通过ID使用；为1时，表示该属性通过Name使用，且资源名称使用Unicode编码，低31位为Name的Offset，但NameOffset并不直接指向字符串，而是指向一个IMAGE_RESOURCE_DIR_STRING_U结构，该结构如下所示
<ul>
<li>当用于第一层目录时，定义的是资源的类型</li>
<li>当用于第二层目录时，定义的是资源的名称</li>
<li>当用于第三层目录时，定义的时代码页的编号</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span></span><br><span class="line">    WORD    Length;             <span class="comment">// 字符串的长度（不一定以0结尾，所以该属性很重要）</span></span><br><span class="line">    WCHAR   NameString[ <span class="number">1</span> ];    <span class="comment">// 具体的Unicode字符串</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIR_STRING_U</span><br></pre></td></tr></table></figure>
<ul>
<li>OffsetToData属性：一个指针，当最高位为1时，低31位指向下一层IMAGE_RESOURCE_DIRECTORY的起始地址；当最高位为0时，指向IMAGE_RESOURCE_DATA_ENTRY结构</li>
</ul>
<p><strong>当NameOffset和OffsetToData作为Offset使用时，该指针从资源区块的开始处计算偏移，即它们并不是RVA</strong></p>
<p><strong>当IMAGE_RESOURCE_DIRECTORY_ENTRY用在第一层的目录时，其Name（ID）属性用于标记资源类型，而Windows有14种预定义的类型，且用ID标识，ID的数值在1到16之间</strong></p>
<table>
<thead>
<tr>
<th style="text-align: center;">ID值</th>
<th style="text-align: center;">资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">01h</td>
<td style="text-align: center;">光标（Cursor）</td>
</tr>
<tr>
<td style="text-align: center;">02h</td>
<td style="text-align: center;">位图（Bitmap）</td>
</tr>
<tr>
<td style="text-align: center;">03h</td>
<td style="text-align: center;">图标（Icon）</td>
</tr>
<tr>
<td style="text-align: center;">04h</td>
<td style="text-align: center;">菜单（Menu）</td>
</tr>
<tr>
<td style="text-align: center;">05h</td>
<td style="text-align: center;">对话框（Dialog）</td>
</tr>
<tr>
<td style="text-align: center;">06h</td>
<td style="text-align: center;">字符串（String）</td>
</tr>
<tr>
<td style="text-align: center;">07h</td>
<td style="text-align: center;">字体目录（Front Directory）</td>
</tr>
<tr>
<td style="text-align: center;">08h</td>
<td style="text-align: center;">字体（Front）</td>
</tr>
<tr>
<td style="text-align: center;">09h</td>
<td style="text-align: center;">快捷键（Accelerators）</td>
</tr>
<tr>
<td style="text-align: center;">0Ah</td>
<td style="text-align: center;">未格式化资源（Unformatted）</td>
</tr>
<tr>
<td style="text-align: center;">0Bh</td>
<td style="text-align: center;">消息表（Message Table）</td>
</tr>
<tr>
<td style="text-align: center;">0Ch</td>
<td style="text-align: center;">光标组（Group Cursor）</td>
</tr>
<tr>
<td style="text-align: center;">0Eh</td>
<td style="text-align: center;">图标组（Group Icon）</td>
</tr>
<tr>
<td style="text-align: center;">10h</td>
<td style="text-align: center;">版本信息（Version Information）</td>
</tr>
</tbody>
</table>
<h4 id="资源数据入口结构">资源数据入口结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD   OffsetToData;       <span class="comment">// 资源数据的RVA</span></span><br><span class="line">    DWORD   Size;               <span class="comment">// 资源数据的长度</span></span><br><span class="line">    DWORD   CodePage;           <span class="comment">// 代码页，一般为0</span></span><br><span class="line">    DWORD   Reserved;           <span class="comment">// 保留字段</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY</span><br></pre></td></tr></table></figure>
<p>该结构就是真正的资源数据的结构了，其中OffsetToData是RVA，而不是相对于资源块起始位置的Offset</p>
<h3 id="实例">实例</h3>
<p>我这里用一个Win32程序为实例，先用PE Tools查看其资源表内容</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-示例资源表.png" /></p>
<h4 id="根目录">根目录</h4>
<p>可以看到其中共有7种不同的资源类（24好像是清单类型，暂时每找到相关文档信息），首先在16进制编辑器中观察其根目录</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-根目录.png" /></p>
<ul>
<li>4字节Characteristics，此时为0</li>
<li>4字节TimeDateStamp，为0</li>
<li>2字节MajorVersion，为0</li>
<li>2字节MinorVersion，为0</li>
<li>2字节NumberOfNamedEntries，为0</li>
<li>2字节NumberOfIdEntries，为7</li>
</ul>
<h4
id="根目录下的image_resource_directory_entry">根目录下的IMAGE_RESOURCE_DIRECTORY_ENTRY</h4>
<p>我们以Menu作为分析对象，它是第二个IMAGE_RESOURCE_DIRECTORY_ENTRY结构，因为该结构大小位8字节，所以它的位置应该是2400h
+ 8 = 2408h，我们在16进制编辑器中可以看到如下内容</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-第一层Entry.png" /></p>
<p>可以看到其Name（ID）属性值为：0x00000004，其OffsetToData属性值为0x800000E8，我们进一步解析</p>
<ul>
<li>Name（ID）属性的最高位为0，表示它通过ID标识，由于是第一层目录中，它代表一个预定义的资源，查表我们发现04h是Menu</li>
<li>OffsetToData属性的最高位为1，表示它指向下一层目录，其Offset是E8h，那么下一层目录的地址为2400h
+ E8h = 24E8h</li>
</ul>
<h4
id="第二层目录的image_resource_directory">第二层目录的IMAGE_RESOURCE_DIRECTORY</h4>
<p>第二层目录如下所示</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-第二层目录.png" /></p>
<p>可以知道其NumberOfIdEntries为1，表示Menu资源下只有一个该类资源</p>
<p>紧跟其后的8字节就是IMAGE_RESOURCE_DIRECTORY_ENTRY结构，可以看到其Name（ID）属性值为：0x0000006D，其OffsetToData属性值为0x80003030</p>
<ul>
<li>Name（ID）属性的最高位为0，表示它通过ID标识，ID为6Dh，即十进制的109</li>
<li>OffsetToData属性的最高位为1，表示它指向下一层目录，其Offset是330h，那么下一层目录的地址为2400h
+ 330h = 2730h</li>
</ul>
<h4
id="第三层目录的image_resource_directory">第三层目录的IMAGE_RESOURCE_DIRECTORY</h4>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-第三层目录.png" /></p>
<p>可以知道其NumberOfIdEntries为1，表示该资源代码页只有一项</p>
<p>紧跟其后就是IMAGE_RESOURCE_DIRECTORY_ENTRY结构</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-第三层Entry.png" /></p>
<p>可以看到其Name（ID）属性值为：0x00000804，其OffsetToData属性值为0x000004F8</p>
<ul>
<li>Name（ID）属性的最高位为0，表示它通过ID标识，ID为804h</li>
<li>OffsetToData属性的最高位为0，表示它指向IMAGE_RESOURCE_DATA_ENTRY结构，其Offset是4F8h，那么该结构的地址为2400h
+ 4F8h = 28F8h</li>
</ul>
<h4 id="image_resource_data_entry">IMAGE_RESOURCE_DATA_ENTRY</h4>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-资源data.png" /></p>
<ul>
<li>OffsetToData为01AE90h</li>
<li>Size为50h</li>
<li>CodePage为0<br />
</li>
<li>Reserved为0</li>
</ul>
<h4 id="image_resource_dir_string_u">IMAGE_RESOURCE_DIR_STRING_U</h4>
<p>因为示例程序比较简单，没有用到这个结构，所以这里单独找一个比较复杂的程序用来展示</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-复杂程序.png" /></p>
<p>可以看到根目录下第一类资源是用Name标识的，其名字为"AFX_DIALOG_LAYOUT"，我们在16进制中观察其IMAGE_RESOURCE_DIRECTORY_ENTRY</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-复杂entry.png" /></p>
<p>可以看到其Name（ID）属性值为：0x8000CB2E，其OffsetToData属性值为0x800000B0</p>
<ul>
<li>Name（ID）属性的最高位为1，表示它通过Name标识，且Name的Offset为CB2Eh，那么IMAGE_RESOURCE_DIR_STRING_U结构的地址为630000h
+ CB2Eh = 63CB2Eh</li>
<li>OffsetToData属性的最高位为1，表示它指向下一层目录</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-21-名字结构.png" /></p>
<p>可以看到IMAGE_RESOURCE_DIR_STRING_U结构中Length为11h，而NameString为Unicode表示的"AFX_DIALOG_LAYOUT"（可以注意到字符串并没有以0结尾，所以Length属性很重要）</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>PE文件解析（三）</title>
    <url>/2024/07/15/2024-07-15-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>之前讲解了输入表与输入地址表以及他们的工作原理，现在我们开始分析输出表与重定位表</p>
<h3 id="输出表">输出表</h3>
<p>创建一个DLL时，实际上创建了一组能让exe或其他DLL调用的函数，而PE装载器将根据DLL文件中的输出信息修正正被执行文件中的IAT。通常exe文件中不存在输出表（并不绝对），而大部分DLL文件中则存在输出表</p>
<h4 id="输出表的结构">输出表的结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;            <span class="comment">// 旗标，未使用，总是为0</span></span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;               <span class="comment">// 主版本号，一般为0</span></span><br><span class="line">    WORD    MinorVersion;               <span class="comment">// 次版本号，一般为0</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     </span><br><span class="line">    DWORD   AddressOfNames;         </span><br><span class="line">    DWORD   AddressOfNameOrdinals;  </span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>现在对一些重要属性做出解释</p>
<ul>
<li>TimeDateStamp：输出表的创建时间（GMT时间）</li>
<li>Name：指向一个ASCII字符串的RVA，即DLL的名字</li>
<li>Base：一个初始序号值，当通过序号查询输出的函数时，实际数值 =
查询数值 - Base，实际数值即为输出函数地址表（EAT）的索引</li>
<li>NumberOfFunctions：输出函数地址表中条目的数量</li>
<li>NumberOfNames：输出函数名称表（ENT）和输出函数序号表中条目的数量</li>
<li>AddressOfFunctions：输出函数地址表的RVA，是一个RVA数组</li>
<li>AddressOfNames：输出函数名称表的RVA，也是一个RVA数组，<strong>该表会排序</strong></li>
<li>AddressOfNameOrdinals：输出序号表的RVA，指向输出序号的数组，即一个WORD大小的数组</li>
</ul>
<p>我们看到结构中提到了3张表，分别是输出函数地址表EAT、输出函数名称表ENT、输出函数序号表，那么他们之间有什么联系呢？且DLL中的函数既可以通过名称导出，也可以通过序号导出，那么两种不同的导出方式，又要如何定位函数的地址呢？</p>
<ul>
<li>函数通过名称导出时，如何建立名称到地址的映射关系就成了关键，而输出函数序号表就是承担中转工作的，我们之前提到这三张表都是数组，假设我们有一个名称A的函数，通过查询ENT表得到其索引为3，那么函数A的序号在函数序号表的索引也是3，我们从序号表中取出该函数的序号，这个序号就是函数A在EAT表中的索引</li>
<li>函数通过序号导出时，导出序号 - base = EAT表索引</li>
</ul>
<h4 id="实例">实例</h4>
<p>为了便于理解，假设我们有DLLTest.dll文件，其中定义了4个函数Plus、Sub、Mul和Div，其中Plus、Sub、和Div以函数名导出，并将其导出序号分别设置为1、5、9，而Mul以序号导出，其序号为为7，具体如下</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-def.png" /></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-Petools.png" /></p>
<p>此时我们画一张导出表的示意图来进行细致的解释</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-图解.png" /></p>
<ul>
<li>对于名称导出方式，以Sub函数为例，我们可以看到它在ENT表中的索引为2，那么我们到序号表中查询索引为2的序号值，其结果为4，这意味着Sub函数的RVA地址存放在EAT表中的索引为4的地方，此时我们再查看EAT表就可以得到Sub函数的RVA为0x1060</li>
<li>对于序号导出方式，我们将Mul以序号7将其导出，此时Base =
1，那么Mul的RVA地址在EAT表中的索引就是7 - 1 =
6，通过查EAT表我们得到了Mul的RVA为0x1070</li>
</ul>
<h3 id="重定位表">重定位表</h3>
<p>首先，为什么会有重定位表，我们都知道在可选映像头中有一个ImageBase属性，这个属性标识了PE文件默认的载入基地址，但是一个exe文件可能同时包含了多个DLL，而这些DLL的ImageBase又都是0x10000000，为了避免冲突现象，我们只能将没抢占到0x10000000这个位置的DLL放入内存中的其他位置，此时就产生了一个问题，DLL中某些数据的地址写的是直接地址（ImageBase
+
RVA），此时换了一个新的基地址，我们要如何取到正确的取得这些数据呢，这就是重定位表的作用，标识出那些需要修正的位置</p>
<h4 id="重定位表的结构">重定位表的结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>
<ul>
<li>VirtualAddress：重定位数据开始的RVA地址</li>
<li>SizeOfBlock：重定位块的大小</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-重定位表图.png" /></p>
<ul>
<li>首先需要注意的是IMAGE_BASE_RELOCATION并不是孤立的一张表，在结构体后紧跟是一个WORD类型（2字节）的数组，数组长度为（SizeOfBlock
- 8）/ 2</li>
<li>其次，这些数据是高4位+低12位的结构，其中高4位为修改标记，若其为0011（即十进制的3），则表示该数据需要修改，低12位是一个Offset，需要用重定位表中的VirtualAddress
+
Offset才是需要修改的数据的RVA；若高4位为0，则不需要修改，作为对齐用</li>
<li>每一张重定位表，都会记录一个4KB大小的数据块中需要修改的数据</li>
<li>最后，重定位表最终以一个8字节大小的全0结构作为结束的标志</li>
</ul>
<p>最后，可能有人会有疑问，对于一个寻址能力为32位的操作系统，为什么Offset是一个2个字节大小的结构，内存地址不是需要4字节才能完整表示吗？</p>
<p>这是因为重定位表采用VirtualAddress +
Offset表示RVA造成的，我们先来看看这么做的好处，假设我们有一个16KB大小的数据块，其中有1000个需要重定位的数据</p>
<ul>
<li>如果我们采用直接记录RVA的方式，那么只需要一张重定位表，其大小为1000
* 4 = 4000字节（如果需要SizeOfBlock记录大小，则至少为4004字节）</li>
<li>如果我们采用VirtualAddress +
Offset的方式，那么按实际的重定位表结构，我们将会有4张重定位表（每个重定位表只记录4KB大小的数据块），假设这1000个数据均匀分布在这4张表中，那么每张重定位表的大小为
8 + 250 * 2 =
508字节，那么4张重定位表总共2032字节，我们可以发现这样的设计大大缩小了重定位表的大小</li>
</ul>
<p>在理解了这样设计的好处之后，现在我们来回答，为什么Offset只需要两字节</p>
<p>从原理的角度：一张重定位表记录一个4BK大小的数据块（即0x0000 ~
0x0FFF），也就是说，我们的Offset只要能表示这个范围内的地址即可，因此Offset只需要12位即可表示（即重定位表中数据的低12位），处于对齐和功能性，我们将其设计为16位，即2字节，那么高4位就用来记录是否需要修改这一信息，所以VirtualAddress大小为4字节，可以记录任意数据块的在内存中的起始地址RVA，而Offset只需要2字节就可表示块内的任意Offset</p>
<h4 id="实例-1">实例</h4>
<p>还是以之前DLLTest.dll为例，我们在PE
Tools中可以看到，该文件共有两张重定位表，标识了不同区块中需要修正的数据，其中.text中共有140个可能需要重定位的数据，而.data中有16个</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-重定位表.png" /></p>
<p>我们以.text中的第一个、第三个需要修改的数据为例，首先分析下他们的RVA
0x1012和0x101E是怎么得到的，我们在16进制编辑器中找到重定位表，红框圈中的即为第一项数据0x3012和第三项数据0x301E，我们将其转换为二进制分别为0011
0000 0001 0010和0011 0000 0001
1110，可以发现他们的高4位都为0011，即需要修改，那么他们的低12位为Offset，分别是0x12和0x1E，那么需要修改的数据的RVA分别为VirtualAddress
+ Offset，即0x1012和0x101E</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-16进制重定位.png" /></p>
<p>此时DLLTest.dll的ImageBase为0x10000000，我们用另一个程序调用DLLTest.dll，并用x64Dbg打开该程序，找到0x10001012处，可以发现其中一个是Push指令，而另一个是call指令（因为Push指令的操作码为0x68，需要占用一个字节，所以指令开始的地址是0x0x10001011，而0x10001012才是实际需要修改的数据的起始地址，call指令同理），那么当DLLTest.dll发生重定位时，这两个部分的数据就需要修改，此时记下他们：①0x100020A4；②0x10002030</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-重定位汇编.png" /></p>
<p>现在我们让DLL不从ImageBase载入，但不修改ImageBase中的值，我们在VS中将随机基址的打开，然后重新编译我们的DLL和调用该DLL的程序，现在虽然DLL的ImageBase还是0x10000000，但实际载入内存时DLL并不会从ImageBase载入
<img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-修改基址.png" /></p>
<p>我们在x64Dbg中重新定位，可以发现此时我们的DLL已经被放到了内存中的其他位置，且载入的基地址为0x78590000，此时我们看到RVA为0x1012处的数据被改成了0x785920A4，而RVA为0x101E处的数据被改为了0x78592030</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/colaxianyu/imgbed/img/2022-03-15-新地址.png" /></p>
<p>我们不难看出这两个值是如何计算得到的</p>
<ul>
<li>0x785920A4 = 0x100020A4 - 默认基地址0x10000000 +
新基地址0x78590000</li>
<li>0x78592030 = 0x10002030 - 默认基地址0x10000000 +
新基地址0x78590000</li>
</ul>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
</search>
