[{"title":"逆向之植物大战僵尸（二）","url":"/2023/02/24/2023-02-24-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"回顾一下上一章实现无限阳光的方法，我们首先猜想有一个变量存储了当前阳光的值，即在内存中有一块空间存储了阳光的值，只需要找到该空间，再将期望的阳光数写入该空间即可实现无限阳光的功能，通过CE多次搜索阳光，我们最终通过基址\r\n+ 2次间址的形式定位到了阳光的具体地址\r\n取消植物放置CD\r\n思路\r\n现在我们实现取消植物放置CD的功能，可以猜想有一个变量存放了某个植物的放置CD，而另一个变量存放了CD计时器，然后通过一个函数判断，当CD计时器从0开始增长到大于等于CD时或CD计时器从CD值开始减少到0时，可以再次放置植物，即\r\n\r\nint plantCD = xxxint CDTimers = 0// CDTimers增加if(CDTimers &gt;= plantCD)&#123;          可以放置植物;&#125;//  or// CDTimers减少CDTimers = plantCDif(CDtimer &lt;= 0)&#123;    可以放置植物;&#125;\r\n在此猜想上我们不难发现两种实现思路：\r\n1. 方法一是置植物CD为0\r\n2. 方法二是让if判断能一直成立\r\n对于方法一，因为每个植物都有其独立的CD，要搜索每一个植物的CD值工作量相对较大，且我们并不知道植物CD的具体数值，在搜索中也较为困难，且在搜索到植物CD后还需要再定位其静态基址\r\n对于方法二，无论植物CD是多少，能否放置植物都依赖于函数的判断，如果我们能定位到该if判断的位置，那么我们就能通过修改程序执行的流程，使其无条件的执行可以放置植物的代码\r\n因此我们的思路就是：\r\n首先找到CDTimers，然后定位if判断的位置，修改程序执行的流程\r\n寻找CDTimers\r\n\r\n因为我们无法确定CDTimers的初始值，所以在CE的搜索方式中我们选择未知初始值，并点击First\r\nScan\r\n\r\n\r\n\r\n我们以向日葵作为对象，此时放置向日葵，并选择changed\r\nvalue，然后再次搜索\r\n\r\n\r\n\r\n我们发现CE得到了非常多的搜索结果，此时游戏处于暂停阶段，CDTimers并未改变，所以我们可以在CE中选择unchanged\r\nvalue，并多次搜索过滤大量无关数据\r\n\r\n\r\n\r\n此时搜索结果减少的量已经很少了，此时我们让游戏继续一段时间，此时CDTimers的值改变，因此再CE中再次选择changed\r\nvalue并搜索\r\n\r\n\r\n\r\n我们重复步骤3和4，直至搜索到少量结果（向日葵CD结束可再放置一次重复搜索）\r\n\r\n\r\n\r\n我们发现最后一个结果的值172比较符合我们的猜想，并发现在游戏进行时，该值不断增大，此时向日葵处于不可放置的状态，那么该值是否会增大到某一个界限后导致向日葵可以重新安放呢，为印证猜想，我们在此处将该值改为1000\r\n\r\n\r\n我们发现此时向日葵恢复了可放置的状态，猜想正确，该值就是CDTimers\r\n定位If判断的位置\r\n\r\n我们知道当植物处于不可放置状态时，CDTimers的值会不断增加，因此我们可以得知必定有一条指令像该内存写入了数据，因此我们可以对CDTimer下一个内存写入断点\r\n\r\n\r\n\r\n此时我们选择show\r\ndisassembler可以看到如下内容，我们发现该值增加后存入了eax寄存器，而之后eax与内存中[edi+0x24]处的值进行了对比，我们猜测该CMP指令就是我们要找的if判断指令，我们记下该CMP指令的地址\r\n\r\n\r\n\r\n用x64Dbg附加植物大战僵尸进程（若附加失败可关闭CE后再尝试附加），之后我们在x64Dbg中通过地址找到CMP指令，并在该处下断点，是程序运行到CMP指令处\r\n\r\n\r\n\r\n此时我们单步执行一次，发现跳转指令jle执行，而此时向日葵是处于无法安置状态的，如果该CMP就是我们需要的if判断，那么可以推测出，若跳转执行，则植物仍在CD，不可放置；若跳转不执行，则植物没有CD，可以放置\r\n\r\n\r\n\r\n为验证猜想，我们可以改变程序的执行流程，即让jle指令不跳转，因为jle跳转与否是由标志寄存器（ZF\r\n== 1 || SF != OF）决定，此时SF !=\r\nOF，跳转执行，因此我们将SF的值该为0，此时跳转就不会执行，之后我们运行程序，可以观察到植物的CD取消\r\n\r\n\r\n\r\n此时我们可以确定该CMP就是我们需要的if判断，而其结果决定了jle指令是否跳转，若我们让jle指令永不跳转，那就实现了植物放置无CD的功能，因此我们在x64Dbg中将jle指令用nop填充并取消断点，回到游戏中，我们发现放置植物之后将不会有CD，功能实现成功\r\n\r\n\r\n实现取消CD功能\r\n其过程就是用代码的形式将jle指令用nop填充 // nop指令的机器码，保证与原jle指令长度相同buffer[0] = 0x90;buffer[1] = 0x90;// 在jle指令地址处，用nop填充WriteProcessMemory(hProcess_, (LPVOID)0x00487296, (LPCVOID)buffer, sizeof(buffer), &amp;pid_)\r\n","categories":["逆向"]},{"title":"逆向之植物大战僵尸（一）","url":"/2023/02/21/2023-02-21-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%B8%80%EF%BC%89/","content":"植物大战僵尸是一款很适合逆向入门的游戏，而设计的辅助主要实现了下面几个功能：\r\n1. 无限阳光和无限金币\r\n2. 取消植物放置的CD\r\n3. 同一个位置可以重复放置植物\r\n无限阳光\r\n静态基址与动态地址\r\n\r\n静态基址：是指静态基址中的内容，不会因程序的重新启动而改变，只有在程序重新编译后才会变动\r\n动态地址：是指地址中的内容，会因程序的重新启动而变动的地址，也就是说，当前状态下，地址中保存的信息是我们所需的信息，但程序重新启动后，该地址中的内容就不再是我们所需的信息了\r\n\r\n\r\n寻找阳光动态地址\r\n\r\n首先通过CE附加植物大战僵尸进程，因为阳光是一个精确的数值50，所以可以选择exact\r\nvalue来进行搜索，首次搜索会得到很多相关的结果\r\n\r\n\r\n\r\n1\r\n\r\n\r\n收集一个阳光后，改变数值为75并再次搜索，此时搜索到唯一的一个结果\r\n\r\n\r\n为了验证这个结果是否正确，我们可以手动修改地址中的数值\r\n如何判断这个地址是否是静态基址，若CE标识的地址为绿色，则该地址为静态基址，而此处的地址并不是绿色的，所以这是个动态地址，因此我们需要寻找基址\r\n寻找基址\r\n\r\n我们已经找到了阳光的动态地址，那么如何寻找基址，思路是，阳光每次变动就意味着一定有一条指令修改了这个地址中的值，那么我们可以下一个内存写入断点，看看哪条指令写入了这个地址，所以我们再CE中选中这个地址，右键找到find\r\nout what writes to this address\r\n\r\n\r\n之后我们收集一个阳光，发现得到了一条指令，我们双击打开\r\n\r\n此时我们可以知道，ecx的值0x19，也就是25，写入了阳光地址标识的内存中，因此阳光的地址\r\n= eax + 0x5560，该地址内存放了当前阳光的具体数值，其中eax =\r\n0x17326B58，而0x5560为偏移地址\r\n\r\n此时我们猜想，内存中有没有一个位置存放了0x17326B58这个值，因此我们可以使用CE，并以16进制搜索0x17326B58，发现很多搜索结果，首先可以排除地址在0x00400000以下的内容，这部分是不进行映射的，以便捕获异常的空指针引用，因此我们找到第一个大于0x00400000的地址，这个值通常是我们需要的，即0x0290A938\r\n\r\n\r\n此时我们可以知道0x0290A938这个地址内保存了0x17326B58这个值，但是0x0290A938这个地址仍是个动态地址，所以我们还需要进一步寻找基址\r\n此时我们用CE下个内存访问断点，查看哪条指令访问了0x0290A938这个地址内的值，可以看到4个结果，我们点进第一个指令发现0x0290A938\r\n= edi + 0x768，其中edi = 0290A1D0，0x768也是偏移地址\r\n\r\n那么同理我们可以看看内存中哪里存放了0290A1D0，得到如下结果\r\n\r\n这时我们看到几个绿色的地址，这就代表这些地址就是静态基址，我们选择第一个，可以看到其地址为0x6A9EC0，这就是我们需要的静态基址，那么如何通过静态基址找到最后的阳光地址呢\r\n\r\n现在梳理一下这个过程\r\n\r\n阳光的动态地址 = 0x17326B58 +\r\n0x5560，而0x17326B58存在地址为0x0290A938的内存中，即[0x0290A938] =\r\n0x17326B58\r\n地址0x0290A938 = 0290A1D0 +\r\n0x768，而0290A1D0存在地址为静态基址为0x6A9EC0的内存中，即[0x6A9EC0] =\r\n0x0290A1D0\r\n所以我们可以得到，阳光地址 = [[0x6A9EC0] + 0x768] + 0x5560\r\n\r\n\r\n之后我们在CE中验证我们的结果，选择add address manually\r\n\r\n之后选择Point，因为此处包含两个偏移地址，因此再点击add\r\noffset，然后填入我们找到的基址与偏移地址\r\n\r\n最终我们可以看到，这个地址内，存的就是当前阳光的数值，修改后，游戏内的阳光也随之改变，且重启游戏后，该地址仍然存的是阳光的数值\r\n\r\n实现无限阳光的功能\r\n的到进程空间中阳光的地址，并向阳光地址处写入所需阳光数，即可实现无限阳光的功能，具体实现细节就不做赘述，给出核心代码\r\n// 将寻找地址功能封装成GetThirdLevelAddress()函数，方便后续寻找金币地址DWORD sunAddress = GetThirdLevelAddress()// 自定义阳光数量DWORD dwSun = 9999;//写入             WriteProcessMemory(hProcess, (LPVOID)sunAddress, (LPCVOID)&amp;dwSun, sizeof(DWORD), &amp;pid)          \r\n金币地址的寻找大同小异，这里也不再赘述，这样我们就完成了无限阳光与无限金币的功能\r\n","categories":["逆向"]},{"title":"逆向之植物大战僵尸（三）","url":"/2023/02/27/2023-02-27-%E9%80%86%E5%90%91%E4%B9%8B%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%EF%BC%88%E4%B8%89%EF%BC%89/","content":"上一章我们实现了植物无CD的功能，主要使通过定位CDTimers间接定位到了if判断的位置，并通过使用nop填充jle指令，改变了程序的执行流程，使其总是运行植物不处于CD状态中的代码\r\n现在我们希望实现另一个功能，即在同一个位置能够重复的放置植物\r\n同一格重复放置植物\r\n思路\r\n\r\n思路一：我们假设放置植物是通过一个二维数组记录的，当二维数组中记录如-1之类的值时，代表位置空闲，可以放置植物，当数组中记录植物编号时，代表位置被占用，不可放置，该思路需要我们能定位到该二维数组，在放置植物时保证二维数组中的值不变，使该位置为空位置\r\n思路二：在我们放置植物时，我们需要一个if判断，用于判断该位置是否可放植物，若可放置，则阳光会减少放置植物所需的cost，即该思路需要我们定位一个cmp指令，即\r\n\r\n\r\nif(可以放置植物)&#123;    阳光减少&#125;\r\n\r\n通过对比我们可以发现思路二更简单，且方法与上一章实现植物无CD相同，同时，阳光在内存中的位置，我们在第一章中也已经定位到，因此使用思路二能使我们更快的定位到CMP位置，\r\n\r\n定位是否可以放置跳转\r\n\r\n我们已经知道，若在一个空位置放置植物，阳光会减少相应的cost，因此我们在阳光的内存处下一个内存写入断点，之后在一个空位放置向日葵，可以发现CE显示了一条指令，我们双击该指令观察esi的值，发现其中的值正是放置向日葵后的阳光数\r\n\r\n\r\n\r\n我们记下该指令的地址，用x64Dbg附加游戏，找到该指令并在此处下一个断点，在游戏中再放一个向日葵，使游戏执行到该处，我们可以看到该指令之后将会返回至另一个位置，在堆栈窗口中，我们可以看到其返回的具体地址\r\n\r\n\r\n\r\n跟进到返回后的位置，我们将该call假设为阳光减少call，我们发现该call周围有大量的跳转指令，且整个代码段中都有大量跳转指令，因此我们无法判断代码段中的哪个跳转指令，此时我们需要一个方法来筛选哪些跳转指令是我们需要关注的\r\n\r\n\r\n\r\n一个可行的方法是，我们向上找到该代码段的起始位置，并下一个断点，在游戏中我们先在空闲位置放置一个向日葵，此时程序会断在代码段起始位置，我们单步调试，在每一个跳转指令处记录其是否跳转，以0标记不跳转，1标记跳转，直至该代码段结束\r\n\r\n\r\n\r\n2022-03-01-空闲跳\r\n\r\n之后我们返回游戏，选择向日葵，将其放置在一个有植物的位置，再次单步调试跟进每一个跳转指令，寻找发生变化的跳转指令，之后我们定位到该跳转指令发生了变化\r\n\r\n\r\n为了印证该跳转是不是决定了该位置为空位置，我们先在此处下个断点，然后修改其执行流程，因为此次放置非空位置，若修改后可以在同一位置重复放置植物，则成功，若不能重复放置，方便我们从此处再对后续的跳转指令进行对比，这里我们将ZF标志位置为1，je指令从不跳转变为跳转\r\n\r\n\r\n\r\n运行游戏，此时我们发现向日葵重复放置在了同一位置，因此该跳转使得我们可以实现重复放置的功能，即跳转则可放，不跳转则不可放，且通过分析反汇编我们不难得出，跳转指令之前的call实现了判断位置是否为空的功能\r\n\r\n\r\n\r\n如果要让跳转指令一直跳转，我们可以将其改为jmp无条件跳转指令，此时回到游戏我们就已经实现了重复种植的功能\r\n\r\n\r\n实现重复放置功能\r\n// JMP 0x00410754的硬编码，硬编码的操作码部分为偏移地址buffer[0] = 0xE9;buffer[1] = 0x20;buffer[2] = 0x09;buffer[3] = 0x00;buffer[4] = 0x00;buffer[5] = 0x90;// 填充至原je跳转指令处WriteProcessMemory(hProcess_, (LPVOID)0x0040FE2F, (LPCVOID)buffer, sizeof(buffer), &amp;pid_)\r\n","categories":["逆向"]},{"title":"PE文件解析（一）","url":"/2024/07/01/2024-07-01-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","content":"基本概念\r\n什么是PE文件\r\n\r\nPE文件的全程：Portable Executable，即可移植的可执行文件\r\n常见的PE文件：EXE文件、DLL文件、OCX文件、SYS文件、COM文件\r\nPE文件通常是指32位的，而64位的PE文件通常称为PE32+、PE+、PE64\r\n\r\n文件偏移地址、虚拟地址与相对虚拟地址\r\n\r\n文件偏移地址：PE文件存储在磁盘中时，某个数据的位置相对于文件头部的偏移量，通常将其称为文件偏移地址（File\r\nOffset Address）或物理地址（RAW Offset）\r\n虚拟地址：在Windows系统中，PE文件会被系统加载器映射到内存中，而每个PE文件都有其自己的独立的虚拟空间，这个虚拟空间的内存地址就被称为虚拟地址（Virtual\r\nAddress）\r\n相对虚拟地址：当PE文件映射到内存之后，某个数据相对于文件载入点地址（即基地址，ImageBase）的偏移量，通常称其为相对虚拟地址（Relative\r\nVirtual Address），虚拟地址与相对虚拟地址存在如下关系：虚拟地址(VA) =\r\n基地址(ImageBase) + 相对虚拟地址(RVA)\r\n\r\n\r\nPE结构图\r\n\r\nPE文件框架结构 \r\nPE文件的详细结构 \r\nPE文件磁盘结构与内存结构（对齐原因） \r\n\r\nPE Headers解析\r\n首先需要明确的是，严格意义上的PE文件头是指IMAGE_NT_HEADERS，但为了方便解析，此处将\r\n\r\nIMAGE_DOS_HEADER（DOS头）\r\nIMAGE_NT_HEADERS（NT头）\r\nIMAGE_FILE_HEADER（映像文件头）\r\nIMAGE_OPTIONAL_HEADER（可选映像头）\r\nIMAGE_SECTION_HEADER（区块表）\r\n\r\n这五个部分都视作PE的头部部分一并进行解析\r\nIMAGE_DOS_HEADER\r\nMS-DOS头部，大小为64字节，每个PE文件都是以一个DOS程序开始的，且DOS可以识别出一个文件是不是一个有效的执行体，若其首部的e_magic被置为0x5A4D（即ASCII的\r\n“MZ”，该值对应于winnt.h文件中的一个宏定义，IMAGE_DOS_SIGNATURE），那么该文件就是一个DOS可执行文件\r\ntypedef struct _IMAGE_DOS_HEADER &#123;          WORD   e_magic;                     // DOS可执行文件标记 &quot;MZ&quot;    WORD   e_cblp;                          WORD   e_cp;                            WORD   e_crlc;                          WORD   e_cparhdr;                       WORD   e_minalloc;                      WORD   e_maxalloc;                      WORD   e_ss;                            WORD   e_sp;                            WORD   e_csum;                          WORD   e_ip;                        // DOS代码入口IP    WORD   e_cs;                        // DOS代码入口CS    WORD   e_lfarlc;                        WORD   e_ovno;                          WORD   e_res[4];                        WORD   e_oemid;                         WORD   e_oeminfo;                       WORD   e_res2[10];                      LONG   e_lfanew;                    // 偏移地址，指向IMAGE_NT_HEADERS，&quot;PE00&quot;(0x00004550)  &#125; IMAGE_DOS_HEADER\r\n其中比较重要的两个字段分别是e_magic与e_lfanew，前者的作用已经解释过，而e_lfanew是真正的PE文件头IMAGE_NT_HEADERS的相对偏移(lfanew\r\n= long file address of new exe)\r\n用十六进制编辑器打开exe文件可以发现，起始位置e_magic字段的值为”MZ”，而e_lfanew的值为”0x000000F0”，在相对文件起始位置0x000000F0的位置我们可以找到真正的PE文件头标记”PE00”\r\n\r\n我们可以观察到在e_lfanew和真正的PE头之间还有一些数据，这部分数据被称为DOS\r\nstub（即DOS块），DOS\r\nstub实际上是一个有效的exe，在不支持PE文件格式的操作系统中，它将显示一个错误提示，即”This\r\nprogram cannot be run in DOS mode”，DOS\r\nstub的数据大多由编译器自动生成，可根据自己的需要修改其中的内容，我们将IMAGE_DOS_HEADER与DOS\r\nstub合称为DOS文件头\r\nIMAGE_NT_HEADERS\r\n紧跟着DOS\r\nstub的就是真正的PE文件头了，这部分也被称为NT映像头，在一个有效PE文件中，其Signature字段被置为0x00004550（即ASCII的”PE00”，该值对应于winnt.h文件中的一个宏定义，IMAGE_NT_SIGNATURE），而紧跟在Signature字段之后的就是IMAGE_FILE_HEADER映像文件头，在此之后紧跟的是IMAGE_OPTIONAL_HEADER可选映像头\r\ntypedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature;                                  // PE文件标识    IMAGE_FILE_HEADER FileHeader;                         IMAGE_OPTIONAL_HEADER32 OptionalHeader;           &#125; IMAGE_NT_HEADERS32\r\n在十六进制编辑器中，NT影响头的结构如下图所示，首个字段即为”PE00”标记，紧跟其后红色框所示部分就是映像文件头，紧跟映像文件头之后的蓝色框所示的部分就是可选映像头\r\n\r\nIMAGE_FILE_HEADER\r\n映像文件头中包含PE文件的一些基本信息，大小为20字节，其中较为重要的两个字段为NumberOfSections字段与SizeOfOptionalHeader字段，前者指出了区块Section的数量（同时也指明了IMAGE_SECTION_HEADER区块表的数量，因为每一个区块表记录了对应区块的相关信息），后者指出了IMAGE_OPTIONAL_HEADER可选映像头的大小\r\ntypedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine;                          // 运行平台    WORD    NumberOfSections;                 // 区块数    DWORD   TimeDateStamp;                    // 文件创建的日期和时间    DWORD   PointerToSymbolTable;             // 指向符号表（用于调试）    DWORD   NumberOfSymbols;                  // 符号表中的符号的个数（用于调试）    WORD    SizeOfOptionalHeader;             // 可选映像头的大小    WORD    Characteristics;                  // 文件属性&#125; IMAGE_FILE_HEADER\r\n这里对字段进行详细的解释：\r\n1.\r\nMachine：可执行文件的目标CPU类型，因为不同平台上指令集不同，因此需要该字段标识运行的平台，如Inter\r\ni386及其之后的处理器，该字段的值都为0x14C\r\n2. NumberOfSections：区块数\r\n3.\r\nTimeDateStamp：文件创建的时间，将该值翻译为易读字符串需要使用_ctime函数\r\n4.\r\nPointerToSymbolTable：COFF符号表的文件偏移位置（FOA），现较为少见\r\n5.\r\nNumberOfSymbols：如果有文件符号表，其指出了文件符号表中符号的数目\r\n6.\r\nSizeOfOptionalHeader：可选映像头的大小，其大小通常依赖于文件是32位还是64位的，若是32位文件，这个值默认为0x00E0，若是64位文件，这个值默认为0x00F0，这表示了选映像头大小的最小值，因此该值是可以修改的\r\n7.\r\nCharacteristics：文件属性，其结果为若干个有效值的和，有效值在winnt.h定义\r\n#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // 不存在重定位信息#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // 文件可执行 若为0，通常是链接时出问题#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // 行号信息被移除#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // 符号信息被移除#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // 应用程序可以处理超过2GB的地址，因为大部分数据库服务器需要很大的内存，而NT仅提供2GB给应用程序，因此从NT SP3开始，可以通过设置此参数，使应用程序分配2 ~ 3GB区域的地址（此部分原本为系统内存区）#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // 处理器的低位字节是相反的#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 目标平台为32为机器#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // .DBG文件的调试信息被移除#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // 如果映像文件在可移动介质中，则先复制到交换文件中再运行#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // 如果映像文件在网络中，则先复制到交换文件后再运行#define IMAGE_FILE_SYSTEM                    0x1000  // 系统文件#define IMAGE_FILE_DLL                       0x2000  // DLL文件#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // 文件只能运行在单处理上#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // 处理器的高位字节是相反的\r\nIMAGE_OPTIONAL_HEADER\r\n虽然称为可选映像头，但该结构是必不可少的，其中定义了更多的数据，32位下最小大小为E0\r\ntypedef struct _IMAGE_OPTIONAL_HEADER &#123;    WORD    Magic;                            // 标志字    BYTE    MajorLinkerVersion;               // 链接器主版本号    BYTE    MinorLinkerVersion;               // 连接器次版本号    DWORD   SizeOfCode;                       // 所有含有代码的区块的大小    DWORD   SizeOfInitializedData;            // 所有初始化数据区块大小    DWORD   SizeOfUninitializedData;          // 所有未初始化数据区块大小    DWORD   AddressOfEntryPoint;              // 程序执行入口RVA    DWORD   BaseOfCode;                       // 代码区块起始RVA    DWORD   BaseOfData;                       // 数据区块起始RVA    DWORD   ImageBase;                        // 程序默认载入基地址    DWORD   SectionAlignment;                 // 内存中块的对齐值    DWORD   FileAlignment;                    // 磁盘文件中块的对齐值    WORD    MajorOperatingSystemVersion;      // 操作系统主版本号    WORD    MinorOperatingSystemVersion;      // 操作系统次版本号    WORD    MajorImageVersion;                // 用户自定义主版本号    WORD    MinorImageVersion;                // 用户自定义次版本号    WORD    MajorSubsystemVersion;            // 所需子系统主版本号    WORD    MinorSubsystemVersion;            // 所需子系统此版本号    DWORD   Win32VersionValue;                // 保留，通常设置为0    DWORD   SizeOfImage;                      // 映像载入内存后的总大小    DWORD   SizeOfHeaders;                    // DOS头、PE文件头、区块表的总大小    DWORD   CheckSum;                         // 映像校验和    WORD    Subsystem;                        // 文件子系统    WORD    DllCharacteristics;               // 显示DLL特性的旗标    DWORD   SizeOfStackReserve;               // 初始化时栈的大小    DWORD   SizeOfStackCommit;                // 初始化时实际提交的栈大小    DWORD   SizeOfHeapReserve;                // 初始化时保留的堆大小    DWORD   SizeOfHeapCommit;                 // 初始化时实际保留的堆大小    DWORD   LoaderFlags;                      // 调试相关，默认值为0    DWORD   NumberOfRvaAndSizes;              // 数据目录项的数量    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];       // 数据目录表数组&#125; IMAGE_OPTIONAL_HEADER32\r\n这里对一些较为关键的字段进行详细的解释：\r\n1.\r\nMagic：标志字，ROM映像为0x107，32位可执行映像为0x010B，64位可执行映像位0x020B\r\n2.\r\nSizeOfCode：所有含有IMAGE_SCN_CNT_CODE属性的区块的总大小，必须是FileAlignment的整数倍，由编译器填写，通常情况下，大多数文件只有一个Code块，所以该字段与.text块的大小匹配\r\n3.\r\nSizeOfUninitializedData：所有未初始化数据区块大小，装载程序需要在虚拟地址空间中位这些数据分配空间，这些块在磁盘文件中不占空间，在程序开始运行时没有指定值，未初始化数据通常在.bss块中\r\n4.\r\nAddressOfEntryPoint：程序执行入口RVA。对于DLL，这个入口点在进程初始化和关闭时与线程创建和销毁时被调用，在大多数可执行文件中，这个地址不直接指向Main、WinMain或DllMain，而是指向运行时的库代码，并由它来调用上述函数\r\n5.\r\nImageBase：程序默认载入基地址，如果PE文件在这个地址载入，加载器将会跳过应用基址重定位的步骤\r\n6.\r\nSectionAlignment：载入内存时，内存中块的对齐值，也就是说每个区块被载入的地址必定是本字段指定数值的整数倍，默认的对齐尺寸是目标CPU的页尺寸（通常是0x10000，也就是4KB）\r\n7.\r\nFileAlignment：磁盘文件中块的对齐值，区块在磁盘文件中存储的首地址必定是本字段指定数值的整数倍，对于x86可执行文件，这个值常为0x200或0x1000，这是为了保证块总是从磁盘的扇区开始，该值必须是2的幂\r\n8.\r\nSizeOfImage：映像载入内存后的总大小，即从ImageBase到最后一个块结束，且按照SectionAlignment对齐的大小\r\n9.\r\nSizeOfHeaders：DOS头、PE文件头、区块表的总大小，按FileAlignment对齐\r\n10.\r\nCheckSum：映像校验和，CheckSumMappedFile函数可以计算该值，通常情况下，普通的EXE文件该值为0，但内核模式的驱动程序和系统DLL必须有一个校验和\r\n11. NumberOfRvaAndSizes：数据目录项的数量，该值至今一直为16\r\n12.\r\nDataDirectory[16]：数据目录数组，由数个相同的IMAGE_DATA_DIRECTORY结构组成，其具体的结构如下\r\ntypedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;         // 数据块的RVA    DWORD   Size;                   // 数据块的大小&#125; IMAGE_DATA_DIRECTORY\r\n数据目录表成员的结构如下所示\r\n\r\n\r\n\r\n序号\r\n表名\r\n结构\r\n\r\n\r\n\r\n\r\n0\r\nExport Table\r\nIMAGE_DIRECTORY_ENTRY_EXPORT\r\n\r\n\r\n1\r\nImport Table\r\nIMAGE_DIRECTORY_ENTRY_IMPORT\r\n\r\n\r\n2\r\nResources Table\r\nIMAGE_DIRECTORY_ENTRY_RESOURCE\r\n\r\n\r\n3\r\nException Table\r\nIMAGE_DIRECTORY_ENTRY_EXCEPTION\r\n\r\n\r\n4\r\nSecurity Table\r\nIMAGE_DIRECTORY_ENTRY_SECURITY\r\n\r\n\r\n5\r\nBase Relocation Table\r\nIMAGE_DIRECTORY_ENTRY_BASERELOC\r\n\r\n\r\n6\r\nDebug\r\nIMAGE_DIRECTORY_ENTRY_DEBUG\r\n\r\n\r\n7\r\nCopyright\r\nIMAGE_DIRECTORY_ENTRY_COPYRIGHT\r\n\r\n\r\n8\r\nGlobal Ptr\r\nIMAGE_DIRECTORY_ENTRY_GLOBALPTR\r\n\r\n\r\n9\r\nThread Local Storage (TLS)\r\nIMAGE_DIRECTORY_ENTRY_TLS\r\n\r\n\r\n10\r\nLoad Configuration\r\nIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\r\n\r\n\r\n11\r\nBound Import\r\nIMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\r\n\r\n\r\n12\r\nImport Address Table (IAT)\r\nIMAGE_DIRECTORY_ENTRY_IAT\r\n\r\n\r\n13\r\nDelay Import\r\nIMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\r\n\r\n\r\n14\r\nCOM Descriptor\r\nIMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\r\n\r\n\r\n15\r\n保留，必须为0\r\n-\r\n\r\n\r\n\r\nIMAGE_SECTION_HEADER\r\n区块表中记录了区块的具体信息，每个区块表分别指向了不同的区块实体，紧跟在\r\nIMAGE_OPTIONAL_HEADER 之后，每个区块表大小都是40字节\r\ntypedef struct _IMAGE_SECTION_HEADER &#123;    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];      // 8字节大小的块名    union &#123;            DWORD   PhysicalAddress;            DWORD   VirtualSize;    &#125; Misc;                                     // 实际被使用的区块的大小，未对齐    DWORD   VirtualAddress;                     // 该块装载到内存中的RVA    DWORD   SizeOfRawData;                      // 在磁盘中区块的大小，已对齐    DWORD   PointerToRawData;                   // 该块在磁盘中的偏移FOA    DWORD   PointerToRelocations;               // 在EXE中无意义，在OBJ文件中表示本块重定位信息表的偏移    DWORD   PointerToLinenumbers;               // 调试信息，行号表在文件中的偏移    WORD    NumberOfRelocations;                // 在EXE中无意义，在OBJ文件中表示本块在重定位表中重定位数量    WORD    NumberOfLinenumbers;                // 该块在行号表中的行号数量    DWORD   Characteristics;                    // 块属性&#125; IMAGE_SECTION_HEADER\r\n块属性中的一些重要字段值如下所示\r\n#define IMAGE_SCN_CNT_CODE                   0x00000020  // 包含代码，通常与0x10000000一起设置#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // 包含已初始化数据#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // 包含未初始化数据#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // 该块可被丢弃，因为它一旦被载入，进程就不再需要它了，常见的可丢弃块是.reloc（重定位块）#define IMAGE_SCN_MEM_SHARED                 0x10000000  // 该块为共享块#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // 该块可执行，通常当0x00000020标志被设置时，该标志也被设置#define IMAGE_SCN_MEM_READ                   0x40000000  // 该块可读，可执行文件中总是设置该标志#define IMAGE_SCN_MEM_WRITE                  0x80000000  // 该块可写，若PE文件中没有设置该标志，装载程序就会将内存映像页标记为可读或可执行\r\n在十六进制编辑器中的区块表信息如下图所示，可以观察到该exe文件包含4个区块表，其中四个区块的信息名称分别为\r\n\r\n.text\r\n.rdata\r\n.data\r\n.rsrc\r\n\r\n\r\n区块解析\r\n首先需要注意的是，区块名称只是为了方便辨识，但对于操作系统来说是无关紧要的，如当寻找输出表、输入表信息时，不应该默认到.text和.rdata区块中寻找，而是要严格依据数据目录数组DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]中的信息进行查找，常见区块如下\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\n.text\r\n默认的代码区块，其中的内容全是指令代码\r\n\r\n\r\n.data\r\n默认的读、写区块，全局变量、静态变量通常放在此处\r\n\r\n\r\n.rdata\r\n默认的只读数据区块，程序较少用到该块中的数据，但至少有两种情况会用到，一是在Microsoft链接器产生的exe文件中，用于存放调试目录；二是用于存放说明字符串，如果程序的DEF文件中指定了DESCRIPTION，字符串就会在出现在该块中\r\n\r\n\r\n.idata\r\n输入表，包含其他外来DLL的函数及数据信息，通常将其合并到其他区块中，如.rdata\r\n\r\n\r\n.edata\r\n输出表，当创建一个输出API或数据的可执行文件时（如DLL），链接器会创建一个.exp文件，.exp文件将会包含一个.edata区块，并加入到最后的可执行文件中，通常将.edata合并到其他块中，如.text区块中\r\n\r\n\r\n.rsrc\r\n资源，包含模块的全部资源，例如图标、菜单、位图等，该区块是只读的，无论如何都不应该命名为为.rsrc以外的名字，也不能被合并到其他区块中\r\n\r\n\r\n.reloc\r\n可执行文件的基址重定位，通常只是DLL需要，而exe不需要，通常在Release模式下，链接器不会给exe文件加上基址重定位\r\n\r\n\r\n\r\n","categories":["逆向"]},{"title":"PE文件解析（二）","url":"/2024/07/03/2024-07-03-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"之前已经对PE文件的总体结构进行了解析，但PE文件中的很多重要的数据还存放在各类数据表中，因此我们还需要对这些表信息进行解析，这里主要包块输入表与输入地址表、输出表、重定位表、资源表五个部分\r\n输入表与输入地址表\r\n什么是输入表\r\n可执行文件使用来自其他DLL的代码与数据的行为称为输入，当PE文件载入内存时，Windows加载器的工作之一就是找到这些输入的函数与数据，并让文件可以使用这些代码与数据的正确地址，而这个过程正是通过输入表（Import\r\nTable）完成的，输入表中保存了输入的函数名和这些函数所在的DLL名称\r\n\r\n什么是输入地址表\r\n当我们调用DLL中的函数时，调用者程序无法得知这些函数的实际地址，因为这些函数的实际地址只有当PE文件载入内存中时才得以确定，所以我们采取了一种间接调用的形式，即在内存中仅保留函数名（或序号），通过此方法告知Windows加载器，我们需要这样的一个函数，当PE文件载入内存后，Windows加载器便将相关DLL载入内存，同时将函数名替换成函数实际所处的地址，而记录这些中间函数信息并最终被替换成实际地址的结构即为输入地址表IAT，记住这个转换过程，之后我们会做详细讲解\r\n输入表的结构\r\n在了解什么是输入表、什么是输入地址表之后，我们了解下它们载入内存前的大致结构\r\n\r\n我们发现图中一共包含了4张表，分别是输入表IMAGE_IMPORT_DESCRIPTOR、输入名称表（INT）、输入地址表（IAT）、函数表IMAGE_IMPORT_BY_NAME，现在我们分别给出这四个表在winnt.h的具体定义\r\n输入表 typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;                    DWORD   OriginalFirstThunk;             &#125; DUMMYUNIONNAME;                       // INT表的RVA    DWORD   TimeDateStamp;                      DWORD   ForwarderChain;                     DWORD   Name;                           // DLL名字的RVA    DWORD   FirstThunk;                     // IAT表的RVA&#125; IMAGE_IMPORT_DESCRIPTOR\r\n\r\nOriginalFirstThunk：指向输入名称表INT的RVA，INT是一个IMAGE_THUNK_DATA结构的数组，数组以一个全0内容来标识数组的结束\r\nTimeDateStamp：32位时间标记\r\nForwarderChain：当程序使用一个DLL中的API，而该API又使用其他DLL中的API时使用，通常为0\r\nName：DLL名字的RVA\r\nFirstThunk：指向输入地址表IAT的RVA，与INT类似，IAT也是一个IMAGE_THUNK_DATA结构的数组\r\n\r\nIMAGE_THUNK_DATA的结构 typedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;              DWORD Function;                     DWORD Ordinal;        DWORD AddressOfData;            &#125; u1;                                   &#125; IMAGE_THUNK_DATA32;\r\n每个IMAGE_THUNK_DATA都对应一个输入函数，由于是一个联合结构，所以其本质是一个大小为4字节的数，但该数在不同时刻具有不同含义\r\n\r\n当该数的最高位为1时，表示该函数以序号方式输入，此时低31位就是该函数的序号\r\n当该数的最高位为0时，表示该函数以名称方式输入，此时整个32位就代表一个指向IMAGE_IMPORT_BY_NAME的RVA\r\n\r\nIMAGE_IMPORT_BY_NAME的结构 typedef struct _IMAGE_IMPORT_BY_NAME &#123;    WORD    Hint;    CHAR   Name[1];&#125; IMAGE_IMPORT_BY_NAME\r\n\r\nHint：本函数在其所驻留的DLL中输出表的序号，但该值不是必须的，一些链接器直接将其置为0\r\nName：输入函数函数名的变长数组，以0结尾\r\n\r\n输入表如何工作\r\n原理\r\n我们之前提到IAT表承担了将函数名转换成实际地址的功能，其实这就是输入表的主要功能，即载入时替换IAT表中的内容，一旦替换工作完成，那么整个输入表的替他部分就不关键了，程序依靠IAT表中的内容就可以正常运行\r\n我们现在来看PE文件载入内存后输入表的结构，我们可以发现IAT此时不再指向IMAGE_IMPORT_BY_NAME表，其中的内容被填入了函数的实际地址\r\n\r\n具体的工作流程是\r\n\r\n①PE装载器先通过INT表找出每个IMAGE_IMPORT_BY_NAME结构指向的函数地址\r\n②装载器用函数真正的入口地址来替代IAT中的值\r\n\r\n也就是说在实际的程序中，当我们调用一个DLL中的函数，其采用了一种间接调用的形式call\r\ndword ptr\r\n[xxxxxxx]，这个xxxxx就是IAT表的地址，当载入内存前，[xxxxxx]指向了IMAGE_IMPORT_BY_NAME中的对应的函数，而载入内存后[xxxxxx]就指向了函数的实际地址，这就是转换工作在程序中的体现\r\n实例\r\n为了解释这一过程，我们通过一个例子来理解其中的转换过程，例如此处我们的程序使用了一个TestDLL.dll中的Plus函数，首先我们在反汇编程序中观察反汇编代码，可以发现我们我们并不是call了一个绝对地址，而是call了ds:[0x402000]内存里的内容，我们在内存窗口里观察到0x402000处的4字节信息为0x10001050\r\n\r\n之后我们跟进call中，可以发现来到了Plus函数内部，而地址正是0x10001050，也就是说调用Plus函数是以一种间接调用的形式实现的，且ds:[0x402000]中存了Plus函数载入内存后的实际地址0x10001050\r\n\r\n此时程序已经载入内存，而我们需要查看其载入内存前ds:[0x402000]的内容，因为该程序的ImageBase为0x400000，那么RVA\r\n=\r\n0x2000，将其转换为FOA即是0x1200，现在我们打开16进制编辑器，找到此处观察发现里面存了一个RVA偏移值0x2778（指向IMAGE_IMPORT_BY_NAME中的对应的函数）\r\n\r\n我们将0x2778转换为其对应的FOA，即0x1978，我们来到该处可以看到这里记录了函数的名字\r\n\r\n现在我们已经分析完了输入表的整个工作流程，通过PE\r\ntools我们可以查看完整的输入表信息\r\n\r\n需要注意的是，我们的程序使用了多少个DLL，就会有多少个输入表，且输入表也是以一个全0的结构作为判空标识的，最后，我们用一个简单的图来回顾整个过程\r\n\r\n","categories":["逆向"]},{"title":"PE文件解析（三）","url":"/2024/07/15/2024-07-15-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/","content":"之前讲解了输入表与输入地址表以及他们的工作原理，现在我们开始分析输出表与重定位表\r\n输出表\r\n创建一个DLL时，实际上创建了一组能让exe或其他DLL调用的函数，而PE装载器将根据DLL文件中的输出信息修正正被执行文件中的IAT。通常exe文件中不存在输出表（并不绝对），而大部分DLL文件中则存在输出表\r\n输出表的结构\r\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123;    DWORD   Characteristics;            // 旗标，未使用，总是为0    DWORD   TimeDateStamp;    WORD    MajorVersion;               // 主版本号，一般为0    WORD    MinorVersion;               // 次版本号，一般为0    DWORD   Name;    DWORD   Base;    DWORD   NumberOfFunctions;    DWORD   NumberOfNames;    DWORD   AddressOfFunctions;         DWORD   AddressOfNames;             DWORD   AddressOfNameOrdinals;  &#125; IMAGE_EXPORT_DIRECTORY\r\n\r\n现在对一些重要属性做出解释\r\n\r\nTimeDateStamp：输出表的创建时间（GMT时间）\r\nName：指向一个ASCII字符串的RVA，即DLL的名字\r\nBase：一个初始序号值，当通过序号查询输出的函数时，实际数值 =\r\n查询数值 - Base，实际数值即为输出函数地址表（EAT）的索引\r\nNumberOfFunctions：输出函数地址表中条目的数量\r\nNumberOfNames：输出函数名称表（ENT）和输出函数序号表中条目的数量\r\nAddressOfFunctions：输出函数地址表的RVA，是一个RVA数组\r\nAddressOfNames：输出函数名称表的RVA，也是一个RVA数组，该表会排序\r\nAddressOfNameOrdinals：输出序号表的RVA，指向输出序号的数组，即一个WORD大小的数组\r\n\r\n我们看到结构中提到了3张表，分别是输出函数地址表EAT、输出函数名称表ENT、输出函数序号表，那么他们之间有什么联系呢？且DLL中的函数既可以通过名称导出，也可以通过序号导出，那么两种不同的导出方式，又要如何定位函数的地址呢？\r\n\r\n函数通过名称导出时，如何建立名称到地址的映射关系就成了关键，而输出函数序号表就是承担中转工作的，我们之前提到这三张表都是数组，假设我们有一个名称A的函数，通过查询ENT表得到其索引为3，那么函数A的序号在函数序号表的索引也是3，我们从序号表中取出该函数的序号，这个序号就是函数A在EAT表中的索引\r\n函数通过序号导出时，导出序号 - base = EAT表索引\r\n\r\n实例\r\n为了便于理解，假设我们有DLLTest.dll文件，其中定义了4个函数Plus、Sub、Mul和Div，其中Plus、Sub、和Div以函数名导出，并将其导出序号分别设置为1、5、9，而Mul以序号导出，其序号为为7，具体如下\r\n\r\n\r\n此时我们画一张导出表的示意图来进行细致的解释\r\n\r\n\r\n对于名称导出方式，以Sub函数为例，我们可以看到它在ENT表中的索引为2，那么我们到序号表中查询索引为2的序号值，其结果为4，这意味着Sub函数的RVA地址存放在EAT表中的索引为4的地方，此时我们再查看EAT表就可以得到Sub函数的RVA为0x1060\r\n对于序号导出方式，我们将Mul以序号7将其导出，此时Base =\r\n1，那么Mul的RVA地址在EAT表中的索引就是7 - 1 =\r\n6，通过查EAT表我们得到了Mul的RVA为0x1070\r\n\r\n重定位表\r\n首先，为什么会有重定位表，我们都知道在可选映像头中有一个ImageBase属性，这个属性标识了PE文件默认的载入基地址，但是一个exe文件可能同时包含了多个DLL，而这些DLL的ImageBase又都是0x10000000，为了避免冲突现象，我们只能将没抢占到0x10000000这个位置的DLL放入内存中的其他位置，此时就产生了一个问题，DLL中某些数据的地址写的是直接地址（ImageBase\r\n+\r\nRVA），此时换了一个新的基地址，我们要如何取到正确的取得这些数据呢，这就是重定位表的作用，标识出那些需要修正的位置\r\n重定位表的结构\r\ntypedef struct _IMAGE_BASE_RELOCATION &#123;    DWORD   VirtualAddress;    DWORD   SizeOfBlock;//  WORD    TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;\r\n\r\nVirtualAddress：重定位数据开始的RVA地址\r\nSizeOfBlock：重定位块的大小\r\n\r\n\r\n\r\n首先需要注意的是IMAGE_BASE_RELOCATION并不是孤立的一张表，在结构体后紧跟是一个WORD类型（2字节）的数组，数组长度为（SizeOfBlock\r\n- 8）/ 2\r\n其次，这些数据是高4位+低12位的结构，其中高4位为修改标记，若其为0011（即十进制的3），则表示该数据需要修改，低12位是一个Offset，需要用重定位表中的VirtualAddress\r\n+\r\nOffset才是需要修改的数据的RVA；若高4位为0，则不需要修改，作为对齐用\r\n每一张重定位表，都会记录一个4KB大小的数据块中需要修改的数据\r\n最后，重定位表最终以一个8字节大小的全0结构作为结束的标志\r\n\r\n最后，可能有人会有疑问，对于一个寻址能力为32位的操作系统，为什么Offset是一个2个字节大小的结构，内存地址不是需要4字节才能完整表示吗？\r\n这是因为重定位表采用VirtualAddress +\r\nOffset表示RVA造成的，我们先来看看这么做的好处，假设我们有一个16KB大小的数据块，其中有1000个需要重定位的数据\r\n\r\n如果我们采用直接记录RVA的方式，那么只需要一张重定位表，其大小为1000\r\n* 4 = 4000字节（如果需要SizeOfBlock记录大小，则至少为4004字节）\r\n如果我们采用VirtualAddress +\r\nOffset的方式，那么按实际的重定位表结构，我们将会有4张重定位表（每个重定位表只记录4KB大小的数据块），假设这1000个数据均匀分布在这4张表中，那么每张重定位表的大小为\r\n8 + 250 * 2 =\r\n508字节，那么4张重定位表总共2032字节，我们可以发现这样的设计大大缩小了重定位表的大小\r\n\r\n在理解了这样设计的好处之后，现在我们来回答，为什么Offset只需要两字节\r\n从原理的角度：一张重定位表记录一个4BK大小的数据块（即0x0000 ~\r\n0x0FFF），也就是说，我们的Offset只要能表示这个范围内的地址即可，因此Offset只需要12位即可表示（即重定位表中数据的低12位），处于对齐和功能性，我们将其设计为16位，即2字节，那么高4位就用来记录是否需要修改这一信息，所以VirtualAddress大小为4字节，可以记录任意数据块的在内存中的起始地址RVA，而Offset只需要2字节就可表示块内的任意Offset\r\n实例\r\n还是以之前DLLTest.dll为例，我们在PE\r\nTools中可以看到，该文件共有两张重定位表，标识了不同区块中需要修正的数据，其中.text中共有140个可能需要重定位的数据，而.data中有16个\r\n\r\n我们以.text中的第一个、第三个需要修改的数据为例，首先分析下他们的RVA\r\n0x1012和0x101E是怎么得到的，我们在16进制编辑器中找到重定位表，红框圈中的即为第一项数据0x3012和第三项数据0x301E，我们将其转换为二进制分别为0011\r\n0000 0001 0010和0011 0000 0001\r\n1110，可以发现他们的高4位都为0011，即需要修改，那么他们的低12位为Offset，分别是0x12和0x1E，那么需要修改的数据的RVA分别为VirtualAddress\r\n+ Offset，即0x1012和0x101E\r\n\r\n此时DLLTest.dll的ImageBase为0x10000000，我们用另一个程序调用DLLTest.dll，并用x64Dbg打开该程序，找到0x10001012处，可以发现其中一个是Push指令，而另一个是call指令（因为Push指令的操作码为0x68，需要占用一个字节，所以指令开始的地址是0x0x10001011，而0x10001012才是实际需要修改的数据的起始地址，call指令同理），那么当DLLTest.dll发生重定位时，这两个部分的数据就需要修改，此时记下他们：①0x100020A4；②0x10002030\r\n\r\n现在我们让DLL不从ImageBase载入，但不修改ImageBase中的值，我们在VS中将随机基址的打开，然后重新编译我们的DLL和调用该DLL的程序，现在虽然DLL的ImageBase还是0x10000000，但实际载入内存时DLL并不会从ImageBase载入\r\n\r\n我们在x64Dbg中重新定位，可以发现此时我们的DLL已经被放到了内存中的其他位置，且载入的基地址为0x78590000，此时我们看到RVA为0x1012处的数据被改成了0x785920A4，而RVA为0x101E处的数据被改为了0x78592030\r\n\r\n我们不难看出这两个值是如何计算得到的\r\n\r\n0x785920A4 = 0x100020A4 - 默认基地址0x10000000 +\r\n新基地址0x78590000\r\n0x78592030 = 0x10002030 - 默认基地址0x10000000 +\r\n新基地址0x78590000\r\n\r\n","categories":["逆向"]},{"title":"获取kernel32.dll","url":"/2025/04/12/2025-04-12-%E8%8E%B7%E5%8F%96kernel32.dll/","content":"FS寄存器\r\nfs寄存器记录了当前活动线程的TEB结构，具体信息如下 0x000 指向SEH链指针0x004 线程堆栈顶部0x008 线程堆栈底部0x00C SubSystemTib0x010 FiberData0x014 ArbitraryUserPointer0x018 FS段寄存器在内存中的镜像地址0x020 进程PID0x024 线程ID0x02C 指向线程局部存储指针0x030 PEB结构地址（进程结构）0x034 上个错误号\r\n\r\nshellcode中常用的获取kernel32.dll方法如下 1. 通过peb(fs:[30])获取\r\n\r\n通过fs:[30]获取\r\npeb(fs:[30])的结构\r\nwin11环境下大部分成员都被命名为Reserved typedef struct _PEB &#123;    +0x000 BYTE Reserved1[2];          +0x002 BYTE BeingDebugged;         +0x003 BYTE Reserved2[1];          +0x004 PVOID Reserved3[2];         +0x00C PPEB_LDR_DATA Ldr;          +0x010 PRTL_USER_PROCESS_PARAMETERS ProcessParameters;    +0x014 PVOID Reserved4[3];    +0x020 PVOID AtlThunkSListPtr;    +0x024 PVOID Reserved5;    +0x028 ULONG Reserved6;    +0x02C PVOID Reserved7;    +0x030 ULONG Reserved8;    +0x034 ULONG AtlThunkSListPtr32;    +0x038 PVOID Reserved9[45];    +0x0EC BYTE Reserved10[96];    +0x14C PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;    +0x150 BYTE Reserved11[128];    +0x1D0 PVOID Reserved12[1];    +0x1D4 ULONG SessionId;&#125; PEB, *PPEB;\r\n对照windows xp sp3 typedef struct _PEB &#123; \t+0x000    UCHAR           InheritedAddressSpace;    +0x001    UCHAR           ReadImageFileExecOptions;    +0x002    UCHAR           BeingDebugged;                  +0x003    UCHAR           SpareBool;    +0x004    HANDLE          Mutant;    +0x008    HINSTANCE       ImageBaseAddress;               +0x00C    struct _PEB_LDR_DATA    *Ldr                    +0x010    struct _RTL_USER_PROCESS_PARAMETERS  *ProcessParameters;    +0x014    ULONG           SubSystemData;    +0x018    HANDLE          DefaultHeap;    +0x01C    KSPIN_LOCK      FastPebLock;    +0x020    ULONG           FastPebLockRoutine;    +0x024    ULONG           FastPebUnlockRoutine;    +0x028    ULONG           EnvironmentUpdateCount;    +0x02C    ULONG           KernelCallbackTable;    +0x030    LARGE_INTEGER   SystemReserved;    +0x038    struct _PEB_FREE_BLOCK  *FreeList    +0x03C    ULONG           TlsExpansionCounter;    +0x040    ULONG           TlsBitmap;    +0x044    LARGE_INTEGER   TlsBitmapBits;    +0x04C    ULONG           ReadOnlySharedMemoryBase;    +0x050    ULONG           ReadOnlySharedMemoryHeap;    +0x054    ULONG           ReadOnlyStaticServerData;    +0x058    ULONG           AnsiCodePageData;    +0x05C    ULONG           OemCodePageData;    +0x060    ULONG           UnicodeCaseTableData;    +0x064    ULONG           NumberOfProcessors;    +0x068    LARGE_INTEGER   NtGlobalFlag;               ER   CriticalSectionTimeout;    +0x078    ULONG           HeapSegmentReserve;    +0x07C    ULONG           HeapSegmentCommit;    +0x080    ULONG           HeapDeCommitTotalFreeThreshold;    +0x084    ULONG           HeapDeCommitFreeBlockThreshold;    +0x088    ULONG           NumberOfHeaps;    +0x08C    ULONG           MaximumNumberOfHeaps;    +0x090    ULONG           ProcessHeaps;    +0x094    ULONG           GdiSharedHandleTable;    +0x098    ULONG           ProcessStarterHelper;    +0x09C    ULONG           GdiDCAttributeList;    +0x0A0    KSPIN_LOCK      LoaderLock;    +0x0A4    ULONG           OSMajorVersion;    +0x0A8    ULONG           OSMinorVersion;    +0x0AC    USHORT          OSBuildNumber;    +0x0AE    USHORT          OSCSDVersion;    +0x0B0    ULONG           OSPlatformId;    +0x0B4    ULONG           ImageSubsystem;    +0x0B8    ULONG           ImageSubsystemMajorVersion;    +0x0BC    ULONG           ImageSubsystemMinorVersion;    +0x0C0    ULONG           ImageProcessAffinityMask;    +0x0C4    ULONG           GdiHandleBuffer[0x22];    +0x14C    ULONG           PostProcessInitRoutine;    +0x150    ULONG           TlsExpansionBitmap;    +0x154    UCHAR           TlsExpansionBitmapBits[0x80];    +0x1D4    ULONG           SessionId;\t+0x1d8 AppCompatFlags   : _ULARGE_INTEGER\t+0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER\t+0x1e8 pShimData        : Ptr32 Void\t+0x1ec AppCompatInfo    : Ptr32 Void\t+0x1f0 CSDVersion       : _UNICODE_STRING\t+0x1f8 ActivationContextData : Ptr32 Void\t+0x1fc ProcessAssemblyStorageMap :Ptr32 Void\t+0x200 SystemDefaultActivationContextData : Ptr32 Void\t+0x204 SystemAssemblyStorageMap : Ptr32 Void\t+0x208 MinimumStackCommit : Uint4B&#125; PEB, *PPEB;\r\n通过PEB+0x0C即可获得PEB_LDR_DATA结构，在PEB中较为重要的的几个成员为\r\n+0x02 BeingDebugged    : UChar+0x08 ImageBaseAddress : Ptr32 Void+0x0C Ldr              : Ptr32 _PEB_LDR_DATA+0x18 ProcessHeap      : Ptr32 Void+0x68 NtGlobalFlag     : Uint4B\r\nPEB_LDR_DATA结构\r\nwin11环境下 typedef struct _PEB_LDR_DATA &#123; +0x00 BYTE Reserved1[8]; +0x08 PVOID Reserved2[3]; +0x14 LIST_ENTRY InMemoryOrderModuleList;&#125; PEB_LDR_DATA, *PPEB_LDR_DATA; windows xp sp3下 typedef struct _PEB_LDR_DATA32&#123;  +0x00 ULONG Length;  +0x04 BOOLEAN Initialized;  +0x08 PVOID SsHandle;  +0x0C LIST_ENTRY InLoadOrderModuleList;  +0x14 LIST_ENTRY InMemoryOrderModuleList;  +0x1C LIST_ENTRY InInitializationOrderModuleList;&#125; PEB_LDR_DATA32, * PPEB_LDR_DATA32;\r\n可以看到在win11下InInitializationOrderModuleList已被弃用，但为了保证兼容性，实际还是可以通过PEB_LDR_DATA+0x1C的方法访问InInitializationOrderModuleList\r\n其中LIST_ENTRY是一个双向循环链表，Flink指向下一个条目，Blink指向上一个条目，指向的内容为LDR_DATA_TABLE_ENTRY结构体中相应的位置，之后详细解释\r\ntypedef struct _LIST_ENTRY &#123;  +0x00 struct _LIST_ENTRY *Flink;  +0x04 struct _LIST_ENTRY *Blink; &#125; LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;\r\nLDR_DATA_TABLE_ENTRY结构\r\nwin11环境下 typedef struct _LDR_DATA_TABLE_ENTRY &#123; +0x00 PVOID Reserved1[2]; +0x08 LIST_ENTRY InMemoryOrderLinks; +0x10 PVOID Reserved2[2]; +0x18 PVOID DllBase; +0x1C PVOID Reserved3[2]; +0x24 UNICODE_STRING FullDllName; +0x2C BYTE Reserved4[8]; +0x34 PVOID Reserved5[3];#pragma warning(push)#pragma warning(disable: 4201) // we&#x27;ll always use the Microsoft compiler +0x40 union &#123;        ULONG CheckSum;        PVOID Reserved6;    &#125; DUMMYUNIONNAME;#pragma warning(pop) +0x48 ULONG TimeDateStamp;&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;\r\nwindows xp sp3下 typedef struct _LDR_DATA_TABLE_ENTRY&#123; +0x00 LIST_ENTRY InLoadOrderLinks;                +0x08 LIST_ENTRY InMemoryOrderLinks;              +0x10 LIST_ENTRY InInitializationOrderLinks;      +0x18 PVOID DllBase;                              +0x1C PVOID EntryPoint;                           +0x20 ULONG SizeOfImage;                          +0x24 UNICODE_STRING FullDllName;                 +0x2C UNICODE_STRING BaseDllName;                &#125;LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 以windows xp\r\nsp3为例PEB_LDR_DATA32中的InLoadOrderModuleList-&gt;Flink指向的内容位置就是LDR_DATA_TABLE_ENTRY中InLoadOrderLinks的位置，InMemoryOrderLinks和InInitializationOrderLinks同理\r\n在win11环境下 使用InLoadOrderLinks查找，模块的顺序为当前进程(xxx.exe)\r\n-&gt;ntdll.dll -&gt; kernel32.dll\r\n使用InMemoryOrderLinks查找，模块的顺序为当前进程(xxx.exe) -&gt;\r\nntdll.dll -&gt; kernel32.dll\r\n使用InInitializationOrderLinks查找，模块的顺序为当前进程ntdll.dll -&gt;\r\nkernelbase.dll -&gt; kernel32.dll\r\n通过代码可以验证 DWORD pebAddr = 0;__asm &#123;    mov eax, fs: [0x30]    mov pebAddr, eax&#125;PEB* peb = (PEB*)pebAddr;PEB_LDR_DATA* ldr = peb-&gt;Ldr;// 获得InLoadOrderLinks的头节点LIST_ENTRY* InLoadOrderHeader = (LIST_ENTRY*)&amp;ldr-&gt;Reserved2[1];// 获得InMemoryOrderLinks的头节点LIST_ENTRY* InMemoryOrderHeader= &amp;ldr-&gt;InMemoryOrderModuleList;    // 获得InInitializationOrderLinks的头节点LIST_ENTRY* InInitializationOrderHeader = (LIST_ENTRY*)((DWORD)ldr + 0x1C);     cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;find by InLoadOrderLinks:&quot; &lt;&lt; endl;cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;for (LIST_ENTRY* first = InLoadOrderHeader-&gt;Flink; first != InLoadOrderHeader; first = first-&gt;Flink) &#123;    UNICODE_STRING* name = (UNICODE_STRING*)((DWORD)first + 0x24);    printf(&quot;%S \\n&quot;, name-&gt;Buffer);&#125;cout &lt;&lt; endl &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;find by InMemoryOrderLinks:&quot; &lt;&lt; endl;cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;for (LIST_ENTRY* first = InMemoryOrderHeader-&gt;Flink; first != InMemoryOrderHeader; first = first-&gt;Flink) &#123;    UNICODE_STRING* name2 = (UNICODE_STRING*)((DWORD)first + 0x1C);    printf(&quot;%S \\n&quot;, name2-&gt;Buffer);&#125;cout &lt;&lt; endl &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;find by InInitializationOrderLinks:&quot; &lt;&lt; endl;cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;for (LIST_ENTRY* first = InInitializationOrderHeader-&gt;Flink; first != InInitializationOrderHeader; first = first-&gt;Flink) &#123;    UNICODE_STRING* name3 = (UNICODE_STRING*)((DWORD)first + 0x14);    printf(&quot;%S \\n&quot;, name3-&gt;Buffer);&#125;cout &lt;&lt; &quot;-----------------------------------&quot; &lt;&lt; endl;system(&quot;pause&quot;);\r\n输出的结果为 -----------------------------------find by InLoadOrderLinks:-----------------------------------D:\\test.exeC:\\WINDOWS\\SYSTEM32\\ntdll.dllC:\\WINDOWS\\System32\\KERNEL32.DLLC:\\WINDOWS\\System32\\KERNELBASE.dllC:\\WINDOWS\\SYSTEM32\\ucrtbased.dllC:\\WINDOWS\\SYSTEM32\\VCRUNTIME140D.dllC:\\WINDOWS\\SYSTEM32\\MSVCP140D.dll-----------------------------------find by InMemoryOrderLinks:-----------------------------------D:\\test.exeC:\\WINDOWS\\SYSTEM32\\ntdll.dllC:\\WINDOWS\\System32\\KERNEL32.DLLC:\\WINDOWS\\System32\\KERNELBASE.dllC:\\WINDOWS\\SYSTEM32\\ucrtbased.dllC:\\WINDOWS\\SYSTEM32\\VCRUNTIME140D.dllC:\\WINDOWS\\SYSTEM32\\MSVCP140D.dll-----------------------------------find by InInitializationOrderLinks:-----------------------------------C:\\WINDOWS\\SYSTEM32\\ntdll.dllC:\\WINDOWS\\System32\\KERNELBASE.dllC:\\WINDOWS\\System32\\KERNEL32.DLLC:\\WINDOWS\\SYSTEM32\\ucrtbased.dllC:\\WINDOWS\\SYSTEM32\\VCRUNTIME140D.dllC:\\WINDOWS\\SYSTEM32\\MSVCP140D.dll-----------------------------------\r\n可以发现无论是用哪个Links寻找kernel32.dll都需要3次，因为任意选一个即可，这里使用InLoadOrderLinks寻找\r\n__asm &#123;    mov eax, fs: [0x30]                     // get peb    mov eax, dword ptr[eax + 0xC]           // get PEB_LDR_DATA    mov esi, dword ptr[eax + 0xC]           // get InLoadOrderModuleList    mov esi, dword ptr[esi]    lodsd                                   // get kernel32.dll LDR_DATA_TABLE_ENTRY    lea edx, dword ptr[eax + 0x24]          // get kernel32.dll name address    mov nameAddr, edx    mov eax, dword ptr[eax + 0x18]          // get kernel32.dll address    mov kernel32Addr, eax&#125; 输出结果为 name: C:\\WINDOWS\\System32\\KERNEL32.DLLkernel32.dll Address is: 76760000\r\n","categories":["逆向"]},{"title":"源码UE5启动项目","url":"/2025/05/02/2025-05-02-%E6%BA%90%E7%A0%81UE5%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE/","content":"源码UE5启动项目的一些常见问题\r\n之前为了学习UE5的源代码，所以就直接从源码编译了UE5来使用，不过期间也是遇到了一些奇怪的坑，在这里记录一下\r\n环境配置问题\r\nUE5对.NET、MSVC、Windows\r\nSDK的版本是有要求的，并不是越新越好，如果出现了环境配置上的错误，可以先打开Visual\r\nStudio Installer检查一下，推荐的配置如下\r\nWindows SDK版本：\r\n\r\n\r\n.NET版本（我这里是VS2022默认安装的配置）:\r\n\r\nMSVC版本，使用’MSVC v143 - VS 2022 C++ x64/x86\r\n生成工具(v14.38-17.8)’这个版本：\r\n\r\n启动UE5项目\r\n如果用源码引擎第一次启动项目，即双击*.uproject的方式启动，大概率会遇到这个问题（蓝图项目不太清楚，但C++项目可能会遇到）\r\n\r\n首先看看有没有.sln文件，如果没有的话，右键*.uproject，选择Switch\r\nUnreal Engine version\r\n\r\n\r\n完成后会生成.sln文件，打开后按图中操作即可，注意：\r\n不要Rebuild UE5！\r\n不要清理解决方案！\r\n不要重新生成解决方案！\r\n因为可能会重新构建整个UE5\r\n\r\n如果这个项目是老版本的UE5项目，这一步有可能会报错，比如下面的问题\r\n\r\n解决的办法也提示了，打开XXXEditor.Target.cs，按提示加入这些内容，然后再次Build该项目即可\r\n\r\n之后我们就可以正常启动项目了\r\n\r\n如果现在可以正常启动项目的话，之后双击*.uproject也可以正常启动项目\r\n","categories":["ue5"]},{"title":"PE文件解析（四）","url":"/2024/07/21/2024-07-21-PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"资源表\r\n资源表的结构相对复杂，采用了类似磁盘目录结构的方式保存，通常目录有3层，第1层目录类似于一个文件系统的根目录，指出了整个资源表中有多少种不同的类型（如光标、菜单、快捷键等）；第2层目录指明了当前类型的资源中，有多少个资源；而第3层目录被称为资源代码页\r\n为了便于理解，先给出一张资源表的树形结构图\r\n\r\n\r\n资源目录结构\r\ntypedef struct _IMAGE_RESOURCE_DIRECTORY &#123;    DWORD   Characteristics;        //资源属性，但通常为0    DWORD   TimeDateStamp;          // 资源建立时间    WORD    MajorVersion;           // 资源的版本，但通常为0    WORD    MinorVersion;               WORD    NumberOfNamedEntries;   // 使用名字的资源条目的个数    WORD    NumberOfIdEntries;      // 使用ID的资源条目个数&#125; IMAGE_RESOURCE_DIRECTORY\r\n其中最关键的属性是NumberOfNamedEntries和NumberOfIdEntries，他们指出了本目录种目录项的总和（即资源类型的总个数）\r\n资源目录入口结构\r\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123;    union &#123;        struct &#123;            DWORD NameOffset:31;            DWORD NameIsString:1;        &#125; DUMMYSTRUCTNAME;        DWORD   Name;        WORD    Id;    &#125; DUMMYUNIONNAME;    union &#123;        DWORD   OffsetToData;        struct &#123;            DWORD   OffsetToDirectory:31;            DWORD   DataIsDirectory:1;        &#125; DUMMYSTRUCTNAME2;    &#125; DUMMYUNIONNAME2;&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY\r\n可以看到其中有两个union结构，我们可以简单的理解为，资源目录入口结构包含两个属性Name（ID）、OffsetToData，根据情况的不同，他们有不同的含义\r\n\r\nName（ID）属性：定义了目录项的名称或ID，当最高位（NameIsString）为0时，表示该属性通过ID使用；为1时，表示该属性通过Name使用，且资源名称使用Unicode编码，低31位为Name的Offset，但NameOffset并不直接指向字符串，而是指向一个IMAGE_RESOURCE_DIR_STRING_U结构，该结构如下所示\r\n\r\n当用于第一层目录时，定义的是资源的类型\r\n当用于第二层目录时，定义的是资源的名称\r\n当用于第三层目录时，定义的时代码页的编号\r\n\r\n\r\ntypedef struct _IMAGE_RESOURCE_DIR_STRING_U &#123;    WORD    Length;             // 字符串的长度（不一定以0结尾，所以该属性很重要）    WCHAR   NameString[ 1 ];    // 具体的Unicode字符串&#125; IMAGE_RESOURCE_DIR_STRING_U\r\n\r\nOffsetToData属性：一个指针，当最高位为1时，低31位指向下一层IMAGE_RESOURCE_DIRECTORY的起始地址；当最高位为0时，指向IMAGE_RESOURCE_DATA_ENTRY结构\r\n\r\n当NameOffset和OffsetToData作为Offset使用时，该指针从资源区块的开始处计算偏移，即它们并不是RVA\r\n当IMAGE_RESOURCE_DIRECTORY_ENTRY用在第一层的目录时，其Name（ID）属性用于标记资源类型，而Windows有14种预定义的类型，且用ID标识，ID的数值在1到16之间\r\n\r\n\r\n\r\nID值\r\n资源类型\r\n\r\n\r\n\r\n\r\n01h\r\n光标（Cursor）\r\n\r\n\r\n02h\r\n位图（Bitmap）\r\n\r\n\r\n03h\r\n图标（Icon）\r\n\r\n\r\n04h\r\n菜单（Menu）\r\n\r\n\r\n05h\r\n对话框（Dialog）\r\n\r\n\r\n06h\r\n字符串（String）\r\n\r\n\r\n07h\r\n字体目录（Front Directory）\r\n\r\n\r\n08h\r\n字体（Front）\r\n\r\n\r\n09h\r\n快捷键（Accelerators）\r\n\r\n\r\n0Ah\r\n未格式化资源（Unformatted）\r\n\r\n\r\n0Bh\r\n消息表（Message Table）\r\n\r\n\r\n0Ch\r\n光标组（Group Cursor）\r\n\r\n\r\n0Eh\r\n图标组（Group Icon）\r\n\r\n\r\n10h\r\n版本信息（Version Information）\r\n\r\n\r\n\r\n资源数据入口结构\r\ntypedef struct _IMAGE_RESOURCE_DATA_ENTRY &#123;    DWORD   OffsetToData;       // 资源数据的RVA    DWORD   Size;               // 资源数据的长度    DWORD   CodePage;           // 代码页，一般为0    DWORD   Reserved;           // 保留字段&#125; IMAGE_RESOURCE_DATA_ENTRY\r\n该结构就是真正的资源数据的结构了，其中OffsetToData是RVA，而不是相对于资源块起始位置的Offset\r\n实例\r\n我这里用一个Win32程序为实例，先用PE Tools查看其资源表内容\r\n\r\n根目录\r\n可以看到其中共有7种不同的资源类（24好像是清单类型，暂时每找到相关文档信息），首先在16进制编辑器中观察其根目录\r\n\r\n\r\n4字节Characteristics，此时为0\r\n4字节TimeDateStamp，为0\r\n2字节MajorVersion，为0\r\n2字节MinorVersion，为0\r\n2字节NumberOfNamedEntries，为0\r\n2字节NumberOfIdEntries，为7\r\n\r\n根目录下的IMAGE_RESOURCE_DIRECTORY_ENTRY\r\n我们以Menu作为分析对象，它是第二个IMAGE_RESOURCE_DIRECTORY_ENTRY结构，因为该结构大小位8字节，所以它的位置应该是2400h\r\n+ 8 = 2408h，我们在16进制编辑器中可以看到如下内容\r\n\r\n可以看到其Name（ID）属性值为：0x00000004，其OffsetToData属性值为0x800000E8，我们进一步解析\r\n\r\nName（ID）属性的最高位为0，表示它通过ID标识，由于是第一层目录中，它代表一个预定义的资源，查表我们发现04h是Menu\r\nOffsetToData属性的最高位为1，表示它指向下一层目录，其Offset是E8h，那么下一层目录的地址为2400h\r\n+ E8h = 24E8h\r\n\r\n第二层目录的IMAGE_RESOURCE_DIRECTORY\r\n第二层目录如下所示\r\n\r\n可以知道其NumberOfIdEntries为1，表示Menu资源下只有一个该类资源\r\n紧跟其后的8字节就是IMAGE_RESOURCE_DIRECTORY_ENTRY结构，可以看到其Name（ID）属性值为：0x0000006D，其OffsetToData属性值为0x80003030\r\n\r\nName（ID）属性的最高位为0，表示它通过ID标识，ID为6Dh，即十进制的109\r\nOffsetToData属性的最高位为1，表示它指向下一层目录，其Offset是330h，那么下一层目录的地址为2400h\r\n+ 330h = 2730h\r\n\r\n第三层目录的IMAGE_RESOURCE_DIRECTORY\r\n\r\n可以知道其NumberOfIdEntries为1，表示该资源代码页只有一项\r\n紧跟其后就是IMAGE_RESOURCE_DIRECTORY_ENTRY结构\r\n\r\n可以看到其Name（ID）属性值为：0x00000804，其OffsetToData属性值为0x000004F8\r\n\r\nName（ID）属性的最高位为0，表示它通过ID标识，ID为804h\r\nOffsetToData属性的最高位为0，表示它指向IMAGE_RESOURCE_DATA_ENTRY结构，其Offset是4F8h，那么该结构的地址为2400h\r\n+ 4F8h = 28F8h\r\n\r\nIMAGE_RESOURCE_DATA_ENTRY\r\n\r\n\r\nOffsetToData为01AE90h\r\nSize为50h\r\nCodePage为0\r\n\r\nReserved为0\r\n\r\nIMAGE_RESOURCE_DIR_STRING_U\r\n因为示例程序比较简单，没有用到这个结构，所以这里单独找一个比较复杂的程序用来展示\r\n\r\n可以看到根目录下第一类资源是用Name标识的，其名字为”AFX_DIALOG_LAYOUT”，我们在16进制中观察其IMAGE_RESOURCE_DIRECTORY_ENTRY\r\n\r\n可以看到其Name（ID）属性值为：0x8000CB2E，其OffsetToData属性值为0x800000B0\r\n\r\nName（ID）属性的最高位为1，表示它通过Name标识，且Name的Offset为CB2Eh，那么IMAGE_RESOURCE_DIR_STRING_U结构的地址为630000h\r\n+ CB2Eh = 63CB2Eh\r\nOffsetToData属性的最高位为1，表示它指向下一层目录\r\n\r\n\r\n可以看到IMAGE_RESOURCE_DIR_STRING_U结构中Length为11h，而NameString为Unicode表示的”AFX_DIALOG_LAYOUT”（可以注意到字符串并没有以0结尾，所以Length属性很重要）\r\n","categories":["逆向"]},{"title":"八股","url":"/2025/03/07/2025-03-07-%E5%85%AB%E8%82%A1/","content":"C++\r\n简述C++语言的特点\r\n\r\n以面向对象为主，还支持泛型，函数式编程等多种编程范式\r\nC++既可以直接操作内存，也可以利用零成本抽象的特性和元编程等技巧提高运行效率\r\nC++更安全，鼓励使用RAII机制自动管理资源，减少内存泄漏风险\r\nC++是一个不断发展的语言，每3年增加一些新特性，例如C++11引入了智能指针，右值，移动语义等特性，c++20引入了module、concept、ranges等特性\r\n\r\n\r\n说说C语言和C++的区别\r\n\r\nC是一门面向过程的语言，C++是一门面向对象为主，支持多种编程范式的语言\r\nC++的安全性更高，C语言更倾向手动管理内存，C++更倾向通过RAII（智能指针、容器）自动管理资源生命周期。\r\n一些关键的扩展：C++的函数支持函数重载；利用虚函数实现动态多态；对struct进行了扩展；提供了安全的enum\r\nC++提供了更为强大的STL标准库\r\n\r\n说说 C++中 struct 和 class\r\n的区别\r\n\r\nC++对C中的struct进行了扩展，C中的struct不能有成员函数，无法进行访问控制，不支持继承\r\nC++中的strcut默认public访问权限，class默认private访问权限，包括private、protect和public三种访问权限，在继承关系中，struct默认公有继承，class默认私有继承\r\nC++中的struct常用于定义简单的数据容器或模板，class常用于更复杂的对象封装\r\n\r\n说说include头文件的顺序以及双引号”“和尖括号&lt;&gt;的区别\r\n\r\n尖括号的头文件是系统文件，双引号的头文件是自定义文件\r\n尖括号头文件的查找路径是编译器设置的头文件路径-&gt;系统变量；双引号头文件的查找路径是当前源文件目录-&gt;编译器设置的头文件目录-&gt;系统变量\r\n\r\n导入C函数的关键字是什么，C++编译时和C有什么不同？\r\n\r\nC++通过extern关键字导入C函数，通过extern\r\n“C”引入的C函数会按照C语言的规定进行编译\r\n编译的区别主要在函数上，C++由于支持函数重载，编译时不仅包括函数名，还包括参数类型，命名空间等信息，而C语言编译时通常只包括函数名\r\n\r\n简述C++从代码到可执行二进制文件的过程\r\nC++从源代码到二进制文件经历的过程包括：\r\n\r\n预处理，展开#include头文件，处理#define宏和#ifdef条件宏，过滤注释\r\n编译，进行词法/语法分析，语义分析，生成目标代码并优化\r\n汇编，将目标代码转换为二进制代码\r\n链接，合并多个目标文件及库，生成可执行文件，链接阶段可以分为静态链接和动态链接，静态链接在链接阶段就把要调用的函数链接到可执行文件中，动态链接是在执行过程中寻找要链接的函数\r\n\r\n说说 static关键字的作用\r\n\r\nstatic关键字的作用主要是控制存储期或控制链接性\r\n对于全局变量和函数，链接性控制为内部链接，使其只在当前文件可见，其他文件无法通过extern访问，全局变量的存储期不变，依然是静态存储期，作用域不变\r\n对于局部变量，存储期改变为静态存储期，程序启动完成初始化，程序结束销毁，作用域不变\r\n对于成员变量，该变量属于类本身，而不属于实例化的类对象，存储期为静态存储期，所有类对象都共享该变量，C++17后可以通过inline在类内完成初始化\r\n对于成员函数，类似与静态成员变量，属于类本身，而不属于实例化的类对象，静态成员函数只能使用静态成员变量，调用其他静态成员函数，不可以是虚函数\r\n\r\n说说数组和指针的区别\r\n\r\n数组是一段连续的内存块，存储类型相同的元素，数组类型包含元素类型和长度信息；指针是一个保存地址的变量，仅包含类型信息。在c++类型系统中属于不同的复合类型\r\n数组名是一个可隐式转换为常量指针的标识符，无法进行赋值，而指针变量可以进行赋值，对数组名的引用得到的是数组指针，对指针的引用得到的是指针变量的地址\r\n指针的大小在32为系统下固定为4字节，64位系统下位8字节\r\n数组在传参过程中会发生类型退化，退化为指针变量\r\n\r\n简单说⼀下函数指针\r\n\r\n函数指针是一个指向函数的指针变量\r\n在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。函数指针最常用的地方是做回调函数\r\n\r\n野(wild)指针与悬空(dangling)指针有什么区别？如何避免？\r\n\r\n野指针是未初始化的指针，悬空指针是指向已被释放的内存或失效对象的指针\r\n避免的手段通常包括，初始化或资源释放后及时置nullptr，尽量使用智能指针\r\n\r\n说说内联函数和宏函数的区别\r\n\r\n宏定义的函数并非真正的函数，只是预处理阶段的字符串展开，没有类型检查\r\n内联函数是真正的函数，具有类型检查，是一种编译期的优化，编译器会在内联的位置直接插入代码，避免函数调用带来的开销，内联函数通常是函数体内容简单的函数\r\ninline关键字仅作为内联建议，一个函数是否为内联函数最终由编译器决议，C++17扩展了inline关键字的功能，inline函数允许函数定义出现在多个翻译单元\r\n\r\n说说运算符i++和++i的区别\r\n\r\n++i返回的是一个左值，i++返回的是一个右值，++i效率更高\r\n以int a = i++; int b = ++i;\r\n这个例子中，a是先赋值为i，然后i自增，b是被赋值为i自增后的结果\r\n\r\nnew / delete ，malloc / free\r\n区别\r\n\r\nnew和delete是C++运算符，支持重载，而malloc和free是C库函数，不可重载\r\nnew执行了两个过程，第一步是分配未初始化的内存空间，第二步是调用构造函数进行初始化，失败会抛出异常。delete也有两个过程，首先调用析构函数完成析构，最后调用解分配函数释放内存\r\nmalloc分配的内存大小需要手动计算，返回的指针需要进行强转，失败时返回null\r\n\r\n 说说const和define的区别\r\n\r\nconst用于定义常量，define可以用于定义宏，也可以用于定义常量\r\n当用于定义常量时，const常量是具有类型的，会进行类型检查，遵循C++的作用域规则，在编译期进行处理，const常量可能会分配相应的内存，也可能会被优化为立即数\r\ndefine常量是无类型的，也没有类型检查，在预处理阶段进行处理，不涉及内存分配，只是简单的进行宏展开\r\n\r\n说说const\r\nint a, int const *a, int *const a, int *const a, const int *const\r\na分别是什么，有什么特点\r\n\r\nconst int a定义了一个整型常量\r\nconst int* a定义了一个指针，其指向的内容是一个整型常量\r\nint const* a同const int* a\r\nint *const a定义了一个常量指针，指向一个整型数据\r\nconst int *const a定义了一个常量指针，指向一个整型常量\r\n\r\nC++有几种传值方式，之间的区别是什么？\r\n\r\nC++有值传递，指针传递和引用传递三种方式，对于值传递，形参是实参的副本，所以修改形参不会影响实参。\r\n对于指针传递，传递的是指针的值，形参和实参指向同一内存，在不改变指针的值的情况下，解引用修改数据会影响实参。\r\n对于引用传递， 引用是实参的一个别名，修改引用会影响到实参\r\n\r\n简述一下堆和栈的区别\r\n\r\n在管理方式上，栈由编译器进行分配与释放，内存连续，分配速度快；堆由开发者手动管理分配与释放，分配可能碎片化\r\n在生命周期方面，栈变量随作用域结束自动销毁，堆对象需要手动释放，否则会导致资源泄漏\r\n在结构上，栈严格遵守先进后出，由于内存连续，缓存命中率会更高，堆分配通常地址不连续，易碎片化\r\n\r\n简述C++的内存管理\r\n\r\nC++的内存可以分为栈区，堆区，静态存储区，常量存储区和自由存储区\r\n栈区主要用于存放局部变量和函数参数，由编译器进行管理\r\n静态存储区用于存放静态变量和全局变量，分为初始化和未初始化两个区域\r\n常量存储区用于存放常量\r\n堆区用于存放动态分配的对象，自由存储区是C++中的一个抽象概念，当使用默认的new和delete时，自由存储区和堆区共享同一块内存，但如果重载new运算符，自由存储区可以脱离堆\r\n\r\n内存泄露及解决办法\r\n\r\n内存泄漏是指没有及时回收动态分配的内存，常见的造成内存泄漏的行为有使用new和malloc，没有正确使用delete和free释放资源；存在继承关系时，父类析构函数非虚，导致资源不能及时释放；windows句柄资源使用后没有释放\r\n可以通过使用智能指针，RAII技术来避免出现内存泄漏问题，当出现内存泄漏时，可以使用Dmalloc、Leaky等工具来进行检查\r\n\r\n简述一个程序有哪些section\r\n\r\n通常包括.text段，.rdata段，.data段，.bss段，堆区，共享区，栈区等组成\r\n.text段通常用于存放二进制代码\r\n.rdata段存放只读常量\r\n.data段用于存放用于存放已初始化的全局变量和静态变量\r\n.bss段用于存放未初始化的全局变量和静态变量\r\n栈区用于存放局部变量，函数参数和返回地址，由编译期管理，栈区从高地址向低地址增长\r\n堆区用于存放动态分配的资源，地址从低地址向高地址增长\r\n共享区用于实现文件映射等功能\r\n\r\n简述一下程序启动的过程\r\n\r\n操作系统首先会创建新进程，并分配虚拟地址空间，然后加载器将代码段(.text)，已初始化的数据段(.data)映射到内存，然后.bss段清零，完成内存布局初始化\r\n对于静态链接库，直接嵌入可执行文件；对于动态链接库，加载器读取可执行文件的导入表，确定每一个依赖的动态链接库，将导入函数的实际地址写入IAT表，对于基址与预设不符的，查询重定位表进行重定位，\r\nC\r\nruntime库进行初始化，初始化堆管理器，调用全局对象的构造函数，并注册全局对象的析构函数\r\n进入程序入口main或WinMain，开始执行\r\n\r\n简述一下面向对象，以及面向对象的三大特征\r\n\r\n面向对象是一种以对象为核心的编程范式，将数据和操作数据的方法封装为类，利用实例化的对象解决问题。相较于面向过程式自上而下的编码方式，面向对象可以提高代码的复用性，扩展性和维护性，\r\n面向对象的三大特征是封装、继承和多态\r\n封装是指将数据和操作数据的方法封装到一起，利用访问权限修饰符控制外部访问\r\n继承是指子类继承父类的属性和方法，提高代码复用性，C++中支持private，protected和public三种继承类型，在private继承下，父类的所有成员都变为private，子类无法访问，在protected继承下，父类的public成员变为protected属性，子类可以访问，但外部对象无法访问，在public继承下，父类的成员属性不发生变化\r\n多态是指可以通过父类指针调用子类的方法，子类可以通过重写父类的虚函数进行扩展。面向对象中的多态通常是指运行时的多态，通过虚表实现动态绑定，C++中还存在静态多态，通常是指函数重载和模板\r\n现代oop提倡组合优于继承，更推荐使用继承+组合的形式来提高编码的灵活性，减少耦合\r\n\r\n简述一下 C++\r\n的重载和重写，并说一下它们是怎么实现的\r\n\r\n函数重载是指可以在同一作用域内定义参数列表的不同的同名函数，编译器通过“Name\r\nMangling”技术，利用函数名和参数列表生成唯一符号，在编译期间通过实参信息进行决议，匹配最佳函数，参数的类型，顺序和个数参与决议过程，返回值不参与\r\n重写是指派生类中重新定义了父类中除函数体外完全相同的虚函数，该函数在父类中必须是虚函数，不能是static函数，重写的函数访问修饰符可以与父类不同，可以通过final阻止进一步重写。其核心机制是通过虚函数表和虚表指针实现的，如果类存在虚函数，则编译器会为该类生成一个虚函数表，虚函数表中存放着虚函数的函数指针，在构造时完成虚表指针的初始化，指向该类的虚函数表（虚函数表类共享，而不属于某个对象）。当派生类继承了具有虚函数的基类时，首先会拷贝基类的虚函数表，如果派生类重写了虚函数，就替换为重写后的虚函数地址，如果派生类自身也有虚函数，则追加到虚函数表中\r\n\r\n简述一下C++中所有的构造函数\r\n\r\nC++中常见的构造函数有，默认构造函数，一般构造函数，拷贝构造函数，移动构造函数，委托构造函数，继承构造函数和转换构造函数\r\n默认构造函数也称为无参构造函数，当没有显式定义构造函数时，编译器会自动生成默认构造函数，一般构造函数是有参数的构造函数\r\n拷贝构造函数用于实现同类型的拷贝，默认实现是浅拷贝\r\n移动构造函数接收右值引用，转移资源的所有权\r\n委托构造函数可以让一个构造函数调用其他同类构造函数，减少重复代码，集中初始化逻辑\r\n继承构造函数用于继承基类构造函数，避免重复编写基类构造函数\r\n转换构造函数是单参数构造函数（或含默认值的多参数构造），允许隐式类型转换\r\n根据零/三/五法则，若定义了析构函数，拷贝构造，拷贝赋值，移动构造，移动赋值之一，通常需要定义全部\r\n\r\n说说一个类，默认会生成哪些函数\r\n\r\n默认会生成默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符\r\n当用户定义了析构函数时，会抑制移动构造函数，移动赋值运算符的生成\r\n\r\n说说 C++\r\n类对象的初始化顺序，有多重继承情况下的顺序\r\n\r\n在创建派生类对象时，有限调用基类构造函数，如果类中有其他成员类，再调用成员类的构造函数\r\n对于多继承的情况，按多继承的顺序调用基类构造函数，不受初始化列表顺序影响。对于成员类，按成员类的定义顺序调用构造函数，不受初始化列表顺序影响\r\n调用派生类的构造函数\r\n\r\n说说C++的四种强制类型转换\r\n\r\nC++的强制类型转换有static_cast，dynamic_cast，const_cast，reinterpret_cast四种\r\nstatic_cast是带有类型安全检查的类型转换，在多态环境下仅保证向上转换是安全的，向下转换是未定义行为，常用于基本类型之间的转换，类类型的转换需要提供有效的构造函数或转换运算符，用于转换无关联的类型（如int*转double*）时，在编译期报错，建议将大部分隐式类型转换替换为static_cast\r\ndynamic_cast专用多态环境下的类型转换，保证在down\r\ncast转换过程中是安全的，转换无虚表对象时会在编译期报错，对于转换失败的，结果将返回空指针，由于需要RTTI，因此存在一定的开销\r\nconst_cast专用于const属性的转换，可以用于增加或去除const属性\r\nreinterpret_cast会从内存布局上对数据重新进行解释，无限制，但可移植性差，危险度高\r\n\r\n说说为什么要虚析构，为什么不能虚构造\r\n\r\n虚析构是为了保证派生类可以正确释放自身资源，如果析构函数非虚，在使用基类指针管理派生类对象进行析构时，只会调用基类的析构函数，导致派生类资源无法正确释放，导致资源泄漏\r\n构造函数的调用先于虚函数表的建立，故虚构造是错误的\r\n\r\n简述一下什么是常函数，有什么作用\r\n\r\n常函数是指参数列表后带const的成员函数，其特点是常函数只能调用其他常函数，且不能修改成员变量（用mutable修饰的除外）\r\n\r\n说说什么是虚继承，解决什么问题，如何实现？\r\n\r\n虚继承是一种用于解决多重继承环境下菱形继承问题的一种机制，虚继承通过在继承基类时使用virtual关键字实现，确保在多重继承时，基类仅被最终派生类实例化一次，避免数据冗余和二义性\r\n在内存布局上，虚基类的实例被放置在最终派生类的末尾，被所有虚继承的类共享，编译器为每一个虚继承的派生类插入虚基类指针（或使用虚基类表，虚基类表保存虚基类相对当前对象的偏移），指向虚基类实例的位置，访问虚基类的成员时统一通过指针间接访问，确保唯一性，但存在一定的开销\r\n虚基类的构造函数由最终派生类直接调用\r\n\r\n简述一下虚函数和纯虚函数，以及实现原理\r\n\r\n虚函数的作用主要是为了实现动态多态，当使用父类指针调用子类成员函数时，通过虚函数表和晚绑定，实现了相同函数不同功能的作用\r\n纯虚函数是成员函数参数列表后又=0的函数，包含纯虚函数的类是一个抽象类，无法被实例化，继承了纯虚函数的派生类必须定义抽象类中的每一个纯虚函数，否则也无法实例化\r\n纯虚函数和虚函数都可以提供默认实现，但调用纯虚函数的默认实现必须显式调用（class::function）\r\n\r\n 请问构造函数中的能不能调用虚方法\r\n\r\n可以在构造函数中调用虚方法，但方法的行为可能与直觉不符，因为在构造函数执行期间，对象的动态类型为当前正在构造的类型\r\n当构造函数中调用的是纯虚函数时，如果纯虚函数没有提供默认实现，将会报错\r\n\r\n请问拷贝构造函数的参数是什么传递方式，为什么\r\n拷贝构造函数的参数必须是引用传递，如果是值传递，那么在传参过程中需要构建临时对象，而构建临时对象又需要调用拷贝构造函数，这就导致了无限递归的现象\r\n简述一下拷贝赋值和移动赋值\r\n\r\n拷贝赋值的参数为左值引用，移动赋值的参数是右值引用\r\n拷贝赋值通常是为了实现深拷贝，避免悬垂指针或引用的问题，移动赋值是资源所有权的转移\r\n\r\n仿函数了解吗？有什么作用\r\n\r\n仿函数也称为函数对象，是一个能像普通函数一样使用的类，通过重载()运算符实现，仿函数的优势在于可以利用成员变量记录上下文信息\r\nlambda函数本质上是一个匿名函数对象，当lambda函数的捕获列表为空时，会生成一个转换函数，使其可以转换为函数指针\r\n\r\nC++\r\n中哪些函数不能被声明为虚函数\r\n\r\nc++中普通函数，构造函数，静态成员函数，友元函数和模板成员函数不能被声明为虚函数\r\n普通函数只能重载，与重写无关，属于静态多态，故不能成为虚函数\r\n构造函数的功能是完成初始化，\r\n虚表指针的初始化就发生在构造函数阶段，如果构造函数是虚函数，那么就需要查虚函数表，此时就产生了逻辑矛盾，故不能为虚函数\r\n静态成员函数为类所有，所有实例化对象共享统一静态成员函数，无this指针，无法通过虚表机制实现多态\r\n友元函数是类外的普通函数，只是可以访问类内的private成员，不支持继承，所以不能为虚函数\r\n模板成员函数，虚表需要在编译期确定，而模板成员在实例化时才会生成代码，故不能为虚函数\r\n\r\n说说new和delete的实现原理，delete是如何知道释放内存的大小的\r\n\r\nnew通过调用operator\r\nnew，分配内存后调用构造函数，delete则是先调用析构函数，后回收内存\r\ndelete是如何知道释放内存的大小的，在分配内存时通常会分配更多一点的内存用于保存元数据，元数据中会记录分配的内存大小，对于new[]和delete[]，元数据中还会记录数组的长度，这样在delete[]就会按逆序依次调用析构函数\r\n\r\n说说什么是对象复用，什么是零拷贝\r\n\r\n对象复用是一种用于避免对象反复构造和销毁的技术，通过将对象保存到对象池中即可实现对象复用，避免资源浪费\r\n零拷贝是指避免CPU将数据从一块内存中拷贝到另一块内存中，C++中的emplace_back就属于零拷贝技术\r\n\r\n说说指针和引用\r\n\r\n指针和引用分属C++类型系统中不同的复合类型，指针是一个保存地址的变量，引用是一个别名，引用可以看作是指针的语法糖\r\n指针可以置空，引用不可以，指针可以改变指向的数据，引用不可以\r\n从编译角度看，在编译时会将指针和引用添加到符号表，符号表中记录了变量名和变量对应的地址。对于指针来说，符号表上记录了指针变量的地址，而对于引用来说，符号表上记录引用对象的地址\r\n\r\n说说类如何实现只静态分配和只动态分配\r\n\r\n重载new和delete运算符为private属性即可实现只静态分配\r\n将构造函数和析构函数设置为protected属性即可实现只动态分配\r\n\r\n说一说函数查找和重载解析的过程\r\n\r\n函数调用可以分为两种形式，一种是非限定调用，即只使用函数名的调用；另一种是限定调用，即作用域运算符（::）和成员访问符(.或-&gt;)\r\n函数的查找的过程也就分为了非限定调用函数的查找和限定调用函数的查找，对于非限定调用函数，会从当前作用域逐层向外查找（局部作用域，外层函数作用域，类作用域，命名空间作用域，全局作用域），并且进行参数依赖查找，即会额外搜索参数类型所属的命名空间或类（基本类型不涉及ADL），优先级关系为当前作用域，ADL扩展的作用域，外层作用域；对于限定函数的查找，只搜索指定作用域，不会触发ADL\r\n重载解析，重载解析的关键在于构建函数调用候选集和匹配决议，首先通过函数查找规则来构建候选集，然后通过优先级规则来匹配具体的函数。优先级顺序为参数精准匹配\r\n&gt; 类型提升 &gt; 标准转换 &gt; 类类型转换\r\n\r\n说说volatile的作用\r\n\r\nvolatile主要有三大特性，分别是易变性，不可优化性和顺序性\r\n易变性是指该值可能被意料之外的因素修改（例如其他线程），要求编译器每次都从内存中读取\r\n不可优化性是指不让编译器直接对变量进行优化（例如常量传播，无用代码消除等）\r\n顺序性是指保证volatile变量之间的顺序性\r\n值得一提的是volatile并不保证原子性\r\n\r\n解释下 C++\r\n中类模板和模板类的区别\r\n类模板是一个模板，是一个生成类的蓝图，本身并不是一个类；而模板类是一个类，是类模板实例化的一个结果\r\n说说auto和decltype\r\n\r\nauto的作用是自动推导变量的类型，根据初始化表达式推断变量的类型，因此atuo变量必须具有初始化表达式，auto推导不会保留const属性和引用属性\r\ndecltype的作用是推导表达式的类型，且保留所有修饰符，decltype的推导是不求值的。如果推导的对象是变量名，那么直接推导变量的类型。对于复杂表达式，根据值类别推导，具体来说，如果表达式的结果是左值，那么推导的结果是T&amp;，如果表达式的结果是右值，那么推导的结果是T\r\n\r\n为什么成员列表初始化速度比函数体内的初始化速度块\r\n因为成员列表初始化直接匹配成员的构造函数，而函数体内的初始化本质是调用构造赋值，故速度更快\r\n构造函数和析构函数应不应该抛出异常\r\n\r\n构造函数可以抛出异常，但需要正确处理，因为构造函数抛出异常时，对象构造不完全，不会调用析构函数\r\n析构函数不应该抛出异常，若析构函数在栈展开（处理异常）过程中抛出异常，C++\r\n会调用 std::terminate，直接终止程序\r\n\r\nSTL\r\n请说说 STL 的基本组成部分\r\n\r\nSTL由6部分组成，分别是容器，迭代器，算法，仿函数，适配器，分配器\r\n容器是一种管理数据的模板类，包括序列容器，关联容器和无序容器\r\n迭代器提供了访问容器的统一接口，包括输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器，迭代器是连接容器和算法的桥梁\r\n算法是操作数据的模板函数，通过迭代器间接操作容器\r\n仿函数是函数对象，行为上类似于函数调用，通过重载括号实现，lambda函数一种轻量级的函数对象\r\n适配器是一种转换组件接口的工具，包括容器适配器，迭代器适配器和函数适配器\r\n分配器用于管理对象的创建与销毁，内存的分配与释放\r\n\r\n说说 STL 中 map\r\nhashtable deque list 的实现原理\r\n\r\nmap、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表\r\nmap内部实现了一个红黑树，由于红黑树是一个二叉搜索树，故内部数据是有序的\r\nhashtable采用了函数映射的思想，可以实现快速的查找\r\ndeque内部是一个双向队列，元素在内存中连续存放，随机存取任何元素都在常数时间完成\r\nlist内部实现的是一个双向链表，元素在内存不连续存放\r\n\r\n请你来介绍一下 STL 的分配器\r\n\r\n分配器的核心职责有两个部分，一是内存的分配和释放，二是对象的构造和析构\r\n分配器通过allocate和deallocate管理内存，通过construct和destroy完成对象的构造与析构\r\n\r\nSTL\r\n容器用过哪些，查找的时间复杂度是多少，为什么\r\n\r\n常用STL容器有vector，deque，list，set，map，unordered_set，unordered_map等\r\nvector的增删时间复杂度为O(N)，查找的时间复杂度为O(1)\r\ndeque的增删时间复杂度为O(N)，查找的时间复杂度为O(1)\r\nlist的增删时间复杂度为O(1)，查找的时间复杂度为O(N)\r\nmap和set的增删查找时间复杂度均为O(logN)\r\nunordered_map、unordered_set的增删查找时间复杂度，最好时为O(1)，最坏为O(N)\r\n\r\n说说解决哈希冲突的方法\r\n\r\n解决哈希冲突常用的方法有线性探测，开链，再散列，二次探测等方法\r\n线性探测是指发生冲突时向后依次查找，找到表尾部就返回表头，直到找到空位\r\n开链是指每个位置维护一个链表，如果计算后位置相同则放入链表中\r\n再散列是指发生冲突后用另一种哈希算法再计算一个地址，直到没有冲突\r\n\r\n说说迭代器失效问题\r\n\r\n迭代器失效是因为对容器操作后容器内部的存储结构发生了变化导致的\r\n常见的迭代器失效情况有，vector中erase一个元素后，该元素之后的所有迭代器失效，迭代器失效的原因在于，删除元素后，vector为了保证数据的连续性需要把后续的元素依次前移一个位置\r\n\r\n操作系统\r\n说说进程，线程和协程的联系与区别\r\n\r\n进程是资源分配的基本单位，程序运行时可能会创建一个进程，也可能创建多个进程。进程切换的开销较大，需要由用户态切换至内核态，同时需要切换虚拟内存空间，内核栈，硬件上下文等内容，开销较大\r\n线程是资源调度的基本单位，每一个进程都有一个唯一的主线程，主线程和进程是相互依存的关系，当主线程结束时，进程也会结束，线程的切换开销相对较小，需要由用户态切换至内核态，仅保存少量寄存器内容\r\n协程是一个轻量级的线程，线程内部调度的基本单位，由于协程切换不需要进入内核态，故切换开销最小\r\n\r\n说说外中断和内中断是什么\r\n\r\n外中断是由cpu执行指令之外的事件引起的，例如IO中断，代表设备的输入输出任务已完成，需要处理器发送下一阶段的任务\r\n内中断也称为异常，是由cpu执行指令引起的，例如除0异常，地址越界等，\r\n可以分为 陷阱（Trap），故障（Fault）和终止（Abort）三类\r\n\r\n说说进程调度算法\r\n\r\n常见的进程调度算法包括，先来先服务，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列等算法\r\n先来先服务时一种非抢占式的调度算法，有利于长作业，不利于短作业。而短作业优先任务则刚好相反，缺点是可能会出出现长作业饿死的情况\r\n最短剩余时间优先是一种抢占式调度算法，当有新的作业到达时，会与当前作业的剩余时间进行对比，由此决定哪一个线程被挂起\r\n时间片轮转是将所有进程按序存入队列中，然后将CPU时间分配给队首的进程，当时间片结束时发起时钟中断，当前进程送往队尾\r\n优先级调度是根据进程优先级进行调度的算法，而多级反馈队列综合了前面的多种调度算法\r\n\r\n说说Linux下的进程通信方式\r\n\r\n可以通过消息队列，共享内存，信号，信号量，套接字和管道6种方式通信\r\n消息队列是一个消息链表，存放在内核中，消息队列独立于收发进程\r\n共享内存是指映射一段可供其他进程访问的内存\r\n信号量是一个计数器，用于控制多个进程对资源的访问，常用于同步和互斥访问的情况\r\n信号用于通知进程某个时间的发生\r\n套接字常用于不同主机之间的进程通信\r\n管道可以分为无名管道和有名管道，是一种半双工的通信方式，数据单向流通，其中无名管道只能用于具有亲缘关系的进程通信（父子进程或者兄弟进程），而有名管道可以用于无关进程之间的通信\r\n\r\n说说动态分区算法\r\n\r\n常见的动态分区算法由首次适配算法，最佳适配算法，最坏适配算法和邻近适配算法\r\n首次适配算法是指每次都从低地址开始查找，直到找到第一个满足大小的分区，虽然可能会导致低地址部分出现较多的外部碎片，高地址部分空闲块长时间不被使用，但通常情况下表现都是最优的\r\n最佳适配算法是指维护一个由小到大的空闲分区链表，然后每次都从最小的分区开始搜索，直到找到第一个可用的空闲分区，有点是理论上利用效率更高，但存在维护链表和搜索链表的开销，且会产生大量细小的外部碎片\r\n最坏适配算法是指每次都使用最大的空闲分区，优点是可以减少细小外部碎片的产生，缺点是大的空闲分区被快速分割，后续如果有打的内存需求难以满足，同样需要维护链表\r\n临近适配算法是指，每次都从上一次查找结束的位置开始搜索满足大小的分区，优点是避免出现首次适配算法中外部碎片集中在低地址部分的问题，但是会导致空闲分区更加分散\r\n\r\n说说虚拟技术\r\n\r\n常见的虚拟技术有时分复用和空分复用两种\r\n时分复用的应用例如并发，空分复用的应用例如虚拟内存\r\n\r\n说说虚拟内存的作用\r\n\r\n扩展内存空间，通过分页和交换技术，提供远大于物理内存的连续的虚拟地址空间\r\n实现不同进程间的内存隔离与保护，每个进程都有自己独立的虚拟内存空间，有效防止其他进程的非法访问\r\n简化内存管理，以进程的视角，所有地址空间均是连续的，屏蔽了物理内存存在碎片，\r\n地址不连续的问题\r\n实现内存共享，不同的进程的虚拟页可以映射到同一物理页，例如不同进程共享同一个动态链接库。\r\n\r\n说一说常见的几种锁\r\n\r\n包括读写锁，互斥锁，条件变量和自旋锁\r\n读写锁是允许同时读，不允许同时写，且写者优先于读者\r\n互斥锁则是一次只能由一个线程持有互斥锁，其他线程只能等待，用于线程互斥\r\n条件变量则是用于线程同步，常与互斥锁配合使用，避免出现竞态条件\r\n自旋锁是指，当程序获取锁失败时，不会直接放弃cpu时间，而是一直循环尝试获得锁，一般用于加锁时间很短的场景\r\n\r\n说一说内存交换\r\n\r\n内存交换是指将内存中暂时不用的进程或数据整体移至磁盘交换区，腾出内存空间供其他进程使用，需要时再换回内存\r\n\r\n说说地址变换中，有快表和没快表的流程\r\n\r\n当没有快表时，首先计算页号和页内偏移，然后检查页号合法性，合法就查询页表，找到对应的块号即可访问物理地址\r\n当存在快表时，检查完页号合法性后会查询块表，如果快表命中则可以从块表中直接获取到块号\r\n\r\n说说malloc申请内存的流程\r\n\r\nmalloc申请内存主要依赖两个系统调用，分别是brk和mmap\r\n当申请的内存少于128KB时，如果申请的内存小于64B时从fast_bins中获取空闲块，fast_bins是一个单链表，每一个空闲块的大小都是64B；如果申请的内存大于64B小于512B时，从small_bins中挑选合适的空闲块，small_bins是多个单链表，每个单链表管理大小相同的空闲块，单链表管理的空闲块大小按一定步长递增；当申请的内存大于512B小于128KB时，从large_bins中获取空闲块；如果没有合适的空闲块，则调用brk，通过抬高.data数据段最高处的指针获取新的虚存\r\n当申请的内存大于128kb时，调用mmap通过搜索空闲的虚拟内存获取可操作的堆内存\r\n\r\n说说守护进程，僵尸进程和孤儿进程\r\n\r\n孤儿进程是指父进程结束，但父进程的一个或多个子进程还在运行，这些子进程此时会成为孤儿进程，被init进程接管\r\n僵尸进程是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程\r\n守护进程是一种运行在后台且生存期较长的特殊进程，它独立于控制台，常用于处理一些系统级别的任务\r\n\r\n说说怎么处理僵尸进程\r\n\r\n一种方式是使用signal通知内核对子进程的结束不关系，由内核回收\r\n另一种方式是在父进程中调用wait或waitpid\r\n\r\n说说常见的磁盘调度算法\r\n\r\n先来先服务算法，按请求顺序调度，公平，但寻道时间可能较长\r\n最短寻道时间优先，优先调度距离当前磁头最近的磁道，可能会导致饥饿\r\n电梯扫描算法，按一个方向进行调度，直到该方向没有磁盘请求，不存在饥饿问题\r\n\r\n说说抖动现象\r\n\r\n抖动现象是指刚换出的页面立刻又要换入内存，刚换入的页面立刻又要换出，造成这一现象的原因通常是分配的物理块少于频繁使用的页面数\r\n\r\n说说死锁产生的必要条件，以及如何解除死锁\r\n\r\n死锁产生的必要条件包括4个，互斥条件，不剥夺条件，请求和保持条件，循环等待条件\r\n常见的方法有死锁的检测与恢复，利用资源分配图检查是否存在死锁，恢复则可通过抢占式恢复，回滚恢复和杀死进程恢复；死锁的预防，该方法通过破坏死锁的四个必要条件完成；死锁的避免，常用的方法有银行家算法\r\n\r\n说说什么是内部碎片，什么是外部碎片\r\n\r\n内部碎片常见于固定分配方式，即分配的内存区域有一部分没有用上\r\n外部碎片常见于动态分配方式，即内存的有些空闲区较小，难以利用上，外部碎片可以通过紧凑技术解决\r\n\r\n说说冯诺依曼结构，以及分别对应现代计算机的哪几个模块\r\n\r\n冯诺依曼结构包括输入设备，输出设备，存储器，控制器，运算器这几部分\r\n输入设备对应键盘，输出设备对应显示器，存储器对应内存，控制器对应南桥北桥，运算器对应cpu\r\n\r\n说说什么是大端小端，如何判断大端小端\r\n\r\n大端存储是指数据高位存在低字节部分，符合人们的阅读习惯，小端存储则相反，数据低位存在低字节部分\r\n可以通过int i =\r\n1;然后用一个char指针取变量i首地址的数据，如果等于0是大端存储，如果是1就是小端存储\r\n\r\n说说进入内核态的方式\r\n\r\n通常有三种方式：a、系统调用。b、异常。c、设备中断。其中，系统调用是主动的，另外两种是被动的。\r\n\r\n计算机网络\r\n说说路由协议\r\n\r\n路由可以分为静态路由和动态路由，静态路由由管理员手动维护，动态路由则根据路由协议维护\r\n路由选择的必要步骤包括：1）向其他路由器传递路由信息。2）接收其他路由器的路由信息。3）根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表。4）根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由信息的形式告知其它路由器\r\n常见的路由协议包括RIP，IGRP，OSPF协议等\r\n\r\n说说DNS查询服务器的基本流程\r\n\r\n当打开浏览器输入一个网址的时候，首先会检查本地host文件，查询是否由这个地址映射关系，当没有找到时，会向本地DNS服务器发送DNS请求，如果在本地DNS服务器的缓存中查询到了结果，则直接返回结果\r\n当本地DNS服务器没有查询到结果时，向DNS根服务器发送请求，根服务器会返回域服务器地址，然后本机向域服务器发起请求，然后域服务器会返回域名解析服务器的地址，最后本机向域名解析服务器发送请求获得最终的IP地址，然后本地host文件缓存这个映射关系\r\n\r\n说说TCP三次握手和四次挥手的过程\r\n\r\n第一次握手：建立连接时，客户端向服务器发送SYN包（seq =\r\nx），请求建立连接，等待确认\r\n第二次握手：服务器端收到客户端的SYN包，回一个ACK包（ack =\r\nx+1），确认收到，然后发送一个SYN包（seq = y）给客户端\r\n第三次握手，客户端收到服务器端发送的SYN和ACK包，回一个ACK包（ack =\r\ny+1），告诉服务器端收到，此时连接建立成功，开始传输数据\r\n第一次挥手，客户端发送FIN包（fin =\r\n1）给服务器端，请求终止连接，此时客户端不再发送数据，但是可以接收数据\r\n第二次挥手，服务器端收到FIN包，回一个ACK包给客户端，但此时还没有断开连接，等待剩余数据传送结束\r\n第三次挥手，服务器端等待数据传送结束后，向客户端发送FIN包，表明可以断开连接\r\n第四次挥手，客户端收到后，回一个ACK包表示收到，进入TIME_WAIT状态，等待2MSL后如果没有数据发来，正式断开连接\r\n\r\n说说TCP和UDP的区别，怎么即利用UDP的优势，又保证可靠传输\r\n\r\nTCP是有连接的，可靠的，TCP协议保证数据按序发送，按序到达，提供超时重传保证可靠性，并且提供流量控制和拥塞控制，TCP连接是一对一的\r\nUDP是无连接的，不可靠的，只是尽力交付，UDP支持一对一，多对多和一对多的通信\r\n如果要让UDP具备可靠性，那么可以为UDP添加超时重传的机制，具体来说，为了让UDP也能超时重传，那么UDP也需要向TCP一样利用3次握手建立连接，同时让UDP报文具备一个序号，这样当UDP超时时，既可以直到对方发送的报文超时，同时还能直到丢失了哪一个报文，这样就能做到超时重传\r\n\r\n说说如果三次握手时候每次握手信息对方没收到会怎么样，分情况介绍\r\n说说什么是\r\nMSL，为什么客户端连接要等待2MSL的时间才能完全关闭\r\n\r\nMSL是指报文最长生命时间，等待2MSL的原因是，客户端发送的最后一个ACK报文可能会丢失，这就导致了服务器可能会收不到对FIN-ACK的确认报文，此时服务器会超时重传FIN-ACK，然后客户端会再发送一个ACK报文。如果客户端不等待2MSL，可能会导致服务器无法正常进入链接关闭状态\r\n\r\n说说什么是 TCP 粘包和拆包\r\n\r\nTCP并不知道上层业务数据的具体含义，而是根据TCP缓冲区的实际情况进行包的划分，假设客户端分别发送两个数据包D1和D2给服务器端，那么就会存在3种情况：1）服务器端分两次读取到了两个独立的数据包，此时没有粘包和拆包。2）服务器端一次收到了两个数据包，此时D1和D2粘合在一起，即出现粘包。3）服务器端分两次收到两个数据包，可能是第一次收到部分D1和，第二次收到D1剩下的部分和完整的D2，也有可能是第一次收到了D1和部分D2，第二次收到了D2的剩余部分，这就是拆包\r\n\r\n说说浏览器从输入 URL\r\n到展现页面的全过程\r\n\r\n首先进行域名解析，域名解析完成之后，客户端发起TCP建立请求，当TCP3次握手结束链接建立成功之后，发起HTTP请求，服务器响应请求后，浏览器得到html代码，然后完成解析，同时请求html代码中的资源（如图片等）\r\n\r\nTCP头部中有哪些信息\r\n\r\n32bit序号，传输方向上字节流的字节编号\r\n32bit确认号：接收方对发送方TCP报文段的响应\r\n4bit首部长：标识首部有多少个字节\r\n6bit标志位：URG，ACK，PSH，RST，SYN，FIN\r\n16bit窗口：表示接收窗口大小\r\n16bit校验和，接收端用CRC检验整个报文段\r\n\r\n谈谈流量控制和拥塞控制\r\n\r\n流量控制用于控制通信双方传送数据的速率，具体而言，通信双方需要维护发送窗口和接收窗口的大小，然后在通信过程中利用TCP中的window\r\nsize字段告知对方自己当前的接受能力，如果接收窗口为0，那么发送方会暂停发送，并通过计时器定期查看接收方是否恢复了接收能力\r\n拥塞控制用于网络全局发送数据的速率，拥塞控制算法包括慢启动，拥塞避免，超时重传和快重传快恢复算法，在慢启动阶段，拥塞窗口未达到阈值，大小呈指数级增长；在拥塞避免阶段，拥塞窗口达到阈值，呈线性增长；超时重传是指发生拥塞时直接将拥塞窗口重置为1，而快恢复快重传则是将拥塞窗口大小减半\r\n发送方的实际发送能力为发送窗口和拥塞窗口中最小的那个确定\r\n\r\nUE5相关\r\nGAS系统是什么\r\n\r\nAbility System component (ASC)\r\nASC是用于管理Actor技能的组件，负责跟踪技能的状态、属性和时间\r\nGameplay Ability (GA)\r\nGA用于实现具体技能的逻辑，例如技能的激活、效果、动画播放等\r\nGameplay Effect (GE)\r\nGE用于管理影响Actor状态的效果，例如buff、debuff等\r\nAbility Set (AS)\r\nAS用于存储角色基础属性，如生命值、魔法值等\r\n\r\n","categories":["c++"]},{"title":"C++学习之final优化","url":"/2025/05/07/2025-05-07-cpp%E5%AD%A6%E4%B9%A0-final%E4%BC%98%E5%8C%96/","content":"我们都知道虚函数在引用语义下表现出多态，但也多了一次寻址开销\r\n\r\n实际性能开销主要源自虚函数抑制了内联优化\r\n\r\n首先我们先看一下以下代码的输出 class A &#123;public:\tvirtual void f() &#123;\t\tcout &lt;&lt; &quot;A::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvirtual void g() &#123;\t\tcout &lt;&lt; &quot;A::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class B : public A &#123;public:\tvoid f() override &#123;\t\tcout &lt;&lt; &quot;B::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;B::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class C : public B &#123;public:\tvoid f() override &#123;\t\tcout &lt;&lt; &quot;C::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;C::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;int main() &#123;\tA* a = new A();\ta-&gt;f();\ta-&gt;g();\tB* b = new B();\t*(std::uint64_t*)a = *(std::uint64_t*)b;\ta-&gt;f();\ta-&gt;g();\tA aa = *a;\taa.f();\taa.g();\ta = new C();\ta-&gt;f();\ta-&gt;g();&#125;\r\n\r\n\r\nA::f()\r\nA::g()\r\nB::f()\r\nB::g()\r\nA::f()\r\nA::g()\r\nC::f()\r\nC::g()\r\n\r\n第一次输出很好理解，就是简单的函数调用，第二次和第四次输出a都指向了子类，所以调用了子类重写的虚函数，第三次输出是值语义，不表现多态\r\n我们再看另外一份代码\r\nclass A &#123;public:\tvirtual void f() &#123;\t\tcout &lt;&lt; &quot;A::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvirtual void g() &#123;\t\tcout &lt;&lt; &quot;A::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class B : public A &#123;public:\tvoid f() override &#123;\t\tcout &lt;&lt; &quot;B::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;B::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class C : public B &#123;public:\tvoid f() override &#123;\t\tcout &lt;&lt; &quot;C::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;C::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;int main() &#123;\tA* a = new B();\tC* c = new C();\ta-&gt;f();\ta-&gt;g();\tc-&gt;f();\tc-&gt;g();\t*(std::uint64_t*)a = *(std::uint64_t*)c;\ta-&gt;f();\ta-&gt;g();\tstatic_cast&lt;B*&gt;(a)-&gt;f();\tstatic_cast&lt;B*&gt;(a)-&gt;g();&#125;\r\n与之前的输出的原理一致\r\n\r\nB::f()\r\nB::g()\r\nC::f()\r\nC::g()\r\nC::f()\r\nC::g()\r\nC::f()\r\nC::g()\r\n\r\n观察汇编代码也可以很清楚的搞清其中的原理，所有的调用都在查询虚表（64位程序所以是+8）\r\n\ta-&gt;f();00007FF7E38F4F17 48 8B 03             mov         rax,qword ptr [rbx]  00007FF7E38F4F1A 48 8B CB             mov         rcx,rbx  00007FF7E38F4F1D FF 10                call        qword ptr [rax]  \ta-&gt;g();00007FF7E38F4F1F 48 8B 03             mov         rax,qword ptr [rbx]  00007FF7E38F4F22 48 8B CB             mov         rcx,rbx  00007FF7E38F4F25 FF 50 08             call        qword ptr [rax+8]  \tc-&gt;f();00007FF7E38F4F28 48 8B 07             mov         rax,qword ptr [rdi]  00007FF7E38F4F2B 48 8B CF             mov         rcx,rdi  00007FF7E38F4F2E FF 10                call        qword ptr [rax]  \tc-&gt;g();00007FF7E38F4F30 48 8B 07             mov         rax,qword ptr [rdi]  00007FF7E38F4F33 48 8B CF             mov         rcx,rdi  00007FF7E38F4F36 FF 50 08             call        qword ptr [rax+8]  \t*(std::uint64_t*)a = *(std::uint64_t*)c;00007FF7E38F4F39 48 8B 07             mov         rax,qword ptr [rdi]  00007FF7E38F4F3C 48 89 03             mov         qword ptr [rbx],rax  \ta-&gt;f();00007FF7E38F4F3F 48 8B CB             mov         rcx,rbx  00007FF7E38F4F42 FF 10                call        qword ptr [rax]  \ta-&gt;g();00007FF7E38F4F44 48 8B 03             mov         rax,qword ptr [rbx]  00007FF7E38F4F47 48 8B CB             mov         rcx,rbx  00007FF7E38F4F4A FF 50 08             call        qword ptr [rax+8]  \tstatic_cast&lt;B*&gt;(a)-&gt;f();00007FF7E38F4F4D 48 8B 03             mov         rax,qword ptr [rbx]  00007FF7E38F4F50 48 8B CB             mov         rcx,rbx  00007FF7E38F4F53 FF 10                call        qword ptr [rax]  \tstatic_cast&lt;B*&gt;(a)-&gt;g();00007FF7E38F4F55 48 8B 03             mov         rax,qword ptr [rbx]  00007FF7E38F4F58 48 8B CB             mov         rcx,rbx  00007FF7E38F4F5B FF 50 08             call        qword ptr [rax+8]   \r\n现在我们稍微修改一下代码，对B的f函数加上Final，并对C的继承加上Final\r\nclass A &#123;public:\tvirtual void f() &#123;\t\tcout &lt;&lt; &quot;A::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvirtual void g() &#123;\t\tcout &lt;&lt; &quot;A::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class B : public A &#123;public:\tvoid f() override final &#123;\t\tcout &lt;&lt; &quot;B::f()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;B::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;class C final : public B &#123;public:\t// error\t//void f() override &#123;\t//\tcout &lt;&lt; &quot;C::f()&quot; &lt;&lt; &quot;\\n&quot;;\t//&#125;\tvoid g() override &#123;\t\tcout &lt;&lt; &quot;C::g()&quot; &lt;&lt; &quot;\\n&quot;;\t&#125;&#125;;int main() &#123;\tA* a = new B();\tC* c = new C();\ta-&gt;f();\ta-&gt;g();\tc-&gt;f();\tc-&gt;g();\t*(std::uint64_t*)a = *(std::uint64_t*)c;\ta-&gt;f();\ta-&gt;g();\tstatic_cast&lt;B*&gt;(a)-&gt;f();\tstatic_cast&lt;B*&gt;(a)-&gt;g();&#125;\r\n输出如下，可以观察到输出改变了\r\n\r\nB::f()\r\nB::g()\r\nB::f()\r\nC::g()\r\nB::f()\r\nC::g()\r\nB::f()\r\nC::g()\r\n\r\n现在回到汇编代码就可以很清晰的知道发生了什么\r\n\ta-&gt;f();00007FF619A64F07 48 8B 03             mov         rax,qword ptr [rbx]  00007FF619A64F0A 48 8B CB             mov         rcx,rbx  00007FF619A64F0D FF 10                call        qword ptr [rax]  \ta-&gt;g();00007FF619A64F0F 48 8B 03             mov         rax,qword ptr [rbx]  00007FF619A64F12 48 8B CB             mov         rcx,rbx  00007FF619A64F15 FF 50 08             call        qword ptr [rax+8]  \tc-&gt;f();00007FF619A64F18 48 8B CF             mov         rcx,rdi  00007FF619A64F1B E8 7D C9 FF FF       call        B::f (07FF619A6189Dh)  \tc-&gt;g();00007FF619A64F20 48 8B CF             mov         rcx,rdi  00007FF619A64F23 E8 1A C5 FF FF       call        C::g (07FF619A61442h)  \t*(std::uint64_t*)a = *(std::uint64_t*)c;00007FF619A64F28 48 8B 07             mov         rax,qword ptr [rdi]  00007FF619A64F2B 48 89 03             mov         qword ptr [rbx],rax  \ta-&gt;f();00007FF619A64F2E 48 8B CB             mov         rcx,rbx  00007FF619A64F31 FF 10                call        qword ptr [rax]  \ta-&gt;g();00007FF619A64F33 48 8B 03             mov         rax,qword ptr [rbx]  00007FF619A64F36 48 8B CB             mov         rcx,rbx  00007FF619A64F39 FF 50 08             call        qword ptr [rax+8]  \tstatic_cast&lt;B*&gt;(a)-&gt;f();00007FF619A64F3C 48 8B CB             mov         rcx,rbx  00007FF619A64F3F E8 59 C9 FF FF       call        B::f (07FF619A6189Dh)  \tstatic_cast&lt;B*&gt;(a)-&gt;g();00007FF619A64F44 48 8B 03             mov         rax,qword ptr [rbx]  00007FF619A64F47 48 8B CB             mov         rcx,rbx  00007FF619A64F4A FF 50 08             call        qword ptr [rax+8]\r\n对于第一次输出，父类指针a指向了子类B，所以调用采用查询虚表的形式，与之前一致\r\n对于第二次输出，由于C在继承时添加了Final，这表明了不会有别的类进一步继承C，因此C调用函数的过程在编译期可确定，不再查询虚表\r\n对于第三次输出，父类指针a指向了c，此时保持查询虚表的形式\r\n对于第四次输出，我们把指针a转换位B*类型，由于B中的f函数添加了final，可以确定继承B的子类不会进一步重写f函数，因此B调用函数f的过程也是编译期可以确定的，不再查询虚表\r\n通过上面的例子不难总结，当使用了final时：\r\n\r\n对于指针指向子类对象时，调用虚函数依然需要查询虚表（编译期无法确定）\r\n对于指针指向自身类型时，调用虚函数可以根据final进行优化，一旦时编译期可以确定的行为，那么讲不再查询虚表\r\n\r\n这样的优化叫做去虚拟化\r\n","categories":["cpp"]},{"title":"UE5之横版2D游戏(一)","url":"/2025/05/29/2025-05-29-UE5%E4%B9%8B%E6%A8%AA%E7%89%882D%E6%B8%B8%E6%88%8F(%E4%B8%80)/","content":"也算是一边看文档和各种教程，一边用蓝图做了一个简单的demo出来，不过还是感觉很多东西的云里雾里的，正好打算把部分蓝图内容转换为C++实现，所以趁这个机会记录一下\r\nPaperCharacter\r\n地图的制作感觉可以先放一放，因为整个流程还是比较简单的，主要就是素材的导入，给必要的Tile添加碰撞，然后自由组合即可，等后续需要和角色产生交互再统一记录吧，所以这里就先记录一下角色制作的一些关键流程\r\nEnhanced Input\r\n以前处理输入主要依赖于轴映射输入，但现在UE5更推荐使用增强输入来处理，个人的理解是增强输入可以解耦输入操作的逻辑，以组合的形式提高灵活性和复用性。不过我自己也没有详细了解过增强输入系统，所以就不展开介绍原理了，只简单记录一下如何使用\r\n横板2D游戏的移动比较简单，最基础的就是左右移动和跳跃，所以就先从这两个最基础的Action开始，首先从InputMappingContext和InputAction创建IMC_Default、IA_Move和IA_Jump\r\n\r\n\r\n然后在IMC_Default中完成配置 \r\n接下来创建一个C++类用于表示游戏中的角色，这里暂时使用默认的Character，因为2D角色主要就是把骨骼组件改为成了Sprite，动画组件变为FlipBook，其余地方没有太多区别，而正式创建2D角色会用到PaperZD这个插件，所以就先用默认的Character展示\r\n\r\n我们需要实现Move和Jump的逻辑，然后把相应的资源和逻辑载入到输入增强系统中，所以我们首先在头文件CharacterBase.h中声明相关变量和函数\r\n#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Character.h&quot;#include &quot;CharacterBase.generated.h&quot;class UInputMappingContext;class UInputAction;struct FInputActionValue;UCLASS()class TEST_API ACharacterBase : public ACharacter&#123;\tGENERATED_BODY()\t\t// 添加输入映射上下文\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;)) \tUInputMappingContext* InputMappingContext;\t// 添加Move动作\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUInputAction* MoveAction;\t// 添加Jump动作\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUInputAction* JumpAction;public:\t// Sets default values for this character&#x27;s properties\tACharacterBase();protected:\t// Called when the game starts or when spawned\tvirtual void BeginPlay() override;public:\t\t// Called every frame\tvirtual void Tick(float DeltaTime) override;\t// Called to bind functionality to input\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\tvoid Move(const FInputActionValue&amp; Value);&#125;;\r\n然后在CharacterBase.cpp中完成相关逻辑（这里已经在构造函数中调整了胶囊组件和骨骼组件的部分配置，也可以延迟到在蓝图子类中设置），简单来说\r\n\r\n对于Move函数，由于是2D游戏，我们只需要控制角色在水平方向移动即可，假设我们的角色在X轴上移动，那么我们就可以不用关心Y轴和Z轴\r\n对于Jump函数，由于没有什么特殊需求，所以直接使用了默认的实现\r\n最后，我们需要把Action和相应逻辑绑定，并加入到增强输入系统中\r\n\r\n下面是具体的代码 // Fill out your copyright notice in the Description page of Project Settings.#include &quot;CharacterBase.h&quot;#include &quot;EnhancedInputComponent.h&quot;#include &quot;EnhancedInputSubsystems.h&quot;#include &quot;InputActionValue.h&quot;// Sets default valuesACharacterBase::ACharacterBase()&#123; \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.\tPrimaryActorTick.bCanEverTick = true;\t// 初始化胶囊组件\tGetCapsuleComponent()-&gt;InitCapsuleSize(42.f, 96.0f);\t// 设置骨骼网格组件并加载Asset\tGetMesh()-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, -90.0f));\tGetMesh()-&gt;SetRelativeRotation(FRotator(0.0f, -90.0f, 0.0f));\tGetMesh()-&gt;SetSkeletalMeshAsset(LoadObject&lt;USkeletalMesh&gt;(nullptr, TEXT(&quot;/Script/Engine.SkeletalMesh&#x27;/Game/Characters/Mannequin_UE4/Meshes/SK_Mannequin.SK_Mannequin&#x27;&quot;)));&#125;// Called when the game starts or when spawnedvoid ACharacterBase::BeginPlay()&#123;\tSuper::BeginPlay();&#125;// Called every framevoid ACharacterBase::Tick(float DeltaTime)&#123;\tSuper::Tick(DeltaTime);&#125;// Called to bind functionality to inputvoid ACharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)&#123;\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\t// 输入映射上下文\tif (APlayerController* PC = Cast&lt;APlayerController&gt;(Controller)) &#123;\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PC-&gt;GetLocalPlayer())) &#123;\t\t\tSubsystem-&gt;AddMappingContext(InputMappingContext, 0);\t\t&#125;\t&#125;\t// 绑定输入动作\tif (UEnhancedInputComponent* EIComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) &#123;\t\tEIComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;ACharacterBase::Move);\t\tEIComponent-&gt;BindAction(JumpAction, ETriggerEvent::Started, this, &amp;ACharacterBase::Jump);\t\tEIComponent-&gt;BindAction(JumpAction, ETriggerEvent::Completed, this, &amp;ACharacter::StopJumping);\t&#125;&#125;// 移动逻辑void ACharacterBase::Move(const FInputActionValue&amp; Value) &#123;\tFVector ForwardDirection = FVector(1.0f, 0.0f, 0.0f);\tFVector2D MovementValue = Value.Get&lt;FVector2D&gt;();\tAddMovementInput(ForwardDirection, MovementValue.X);&#125;\r\n之后创建一个基于CharacterBase的蓝图类BP_CharacterBase，并添加之前制作好的IMC_Default、IA_Move和IA_Jump，因为我们没有用代码加载它们，所以需要手动设置一下（如果你之前没有用代码调整胶囊组件和骨骼组件的部分配置，那么也可以在这里设置）\r\n\r\n\r\n然后在GameMode中指定BP_CharacterBase为默认的Pawn\r\n// AtestGameMode.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/GameModeBase.h&quot;#include &quot;testGameMode.generated.h&quot;UCLASS(minimalapi)class AtestGameMode : public AGameModeBase&#123;\tGENERATED_BODY()public:\tAtestGameMode();&#125;;// AtestGameMode.cpp#include &quot;testGameMode.h&quot;#include &quot;testCharacter.h&quot;#include &quot;UObject/ConstructorHelpers.h&quot;AtestGameMode::AtestGameMode()&#123;\t// set default pawn class to our Blueprinted character\tstatic ConstructorHelpers::FClassFinder&lt;APawn&gt; PlayerPawnBPClass(TEXT(&quot;/Game/ThirdPerson/Blueprints/BP_CharacterBase&quot;));\tif (PlayerPawnBPClass.Class != NULL)\t&#123;\t\tDefaultPawnClass = PlayerPawnBPClass.Class;\t&#125;&#125;\r\n然后完成相关配置\r\n\r\n现在我们运行游戏，并选中角色以便观察位置的变化（此时还没有添加摄像机，所以看不到人物模型），然后按D试试能否移动\r\n\r\n\r\n可以观察到，只有X发生了变化，所以移动的逻辑暂时没有太大的问题，现在我们处理一下摄像机，以便我们可以更好的观察\r\nCamera\r\n首先需要确定的是，我们的游戏是一个类似于冒险岛或空洞骑士的横版本2D游戏，所以摄像机应该从侧视角拍摄我们的角色，那么这里会用到两个关键的组件SpringArm和Camera\r\n简单解释一下SpringArm是什么，大致可以把SpringArm看作成一个扛着摄像机的人，控制摄像机从什么位置，什么角度进行拍摄。这也能很好的解释为什么后续代码中，我们实现侧视角拍摄旋转的是SpringArm，而不是Camera本身\r\n首先在CharacterBase.h中添加相应的组件\r\n// 添加SpringArm组件UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))USpringArmComponent* SpringArm;// 添加Camera组件UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))UCameraComponent* Camera;\r\n然后在构造函数中完成初始化 // Sets default valuesACharacterBase::ACharacterBase()&#123; \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.\tPrimaryActorTick.bCanEverTick = true;\t// 初始化胶囊组件\tGetCapsuleComponent()-&gt;InitCapsuleSize(42.f, 96.0f);\t// 设置骨骼网格组件并加载Asset\tGetMesh()-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, -90.0f));\tGetMesh()-&gt;SetRelativeRotation(FRotator(0.0f, -90.0f, 0.0f));\tGetMesh()-&gt;SetSkeletalMeshAsset(LoadObject&lt;USkeletalMesh&gt;(nullptr, TEXT(&quot;/Script/Engine.SkeletalMesh&#x27;/Game/Characters/Mannequin_UE4/Meshes/SK_Mannequin.SK_Mannequin&#x27;&quot;)));\t// 创建SpringArm和Camera组件，并加入到RootComponent中\tSpringArm = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(&quot;SpringArm&quot;));\tSpringArm-&gt;SetupAttachment(RootComponent);\tSpringArm-&gt;TargetArmLength = 300.0f;\t// 调整拍摄的角度，侧视角，并添加一定的俯视角\tSpringArm-&gt;SetRelativeRotation(FRotator(-45, -90, 0));\t// 创建Camera组件，添加到SpringArm组件之下 \tCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;Camera&quot;));\tCamera-&gt;SetupAttachment(SpringArm, USpringArmComponent::SocketName);\tCamera-&gt;ProjectionMode = ECameraProjectionMode::Orthographic;\tCamera-&gt;OrthoWidth = 720.0f;&#125;\r\n\r\n\r\n现在基础的移动功能就完成了（跳跃其实也是正常的，不过视角问题，而且没有添加动画，所以不太明显）\r\n\r\n最终实现\r\n由于使用的是第三人称模板，所以出于方便都是用的3D角色做的实验，现在正式使用PaperZD来实现2D角色(第三方插件)，创建一个继承自PaperZDCharacter的类PaperCharacterBase\r\n\r\n代码方面变动不大，只需要把骨骼相关的内容删除即可，下面给出完整代码\r\n#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;PaperZDCharacter.h&quot;#include &quot;PaperCharacterBase.generated.h&quot;class UInputMappingContext;class UInputAction;class USpringArmComponent;class UCameraComponent;struct FInputActionValue;UCLASS()class TEST_API APaperCharacterBase : public APaperZDCharacter&#123;\tGENERATED_BODY()\t// 添加输入映射上下文\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUInputMappingContext* InputMappingContext;\t// 添加Move动作\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUInputAction* MoveAction;\t// 添加Jump动作\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUInputAction* JumpAction;\t// 添加SpringArm组件\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUSpringArmComponent* SpringArm;\t// 添加Camera组件\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = &quot;true&quot;))\tUCameraComponent* Camera;public:\tAPaperCharacterBase();protected:\tvirtual void BeginPlay() override;public:\tvirtual void Tick(float DeltaTime) override;\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\tvoid Move(const FInputActionValue&amp; Value);&#125;;\r\n#include &quot;PaperCharacterBase.h&quot;#include &quot;EnhancedInputComponent.h&quot;#include &quot;EnhancedInputSubsystems.h&quot;#include &quot;InputActionValue.h&quot;#include &quot;Components/CapsuleComponent.h&quot;#include &quot;Camera/CameraComponent.h&quot;#include &quot;GameFramework/SpringArmComponent.h&quot;#include &quot;PaperFlipbookComponent.h&quot;APaperCharacterBase::APaperCharacterBase()&#123;\tPrimaryActorTick.bCanEverTick = true;\t// 初始化胶囊组件\tGetCapsuleComponent()-&gt;InitCapsuleSize(22.f, 40.0f);\t// 创建SpringArm和Camera组件，并加入到RootComponent中\tSpringArm = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(&quot;SpringArm&quot;));\tSpringArm-&gt;SetupAttachment(RootComponent);\tSpringArm-&gt;TargetArmLength = 300.0f;\tSpringArm-&gt;SetRelativeRotation(FRotator(0, -90, 0));\t// 创建Camera组件，添加到SpringArm组件之下 \tCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;Camera&quot;));\tCamera-&gt;SetupAttachment(SpringArm, USpringArmComponent::SocketName);\tCamera-&gt;ProjectionMode = ECameraProjectionMode::Orthographic;\tCamera-&gt;OrthoWidth = 720.0f;&#125;// Called when the game starts or when spawnedvoid APaperCharacterBase::BeginPlay()&#123;\tSuper::BeginPlay();&#125;// Called every framevoid APaperCharacterBase::Tick(float DeltaTime)&#123;\tSuper::Tick(DeltaTime);&#125;// Called to bind functionality to inputvoid APaperCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)&#123;\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\t// 输入映射上下文\tif (APlayerController* PC = Cast&lt;APlayerController&gt;(Controller)) &#123;\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PC-&gt;GetLocalPlayer())) &#123;\t\t\tSubsystem-&gt;AddMappingContext(InputMappingContext, 0);\t\t&#125;\t&#125;\t// 绑定输入动作\tif (UEnhancedInputComponent* EIComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) &#123;\t\tEIComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;APaperCharacterBase::Move);\t\tEIComponent-&gt;BindAction(JumpAction, ETriggerEvent::Started, this, &amp;APaperCharacterBase::Jump);\t\tEIComponent-&gt;BindAction(JumpAction, ETriggerEvent::Completed, this, &amp;APaperCharacterBase::StopJumping);\t&#125;&#125;// 移动逻辑void APaperCharacterBase::Move(const FInputActionValue&amp; Value) &#123;\tFVector ForwardDirection = FVector(1.0f, 0.0f, 0.0f);\tFVector2D MovementValue = Value.Get&lt;FVector2D&gt;();\tAddMovementInput(ForwardDirection, MovementValue.X);&#125;\r\n同样的，需要创建一个继承自PaperCharacterBase的蓝图类BP_PaperCharacterBase，并在GameMode中把默认Pawn修改过来\r\n\r\n最后看一下效果（这里我只设置了侧视角，没有设置俯视角）\r\n\r\n一些有意思的设定\r\n回到默认的第三人称模板（把GameMode中默认Pawn改回去就行），在调设置的时候发现了几个有意思的设定，分别是角色移动组件里的使用控制器所需的旋转(bUseControllerDesiredRotation)和将旋转朝向运动(bOrientRotationToMovement)、Self里的使用控制器旋转YAW(bUseControllerRotationYaw)\r\n如果以上3个选项都不勾选，那么角色的朝向是永远是初始化到游戏场景中的朝向（如果你可以通过某种方式改变控制器正方向的朝向，那么此时，控制器的朝向和角色的朝向是分离的）\r\n例如最开始移动时，角色朝向和控制器正方向是一致的，按W可以往前走。由于第三人称模板提供了IA_Look，可以用鼠标改变控制器的正方向的朝向，所以当我移动鼠标，角色就开始朝不同的方向移动，即使整个过程都只按了W键\r\n\r\n将控制器和角色朝向关联起来的关键就是这三个设置，其中使用控制器所需的旋转或使用控制器旋转YAW二者的功能是一致的，当勾选之后，角色朝向会和控制器的正方向绑定\r\n\r\n当我移动鼠标时，角色朝向总是与控制器的正方向一致，这就保证了，按下W时总是往角色朝向的方位运动\r\n\r\n那么使用控制器所需的旋转和使用控制器旋转YAW有什么区别呢，在使用控制器所需的旋转的描述中有提到\r\n\r\n如果该选项为true，那么会应用RotationRate以平滑的旋转，会被将旋转朝向运动这一选项覆盖，并且需要取消勾选使用控制器旋转YAW\r\n\r\n我们勾选使用控制器所需的旋转，然后把旋转速率降低\r\n\r\n可以看到旋转的速度是比较缓慢的，尽管我早就已经用鼠标完成了转动的操作\r\n\r\n由于勾选使用控制器旋转YAW会覆盖掉这些设置，且功能一致，所以就不单独测试了，接下来直接看将旋转朝向运动的功能即可\r\n\r\n这个功能并不会将角色的朝向和控制器的正方向绑定(即移动鼠标角色的朝向不会改变)，但它会让角色运动时旋转到运动的方向，可以看到，在我不改变控制器朝向时，分别按下W、D、A，可以观察到角色的朝向改变了（注意这个选项会覆盖掉使用控制器所需的旋转的功能，即控制器的正方向可以改变，但人物朝向不变）\r\n\r\n同样的，如果想使用这个功能，应该取消勾选使用控制器旋转YAW\r\n简单总结一下\r\n\r\n使用控制器所需的旋转和使用控制器旋转YAW是把角色朝向和控制器正方向绑定\r\n\r\n将旋转朝向运动是在运动时改变角色朝向，将其和实际运动的方向绑定\r\n\r\n你可能会好奇，第三人称模板不应该是移动鼠标然后旋转摄像机的视角吗，怎么我这里移动鼠标只能改变控制器在水平方向上的旋转，摄像机总是拍摄角色的背部，这就是最后一个设定，SpringArm中的使用Pawn控制旋转(bUsePawnControlRotation)\r\n我们先把之前的几个设定取消勾选，然后开启使用Pawn控制旋转，注意，虽然这里写的是摄像机设置，但实际是SpringArm中的选项，而不是摄像机中的（摄像机也有相同的选项）\r\n\r\n当然，由于关闭了之前的三个选项，所以控制器的正方向和角色朝向不是一致的\r\n\r\n所以要实现正确的第三人称视角就有两种组合，使用Pawn控制旋转 + 使用控制器所需的旋转和使用Pawn控制旋转 + 将旋转朝向运动，它们的区别就在于朝不同的方向移动时，角色是否会面向这个方向\r\n简单看一下效果，首先是Pawn控制旋转 + 使用控制器所需的旋转组合，可以看到，角色朝向会随着我移动鼠标变化，但当我按A和D时，角色并没有转向运动的方向，但如果我只按W，用鼠标改变控制器正方向时，一切都很正常，因为此时角色的朝向与控制器的正方向绑定，所以OK\r\n\r\n现在我们看看Pawn控制旋转 + 将旋转朝向运动的组合，最大的区别就在于，不产生运动时，角色的朝向并不会改变，但我按A和D时，角色会转向运动的方向，并且最后我只按W，用鼠标改变控制器正方向时，也是正常的，所以这个组合可以看作一个满血的第三人称控制，那么Pawn控制旋转 + 使用控制器所需的旋转组合有什么用途呢，假设我们的游戏提供了一个AutoRun的功能，此时玩家便无需按W、A、S、D控制角色运动，只需要移动鼠标控制方向即可\r\n\r\n","categories":["cpp"]},{"title":"2025-05-13-记一次失败的面试","url":"/2025/05/13/2025-05-13-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%9D%A2%E8%AF%95/","content":"更新: 果然一晚上没睡好，闭上眼睛就是free(p,\r\nlenth)，转眼已经5月中旬了，感觉机会不多时间也不充裕了，人总要为自己的失误买单，还是抓紧时间继续准备吧\r\n最后，深感自己技术不足且基础不扎实，或许大厂之路还很遥远，想要从事游戏开发唯有付出一切努力继续用心沉淀，而不是沉浸在当下的失败中，也不是沉浸短暂的自我感动中。虽然时间不多，但还是用dota2小骷髅的一句语音鼓励一下自己吧，与其感慨路难行，不如马上出发。仅以此贴警示自己，浮于表面和糟糕的习惯总会给你当头一棒\r\n\r\n结束腾讯光子的二面，喜提鹅厂二面挂*2，被自己蠢哭了，记录一下自己的抽象操作\r\nQ: 为什么要做PE解析工具\r\nA:\r\n小导原本在找量化交易平台开发的相关合作，后续可能会有些项目相关的工作，让我去做一些这个方向的准备，但是后面小导生病导致课题没有后续所以暂时无事可做，就打算在游戏demo和这个项目之间二选一，正好大导要组一个CTF团队，就选了这个项目作为给本科生的一个演示\r\n反思:\r\n真想给自己两巴掌，说一堆废话，确实小导住院了，项目没了下文，科研的课题又是新方向只能自己琢磨，但是这些东西和面试有啥关系，直接明了的说做这个项目是因为自己感兴趣，并且刚好可以提升本科生对CTF的兴趣即可，也不知道自己到底在说什么\r\nQ: 做这个项目遇到哪些困难\r\nA: 阿巴阿巴\r\n反思:\r\n描述还是有些混乱，虽然明确了具体遇到什么问题，但是怎么解决的没有讲好，从东扯到西，一下在说具体实现，一下又扯到设计模式，还是要再好好梳理这个项目\r\nQ: 项目中的AddImport.ixx里的xxxx代码做了什么\r\nA: 阿巴阿巴\r\n反思:\r\n蠢哭第一步，首先这段代码做了一个逻辑上很抽象的事，具体来说，已经存在一个被初始化的buffer(new_section)，之后我又new了一块新内存并进行初始化，然后把初始化后的新内存中的内容copy到buffer中，然后释放新内存，自己看了一圈也没想明白自己当时在干嘛，然后跟面试官说不太记得当时在干嘛了(被自己的sb代码绕晕)，所以为什么不直接说这一段代码逻辑是有问题的呢，面试里遇到一时间答不上来问题还是太着急了，正常表达这段代码有问题就行，不用去扯当时在干什么\r\nQ: 项目中TcharToString函数有什么问题，你会怎么修改\r\nA: 内存泄漏\r\n反思:\r\n犯蠢第二步，首先这一圈的代码存在内存泄漏只是一个问题，另外一点，new的使用方式也是错的，char*\r\np = new[sizeof(char) *\r\nlenth]，死去嵌入式的回忆还在攻击我，不过这个先不说，当时也没注意到，毕竟这还不是最蠢的。最蠢的在于，解决这个问题的方法，也就是我释放内存用的是free，虽然后面说了new和delete要成对使用，巴拉了一堆试图掩盖错误(所以我当时到底为什么没用delete)，但是关键是free也写错了，写成了free(p,\r\nlenth)，原地去世\r\n唉，不知道今晚的面试在干嘛，有种张嘴从东吹到西，结果面试官出了个1+1的题没算对的感觉\r\n感觉面试官真尽力了，虽然我的技术栈不匹配，但还是专门看了我的项目代码给我一个机会多聊下，结果自己什么都没接住，关键时刻掉链子就算了，还是这种最低级的错误\r\n用这个帖子记录一下这次失败的面试，对自己很失望，满瓶不动半瓶摇说的就是我吧，满嘴的新特性，实际连最基础的东西都做不好。看着屏幕一个多小时了也不知道要写什么，或许这就是以前糟糕的编码习惯，不经大脑的胡乱用C写C++的恶果，面评烂了也是自己作的\r\n","categories":["essay"]},{"title":"2025-05-23-C++20学习之module","url":"/2025/05/23/2025-05-23-cpp20%E5%AD%A6%E4%B9%A0%E4%B9%8Bmodule/","content":"头文件存在的一些问题\r\n使用头文件主要存在以下一些问题\r\n\r\n头文件被重复处理导致编译速度过慢\r\n宏和全局命名污染的问题\r\n头文件依赖问题\r\n\r\n头文件被重复处理主要是因为它是在预处理阶段直接展开的，也就是直接进行文本替换，考虑在B.h中include了A.h，然后在Utils.cpp和Main.cpp中都include了B.h，那么在这两个翻译单元中都会间接的包含A.h。并且，如果对A.h中的内容做了任何修改，那么其他所有包含A.h的翻译单元都需要重新编译\r\n宏和全局命名污染的问题的原因同上，预处理阶段对头文件进行简单的文本替换导致了这个问题\r\n\r\n头文件依赖问题算是最常踩的一个坑，头文件循环依赖，或者include顺序不对应该大部分人都遇到过，虽然利用include\r\nguards或者规范include顺序可以尽可能的规避这些问题，但毕竟还是会在一些意想不到的时候出错\r\n推荐的头文件include顺序:\r\n\r\n(1)配套的头文件\r\n(2)C语言系统库头文件\r\n(3)C++标准库头文件\r\n(4)第三方库头文件\r\n(5)本项目的其他头文件\r\n\r\nmodule简介\r\ncppreference是这样介绍module的\r\n\r\n模块是一个用于在翻译单元间分享声明和定义的语言特性。\r\n它们可以在某些地方替代标头的使用\r\n\r\n说白了就是用来取代头文件的东西，简单的，记住以下几个概念即可\r\n\r\n(1)含有export的模块是一个接口单元，类似于头文件定义和实现分离，模块也允许有模块实现单元\r\n(2)模块可以分为具名模块（主模块，例如模块X）和模块分区（子模块，例如模块X\r\n: Y）\r\n(3)导入的声明可以在接口单元中再次导出\r\n\r\n语法\r\n具体的语法如下\r\n\r\n(1)export(可选) module 模块名\r\n模块分区 (可选) 属性 (可选) \r\n(2)export 声明\r\n(3)export { 声明序列 (可选) }\r\n(4)export(可选) import 模块名\r\n属性 (可选)\r\n(5)export(可选) import 模块分区\r\n属性 (可选)\r\n(6)export(可选) import 头名\r\n属性 (可选)\r\n(7)module\r\n(8)module : private\r\n\r\n(1) module声明\r\n就是将当前翻译单元声明为一个模块，例如\r\nexport module MainModule; // 声明一个具名模块接口单元module MainModule; // 声明一个具名模块实现单元export MainModule.Module1 // 声明一个具名模块接口单元module MainModule.Module1 // 声明一个具名模块实现单元export module MainModule :Moudle2; // 声明一个模块分区接口单元module MainModule :Moudle2; // 声明一个模块分区实现单元\r\n需要注意的是，X.Y中的.没有内在含义，只是非正式的表达一个层次结构，更推荐的拆分模块的方案是使用模块分区，如下\r\n// 具名模块接口单元 Math.ixxexport module Math;import :Add;import :Sub;// -------------------------------------------------// -------------    模块分区 Add.ixx     ------------// -------------------------------------------------export module Math :Add;export int add(int a, int b);// -------------------------------------------------// -------------    模块分区 Sub.ixx     ------------// -------------------------------------------------export module Math :Sub;export int sub(int a, int b);\r\n需要注意的是\r\n\r\n(1)模块分区仅自己所在的具名模块内部可见，其他的翻译单元不能直接导入这些模块分区\r\n(2)模块分区内的所有声明和定义在将它导入的模块单元中均可见，无论它们是否被导出\r\n(3)模块分区可以是模块接口单元\r\n\r\n简单解释下\r\n(1)是指其他翻译单元无法直接导入模块分区，只有具名模块和具名模块下的其他模块分区可以直接导入\r\n// Main.cppimport Math :Add // error, 不能直接导入模块分区，无论该模块分区是否被导出import Math       // ok\r\n(2)是指模块分区中的所有声明和实现，在该具名模块下所有的模块分区中都是可见的（具名模块内也可见）\r\n// 具名模块接口单元 Math.ixxexport module Math;import :Add;import :Sub;// -------------------------------------------------// -------------    模块分区 Add.ixx     ------------// -------------------------------------------------export module Math :Add;int add(int a, int b);// -------------------------------------------------// -------------    模块分区 Sub.ixx     ------------// -------------------------------------------------export module Math :Sub;import :Add       //ok, Add和Sub都在Math这一具名模块下export int sub(int a, int b);// ok, 即使add是不导出的，但依然可见int calculate()&#123;\tint c = add(1, 2); &#125;\r\n(3)模块分区可以被导出，但需要在具名模块接口单元中导入的同时再导出\r\n// 具名模块接口单元 Math.ixxexport module Math;import :Add;         // 仅内部使用export import :Sub;  // 作为接口单元被导入的同时又被导出\r\n(2, 3) 导出声明\r\n导出一个声明或序列内的所有声明\r\nexport int add(int a, int b);// 导出序列内的所有声明export &#123;\tint sub(int a, int b);\tint mul(int a, int b);&#125;;\r\n(4, 5, 6) 导入声明\r\n导入一个模块单元，模块分区，或标头单元\r\nimport MainModule;  // 导入一个模块import &lt;vector&gt;;    // 导入头文件import :Module1;   // 在具名模块内导入一个模块分区\r\n需要注意的是，在模块单元里不能使用#include，因为所有被包含的声明和定义都会被当作模块的一部分，这不符合模块显式控制接口是否对外暴露的设计理念\r\n(MSVC会提示一个警告)\r\n\r\n#include &lt;vector&gt; in the purview of module Math appears\r\nerroneous. Consider moving that directive before the module declaration,\r\nor replace the textual inclusion with import &lt;vector&gt;;.\r\n\r\nexport module MainModule;#include &lt;vector&gt;     // errorimport &lt;vector&gt;       // ok\r\n不过import &lt;标头单元&gt;并不是一个好的解决方案，可能会遇到一些奇奇怪怪的问题，最佳解决方案我们后续给出\r\n(7) 全局模块片段\r\n模块单元可以使用module前缀来表明后续是一个全局模块片段（准确来说应该是module之后，模块声明之前的内容），并且，一旦使用module，那么它必须是首个声明。它的作用是什么呢，就是为了解决我们之前提到的#include的问题，直接上例子\r\nmodule;                 // 必须是文件内的首个声明                        // begin# define PI 3.14159     //  |# include &lt;windows.h&gt;   // 全局模块片段 # include &lt;vector&gt;      //  |                        // endexport module MainModule; // 具名模块声明\r\n通过该方法就很好的兼容了老文件，避免import &lt;标头单元&gt;出现的一些神奇的问题\r\n(8) 私有模块片段\r\n具名模块接口单元可以在最后申请一个私有模块片段，这样可以在不把所有内容暴露给导入方的情况下将模块表示为一个翻译单元。需要注意的就下面两点\r\n\r\n(1)仅具名模块接口单元可以包含私有模块片段，也就是说具名模块的实现单元不允许包含，模块分区接口单元和实现单元也不允许包含\r\n(2)私有模块片段提供了一种轻量的声明和定义分离的方法，所以我们即可以在具名模块接口单元中导出声明，在私有模块片段中提供定义，也可以像传统方案一样，在接口单元导出声明，在实现单元中提供定义\r\n\r\n// 具名模块接口单元 Math.ixxexport module Math;import :Add;export import :Subexport void calculate();   // 导出声明module : private;// 私有模块片段内void calculate()&#123;\tint result = add(1, 2) + sub(3, 4);\tcout &lt;&lt; result &lt;&lt; &quot;\\n&quot;;&#125;\r\n模块所有权\r\ncppreference中这样描述模块的所有权\r\n\r\n(1)通常来说，在模块单元中的模块声明后出现的声明都附着于该模块\r\n(2)如果一个实体的声明附着于一个具名模块，该实体只能在该模块中定义。每个这种实体的所有声明都必须附着于同一模块\r\n(3)如果一个声明附着于一个具名模块，并且该声明没有被导出，那么声明的名字具有模块链接\r\n(4)如果同一实体的两个声明附着于不同的模块，那么程序非良构；如果两个声明都无法从对方可及，那么不要求诊断\r\n(5)具有外部链接的命名空间定义和在语言链接说明中的声明不附着于任何具名模块（因此声明的这些实体可以在模块外定义）\r\n\r\n(1, 2,\r\n3)比较容易理解，直接用cppreference中的例子说明，函数f没有被导出，所以具有模块连接，并依附于自身所在的模块，所以lib_A和lib_B中的函数f是不同的实体，它们的定义也必须在各自的模块单元中提供\r\n// -------------------------------------------------// -------    具名模块接口单元 lib_A.ixx     ---------// -------------------------------------------------export module lib_A; int f() &#123; return 0; &#125; // f 具有模块链接export int x = f();   // x 等于 0// -------------------------------------------------// -------    具名模块接口单元 lib_B.ixx     ---------// -------------------------------------------------export module lib_B; int f() &#123; return 1; &#125; // OK，lib_A 中的 f 和 lib_B 中的 f 指代不同的实体export int y = f(); // y 等于 1\r\n(4)还是cppreference中的例子\r\n// decls.hint f(); // #1，附着于全局模块int g(); // #2，附着于全局模块\r\n// M 的模块接口module;#include &quot;decls.h&quot;export module M;export using ::f; // OK，不声明实体，导出 #1int g();          // 错误：与 #2 匹配，但附着于 Mexport int h();   // #3export int k();   // #4\r\n// 其他翻译单元import M;static int h();   // 错误：与 #3 匹配int k();          // 错误：与 #4 匹配\r\n简单解释一下，我们首先在decls.h中声明了函数f()和函数g()，它们是依附于全局模块的（预处理阶段直接展开，只要#include \"decls.h\"就可见），所以当我们在具名模块接口单元M中导入了decls.h时，就已经存在了函数f()和函数g()的声明，它们依附于全局模块，而后续的int g();依附于模块M，因此导致了错误\r\n对于export int h();和export int k();，由于使用了export，所以它们并不是模块链接，而是外部链接，当我们import M;之后，后续的函数static int h()和int k()就是可及的（即从当前翻译单元到达模块M中的声明），因此也出现了和上面一样的错误\r\n(5)实际就是 (1)\r\n中的例外，同样是cppreference中的例子，命名空间这个比较容易理解，简单连说就是命名空间是不附着于模块的，这也是为什么cppreference中说\r\n\r\n模块和命名空间是正交的\r\n\r\n函数f()和函数g()也容易理解，即它们是语言链接说明中的声明，而函数h()是依附于模块lib_A的，必须在当前模块中提供定义\r\nexport module lib_A; namespace ns // ns 不附着于 lib_A&#123;    export extern &quot;C++&quot; int f(); // f 不附着于 lib_A           extern &quot;C++&quot; int g(); // g 不附着于 lib_A    export              int h(); // h 附着于 lib_A&#125;// ns::h 必须在 lib_A 中定义，但 ns::f 和 ns::g 可以在其他地方定义// （例如在传统源文件中）\r\n简单的module用例\r\n介绍完module之后就上个简单的例子吧\r\n// -------------------------------------------------// ------    Character.ixx 具名模块接口单元     ------// -------------------------------------------------module;  // 声明全局模块片段，用于导入头文件#include &lt;memory&gt;#include &lt;string&gt;#include &lt;iostream&gt;export module Character;       // 声明具名模块接口单元Characterexport import :CharacterBase;  // 导出模块分区接口单元CharacterBaseexport import :Ranger;         // 导出模块分区接口单元Rangerexport import :Warrior;        // 导出模块分区接口单元Warriorexport std::unique_ptr&lt;CharacterBase&gt; create_character(    const std::string&amp; type,    const std::string&amp; name,    float health = 100,    float base_speed = 20,    float base_attack = 10);module :private;  // 声明私有模块片段std::unique_ptr&lt;CharacterBase&gt; create_character(    const std::string&amp; type,    const std::string&amp; name,    float health,    float base_speed,    float base_attack) &#123;    if (type == &quot;Warrior&quot;) &#123;        return std::make_unique&lt;Warrior&gt;(name, health, base_speed, base_attack);    &#125;    else if (type == &quot;Ranger&quot;) &#123;        return std::make_unique&lt;Ranger&gt;(name, health, base_speed, base_attack);    &#125;    else &#123;        std::cout &lt;&lt; &quot;Error Character Type;&quot;;        return nullptr;    &#125;&#125;\r\n// -------------------------------------------------// ----    CharacterBase.ixx 模块分区接口单元     ----// -------------------------------------------------module;#include &lt;string&gt;#include &lt;iostream&gt;export module Character :CharacterBase;  // 声明模块分区接口单元CharacterBaseexport class CharacterBase &#123;public:\tCharacterBase(std::string name, float health, float base_speed, float base_attack) noexcept\t\t: name_(name), health_(health), base_speed_(base_speed), base_attack_(base_attack) &#123;&#125;\tvirtual ~CharacterBase() noexcept &#123;&#125;\tvirtual void show_attack() noexcept &#123;\t\tstd::cout &lt;&lt; &quot;attack is: &quot; &lt;&lt; base_attack_ &lt;&lt; &quot;\\n&quot;;\t&#125;\tvirtual void show_speed() noexcept &#123;\t\tstd::cout &lt;&lt; &quot;speed is: &quot; &lt;&lt; base_speed_ &lt;&lt; &quot;\\n&quot;;\t&#125;\tvoid show_name() noexcept &#123;\t\tstd::cout &lt;&lt; name_;\t&#125;protected:\tstd::string name_;\tfloat health_;\tfloat base_speed_;\tfloat base_attack_;&#125;;\r\n// -------------------------------------------------// -------    Ranger.ixx 模块分区接口单元     --------// -------------------------------------------------module;#include &lt;string&gt;#include &lt;iostream&gt;export module Character :Ranger; // 声明模块分区接口单元Rangerimport :CharacterBase;           // 导入模块分区接口单元CharacterBaseexport class Ranger : public CharacterBase &#123;public:\tRanger(std::string name, float health, float base_speed, float base_attack) noexcept\t\t: CharacterBase(name, health, base_speed, base_attack)&#123;&#125;\tvirtual ~Ranger() noexcept override &#123;\t&#125;\tvirtual void show_speed() noexcept override &#123;\t\tstd::cout &lt;&lt; &quot;speed is: &quot; &lt;&lt; base_speed_ + speed_buff_ &lt;&lt; &quot;\\n&quot;;\t&#125;private:\tfloat speed_buff_ = 5;&#125;;\r\n// -------------------------------------------------// --------    Warrior.ixx 模块分区接口     ---------// -------------------------------------------------module;#include &lt;string&gt;#include &lt;iostream&gt;export module Character :Warrior; // 声明模块分区接口单元Warriorimport :CharacterBase;            // 导入模块分区接口单元CharacterBaseexport class Warrior : public CharacterBase &#123;public:\tWarrior(std::string name, float health, float base_speed, float base_attack) noexcept\t\t: CharacterBase(name, health, base_speed, base_attack) &#123;&#125;\tvirtual ~Warrior() noexcept override &#123;\t&#125;\tvirtual void show_attack() noexcept override &#123;\t\tstd::cout &lt;&lt; &quot;attack is: &quot; &lt;&lt; base_attack_ + attack_buff_ &lt;&lt; &quot;\\n&quot;;\t&#125;private:\tfloat attack_buff_ = 10;&#125;;\r\n// Main.cppimport Character;int main()&#123;\tauto player1 = create_character(&quot;Warrior&quot;, &quot;jugg&quot;);\tauto player2 = create_character(&quot;Ranger&quot;, &quot;windrunner&quot;);\tplayer1-&gt;show_name();\tcout  &lt;&lt; &quot; info: &quot; &lt;&lt; &quot;\\n&quot;;\tplayer1-&gt;show_attack();\tplayer1-&gt;show_speed();\tcout &lt;&lt; &quot;-------------------------------\\n&quot;;\tplayer2-&gt;show_name();\tcout &lt;&lt; &quot; info: &quot; &lt;&lt; &quot;\\n&quot;;\tplayer2-&gt;show_attack();\tplayer2-&gt;show_speed();&#125;\r\n输出为\r\n\r\njugg info:\r\nattack is: 20\r\nspeed is: 20\r\n——————————-\r\nwindrunner info:\r\nattack is: 10\r\nspeed is: 25\r\n\r\nmodule的一些问题\r\n总体使用感觉还是很不错的，如果是从零开始的新项目，其实完全可以使用module进行开发了，只有一些小问题\r\n\r\nIDE支持有时候会失效，这个有点奇怪，偶尔会出现没有智能提示，或者是跳转到函数定义失败的问题\r\n\r\n和宏混用容易出错\r\n\r\n报错的支持还有待提升，这个应该是最麻烦的问题，有些奇怪的报错几乎是无法阅读的\r\n\r\n","categories":["cpp"]}]