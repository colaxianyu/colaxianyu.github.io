---
title: 专业课知识点汇总
date: 2021-12-01 22:45:47
mathjax: true
categories: 
    - 随笔
---

## 数据结构

### 循环队列
队空条件：Q.rear == Q.front  
队满条件：(Q.rear + 1) % MaxSize == Q.front  
入队：Q.rear = (Q.rear + 1) % MaxSize  
出队：Q.front = (Q.front + 1) % MaxSize  
长度：(Q.rear - Q.front + MaxSize) % MaxSize  

### 栈
$\displaystyle
\begin{aligned}
    出栈序列个数 \frac{1}{n+1} C_{2n} ^{n}
\end{aligned}$

<!--more-->

### 树与二叉树

#### 部分结论
1. 树   
$\displaystyle
\begin{aligned}
       &①.度为m的树，第i层至多有m^{i - 1}个节点\\
       &②.高度为h的m叉树至多有\frac{m^h-1}{m-1}个结点\\
       &③.具有n个结点的m叉树的最小高度为\lceil log_m(n(m-1)+1) \rceil \\
       &④.结点数 = 分支数 + 1
\end{aligned}$

2. 二叉树   
$\displaystyle
\begin{aligned}
       &①.非空二叉树上第i层至多有2^{i-1}个结点\\
       &②.高度为h的二叉树至多有2^h-1个结点\\
       &③.对于完全二叉树，n个结点的完全二叉树高度为\lceil log_2(n+1) \rceil\\
       &④.非空二叉树上的叶子节点数等于度为2的结点数加1，即n_0=n_2+1
\end{aligned}$

#### 红黑树
1. 定义：
   - 红黑树是二叉排序树
   - 根节点是黑色的
   - 叶节点（失败结点、外部节点、NULL结点）是黑色的
   - 不存在两个相邻的红色节点（即红色结点的**父节点**与**子节点**一定是黑色的）
   - 对每个结点，从该节点到任一叶节点的路径上，所含的黑色结点数量相同

2. 性质
   - 从根节点到叶节点的最长路径不大于最短路径的两倍
   - $\displaystyle有n个内部结点的红黑树高度 h \le 2log_2(n+1)$
   - $\displaystyle 查找时间复杂度=log_2n$
   - 若黑高为h，内部节点最少有$\displaystyle 2^h-1个$，最多有$\displaystyle 2^{2h}-1个$

**AVL树的对平衡的要求更高（树的高度更低），因此查找效率通常比红黑树更好，但插入删除的效率更差（频繁调整），AVL和红黑树的查找/插入/删除的最坏时间复杂度都是$\displaystyle log_2n$**

1. 插入操作
   - 确定插入位置
   - 新结点是根，染黑
   - 新节点非根，染红
        - 若插入新节点后依然满足红黑树的定义，则插入结束
        - 若插入新结点后不满足红黑树定义，则进行调整（看叔结点的颜色）
            - 红叔：染色+变新
                - 叔父结点换色，爷结点变为新节点
            - 黑叔：旋转+染色
                - LL型：右单旋，父换爷+换色
                - RR型：左单旋，父换爷+换色
                - LR型：先左后右旋，儿换爷+换色
                - RL型：先右后左旋，儿换爷+换色

#### 并查集
1. 逻辑上：是一种集合
2. 物理上：采用顺序表存储，每个集合构成一颗树，并用双亲表示法表示
3. 基本操作：
   - 并(Union)：将两个不相交的集合合并为一个
   - 查(find)：找到一个指定元素所属的集合

### 图
无向完全图：e = v(v-1)/2  
有向完全图：e = v(v-1)  
无向图中所有顶点的**度数之和**等于**边数的两倍**  
有向图中全部定点的**入度之和**等于**出度之和**等于**边数**  
邻接矩阵表示中：行表示该结点的**出度**，列表示该结点的**入度**  
边少的图称为稀疏图，反之称为稠密图，当$\displaystyle E < Vlog_2V $时，可将图视为稀疏图

### 查找
#### 顺序查找  
$\displaystyle
\begin{aligned}
    &ASL_{成功} = \frac{n+1}{2} \\\\
    &ASL_{失败} = 
    \begin{cases}
        n+1， \quad 一般线性表 \\\\
        \frac{n}{2}+\frac{n}{n+1}, \quad 有序线性表
    \end{cases}
\end{aligned}$

#### 折半查找（只适用于**有序**的**顺序表**）  
$\displaystyle
\begin{aligned}
    &关键字比较次数：失败=成功=\lfloor log_2(n)+1 \rfloor \\
    &ASL_{成功} = \frac{n+1}{n}log_2(n+1)-1 \approx log_2(n+1)-1 \\\\
\end{aligned}$

#### B树（m阶）
   - 根节点关键字个数：$\displaystyle 1 \le n \le m-1$
   - 非根结点关键字个数：$\displaystyle \lceil \frac{m}{2} \rceil - 1 \le n \le m-1$
   - 若根节点不是叶节点，则至少要有2棵子树，至多m颗
   - 除根节点外，所有非叶节点至少有$\displaystyle \lceil \frac{m}{2} \rceil$棵子树，至多m颗

#### B+树（m阶）
   - 根节点关键字个数：$\displaystyle 1 \le n \le m$
   - 非根结点关键字个数：$\displaystyle \lceil \frac{m}{2} \rceil \le n \le m$
   - 若根节点不是叶节点，则至少要有2棵子树，至多m颗
   - 除根节点外，所有非叶节点至少有$\displaystyle \lceil \frac{m}{2} \rceil$棵子树，至多m颗
   - 结点的关键字个数等于该节点子树的个数

#### hash表  
$\displaystyle
\begin{aligned}
    &①hash函数通常采用除留余数法：H(key) = key \% p \\
    &②开放地址法处理冲突， 在产生冲突后，第i次探测的地址为：H_i=(H(key)+d_i) \%  m\\
    &③线性探测法中d_i = 1，2，3，...，m-1 \\
    &④平方探测法（二次探测法）中d_i = 1^2，-1^2，2^2，-2^2，...，k^2，-k^2，但表长m必须是一个可表示成4k+3的质数 \\
    &⑤填装因子\alpha = \frac{记录数n}{hash表长度m}\\
    &⑥填装因子\alpha 越大，冲突的可能性越大\\
    &⑦hash表的查找效率取决于：散列函数、处理冲突的方法/填装因子 
\end{aligned}$

### 排序
1. 每趟排序都能确定一个**元素的最终位置**：冒泡排序、选择排序、堆排序、快速排序（枢轴元素）
2. 每趟排序都能确定一个**局部有序的子序列**：插入排序、shell排序、归并排序
3. 非稳定的排序算法：选择排序、shell排序、快速排序、堆排序
4. 使用辅助空间的排序算法：快速排序、归并排序、基数排序
5. 可运用于链表中的排序算法：插入排序、冒泡排序、选择排序

**排序算法小结**

| 算法种类 |  时间复杂度(平均) | 空间复杂度 | 是否稳定|  
|:-------:|:----------------:|:---------:|:------:|
| 插入排序 | $\displaystyle O(n^2)$ | $\displaystyle O(1)$ | 是 |
| 冒泡排序 | $\displaystyle O(n^2)$ | $\displaystyle O(1)$ | 是 |
| 选择排序 | $\displaystyle O(n^2)$ | $\displaystyle O(1)$ | 否 | 
| 希尔排序 | - | $\displaystyle O(1)$ | 否 |
| 快速排序 | $\displaystyle O(nlog_2n)$ | $\displaystyle O(log_2n)$ | 否 |
| 堆排序   | $\displaystyle O(nlog_2n)$ | $\displaystyle O(1)$ | 否 | 
| 2路归并排序 | $\displaystyle O(nlog_2n)$ | $\displaystyle O(n)$ | 是 |
| 基数排序 | $\displaystyle O(d(n+r))$ | $\displaystyle O(r)$ | 是 |

**外部排序中，对M个归并段进行N路归并排序，需要补充的虚段数为：$\displaystyle (N-1)-(M-1)\% (N-1)$**

---

## 计算机组成原理

### 基础知识
1. 数据线的宽度 = MDR的宽度
2. 地址线的宽度 = MAR的宽度
3. 机器字长：CPU一次能处理的二进制数据位数，通常等于内部寄存器的大小，与计算机运算精度有关（通常为字节的整数倍）
4. 存储字长：一个存储单元存储的二进制代码的长度（等于MDR的的位数）
5. 指令字长：一个指令字包含的二进制代码长度（通常为存储字长的整数倍）

### 数据的表示与运算

#### 定点数
1. 长度为n+1位的定点数，各种编码方式下的数值范围

| 编码方式 | 数值范围 | 0的个数 |
|:---:|:---:|:---:|
| 无符号定点整数 | $\displaystyle 0 \le x \le 2^{n+1}-1$ | - |
| 原码定点整数 | $\displaystyle -2^n+1 \le x \le 2^n-1$| 2 |
| 反码定点整数 | $\displaystyle -2^n+1 \le x \le 2^n-1$| 2 |
| 补码码定点整数 | $\displaystyle -2^n \le x \le 2^n-1$| 1 |
| 移码码定点整数 | $\displaystyle -2^n \le x \le 2^n-1$| 1 |
| 无符号定点小数 | $\displaystyle 0 \le x \le 1-2^{-n}$ | - |
| 原码定点小数 | $\displaystyle -1+2^{-n} \le x \le 1-2^{-n}$ | 2 |
| 反码定点小数 | $\displaystyle -1+2^{-n} \le x \le 1-2^{-n}$ | 2 |
| 补码定点小数 | $\displaystyle -1 \le x \le 1-2^{-n}$ | 1 |

2. 符号位的生成

| 符号位 | 生成方式 |  | 作用 |
|:---:|:---:|:---:|:---:|
| 溢出标志OF | $\displaystyle OF=C_n \bigoplus C_{n-1}$ | $\displaystyle OF=1有符号数运算结果溢出\\OF=0有符号数运算结果未溢出$ |
| 符号标志SF | $\displaystyle SF=F_{n-1}$ |  $\displaystyle SF=1表示运算结果为负\\OF=0表示运算结果为正$ |
| 零标志位ZF | $\displaystyle ZF=(F==0?1:0)$ |  $\displaystyle OF=1表示运算结果为0\\OF=0表示运算结果不为0$ |
| 进位/借位标志CF | $\displaystyle CF=C_{in}(SUB)\bigoplus C_{out}$ |  $\displaystyle CF=1表示无符号数运算结果溢出\\ CF=0表示无符号数运算结果没溢出$ |

- $\displaystyle C_n表示最高位进位$
- $\displaystyle C_{n-1}表示次高位进位$
- $\displaystyle F_{n-1}表示最高位本位和+低位的进位$
- $\displaystyle F表示最终运算的结果$
- $\displaystyle C_{in}(SUB)表示输入信号，1表示进行减法操作，0表示进行加法操作$
- $\displaystyle C_{out}表示最高位进位$

**对于无符号数，只有CF与ZF标志位有意义，其中CF判断结果是否溢出，ZF判断结果是否为0**  
**对于有符号数，OF、SF、ZF有意义，其中OF判断结果是否溢出，SF判断结果正负性，ZF判断结果是否为0**  

3. 定点数的溢出判断
   1. 无符号数
      - 加减法：本质是看进位/借位标志CF是否为1，CF=1则溢出
      - 乘法：两个n位数相乘，结果用2n位**暂存**（实际运算结果只取低n位，即乘数寄存器的值），若乘积寄存器（高n位）全为0，则不溢出，否则，只要有任一1位为0，则溢出
   2. 有符号数
      -  加减法：本质是看溢出标志OF是否为1，OF=1则溢出
      -  乘法：两个n位数相乘，结果用2n位**暂存**（实际运算结果只取低n位，即乘数寄存器的值），若前n+1位全0或全1则不溢出，反之则溢出（**真值是低n位的数值，但溢出判断是前n+1位，即于高n位与真值部分的最高位的符号位相同才不溢出**）

4. 溢出的具体判断方法

| 方法 | 条件 |
|:---:|:---:|
| 单符号位 | 运算结果的符号与参加操作的两个数的符号相同，则不溢出，否则溢出 |
| 双符号位 | 运算结果的两个符号位相同则未溢出<br>运算结果的两个符号位不同则溢出，且最高位的符号位表示真正的符号（01表示上溢，10表示下溢） |
| 单符号位和进位法 | 符号位的进位与最高数位的进位相同，则不溢出，否则溢出（实际就是OF标志位的生成方法，最高位进位与次高位进位做异或运算） |

5. 定点数除法
   - 除法电路，可完成定点整数与定点小数的除法，由于除法操作需要将被除数扩展为2n位，故对于定点整数，小数点隐含在商寄存器之后，故高n位的余数寄存器补0，而对于定点小数，小数点隐含在余数寄存器之前，低n位的商寄存器补0

#### IEEE 754标准 浮点数
1. 浮点数格式

| 类型 | 数符(S) | 阶码(E，移码表示) | 尾数(原码表示) | 总位数 | 偏置值 | 真值形式 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 单精度浮点数float | 1 | 8 | 23 | 32 | 127 | $\displaystyle (-1)^S\times1.m\times2^{E-127}$ |
| 双精度浮点数double | 1 | 11 | 52 | 64 | 1023 | $\displaystyle (-1)^S\times1.m\times2^{E-1023}$ |
| 临时浮点数 | 1 | 15 | 64 | 80 | 16383 | - |

> 阶码全1表示无穷大，全0表示无穷小或非规格化数

2. 浮点数表示范围

| 格式 | 最小值 | 最大值 |
|:---:|:---:|:---:|
| 单精度浮点数 | $\displaystyle E=1,m=0，\\2^{-126}$ | $\displaystyle E=254,m=.111...1，\\2^{127}\times(2-2^{-23})$
 | 双精度浮点数 | $\displaystyle E=1,m=0，\\2^{-1022}$ | $\displaystyle E=254,m=.111...1，\\2^{1023}\times(2-2^{-52})$

3. 运算
   - 对阶：低阶向高阶对齐，即，阶码小的尾数部分右移一位，阶码+1，直到阶相同
   - 尾数求和：按定点数运算规则运算
   - 规格化
     - 左规：当尾数出现00.0x……或11.1x……时，左规，即尾数左移1位，阶码-1（可多次）
     - 右规：当尾数求和结果溢出时（如10.x……或01.x……），右规，即尾数右移1为，阶码+1（最多一次）
     - 舍入：对阶和右规过程中，可能会将尾数低位丢失，引起误差，可采用“0舍1入法”或“恒置1法”处理
     - 溢出判断：由阶码的符号位判断，若双符号位不同则溢出，且“**01**”表示上溢，进中断处理，“**10**”表示下溢，按机器0处理

### 存储系统

#### 半导体随机存储器

1. RAM（易失性存储器）
   - SRAM（静态随机存储器）
   - DRAM（动态随机存储器）

| | SRAM | DRAM |
|:---:|:---:|:---:|
| 存储信息| 触发器（晶体管） | 电容 |
| 破坏性读出 | 否 | 是 |
| 需要刷新 | 否 | 是（通常按行刷新） |
| 集成度 | 低 | 高 |
| 速度 | 快 | 慢 |
| 功耗 | 大 | 小 |
| 用途 | Cache | 主存 |


2. ROM（非易失性存储器），通常包括
   - 掩模式只读存储器MROM：写入后无法修改
   - 一次可编程只读存储器PROM：写入后无法修改
   - 可擦除可编程只读存储器EPROM：可多次改写，擦除方式可分为两种
     - 紫外线擦除UVEPROM
     - 电擦除$\displaystyle E^2PROM$
   - 闪速存储器Flash Memory
   - 固态硬盘SSD

#### Flash Memory的特点
   - 基于$\displaystyle E^2PROM$技术
   - 价格便宜，集成度高
   - 是非易失性存储器，可以长期保存信息
   - 能快速擦写，写入前必须先擦除，**写比读慢**

#### SSD相关
   1. 原理：基于flash技术，内部包含多个flash芯片，故也是$\displaystyle E^2PROM$ 
   2. 组成：
      1. 闪存翻译层：负责翻译逻辑块号，找到对应页
      2. 存储介质：多个flash芯片（flash chip），每个芯片包含多个块（block），每个块包含多个页（page）
   3. 读写特性：
      1. 以页为单位**读写**（操作系统读写SSD的一个页，读写磁盘的一个块，即扇区）
      2. 以块为单位**擦除**，对于擦除干净的块，其中的每个页都可以写一次，读无限次
      3. 支持随机访问，系统给定逻辑地址，闪存翻译层可通过电路快速定位到对应的物理地址
      4. 读快，写慢，且如果要写入的页中有数据，则不能直接写入，需要将块内各页中的数据全部复制到一个新的（擦除过的）块中，才能在写入数据
   4. 对比机械硬盘
      1. SSD读写速度更快，随机访问能力更高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟
      2. SSD能耗低，造价高
      3. SSD的块若被频繁擦除（重复在同一块写入），可能会坏，而机械硬盘不会因为频繁写入而坏
   5. 磨损均衡技术
      1. 思想：将**擦除操作**平均分布到各个块上
      2. 动态磨损均衡：写入数据时，优先选择**累计擦除次数少的**新闪存块
      3. 静态磨损均衡：SSD检测并自动进行数据分配、迁移，即**老的闪存块承担以读为主的任务**，**而较新的闪存块承担以写为主的任务** 


#### 多体并行存储器
1. 高体交叉存储器 
   - 高位地址为体号，低位为体内地址
   - 程序连续存放在一个体中

2. 低位交叉存储器
   - 低位地址为体号，高位为体内地址
   - 程序连续存放在相邻体中
   - 若要实现流水线方式存取，存储器交叉模块数$\displaystyle m\ge\frac{存取一个字的存取周期T}{总线传送周期为r}$

3. 若存取一个字的存取周期为T，总线传送周期为r，对于m位交叉存储器，连续存取m个字的时间为（即r = T/m）

| | 低位交叉存储器 | 高位交叉存储器 |
|:---:|:---:|:---:|
| 时间 | T+(m-1)r | mT |

#### cache写策略
1. 写命中
   - 全写法（直写法）：写命中时，必须把数据同时写入主存与cache，故cache中某块数据需要替换时，直接覆盖即可
   - 写回法：写命中时，只修改cache中的内容，只有当此块被换出时才写回主存

2. 写不命中
   - 写分配法：现在主存块中更新相应存储单元，然后分配一个cache行，将更新后的主存块装入cache中，通常与写回法合用
   - 非写分配法：仅更新主存单元，不把主存块装入cache，通常与全写法合用


### 指令系统
#### 寻址方式

| 寻址方式 | 有效地址 | 访存次数 |
|:---:|:---:|:---:|:---:|
| 立即寻址 | A是操作数 | 0 | 
| 直接寻址 | EA=A | 1 |
| 一次间址寻址 | EA = (A) | 2 |
| 寄存器寻址 | EA = Ri | 0 |
| 相对寻址 | EA = (PC) + A | 1 |
| 基址寻址(多道程序设计) | EA = (BR) + A | 1 |
| 变址寻址(数组) | EA = (IX) + A | 1 |

#### CISC与RISC

| | CISC | RISC |
|:---:|:---:|:---:|
| 指令系统 | 复杂，庞大| 简单，精简 |
| 指令数目 | 一般大于200条 | 一般小于200条 |
| 指令字长 | 不固定 | 定长 |
| 可访存指令 | 无限制 | 只有Load/Store指令 |
| 各指令执行时间 | 相差较大 | 多在一个时钟周期内完成 |
| 各指令使用频度 | 相差较大 | 都很常用 |
| 通用寄存器数量 | 较少 | 多 |
| 目标代码 | 难以用优化编译生成高效的目标代码 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式 | 多为微程序控制 | 多为组合逻辑控制 | 

**流水线技术特点：①指令长度大多一致，②指令格式尽量规整，③保证除Load/Store指令外的指令都不访问寄存器，④数据和指令在存储器中“对齐”存放**

### 中央处理器
#### CPU基本结构
| 运算器 | 控制器 |
|:---:|:---:|
| 算数逻辑单元ALU | 程序计数器PC |
| 累加寄存器ACC | 指令寄存器IR |
| 暂存寄存器DR | 指令译码器 |
| 通用寄存器组 | 存储器地址寄存器MAR |
| 程序状态字寄存器PSWR | 存储器数据寄存器MDR |
| 移位器 | 时序系统 |
| 计数器 | 微操作信号发生器 |

| 寄存器 | 用户是否可见 | 功能 |
|:---:|:---:|:---:|
| 通用寄存器组 | 是 | 存放操作数和地址信息 |
| 程序状态字寄存器PSWR | 是 |保留由逻辑运算指令或测试指令的结果建立的各种状态信息 |
| 程序计数器PC | 是 | 指出下一条指令在主存中的地址 |
| 累加寄存器 | 是 | 暂时存放ALU运算的结果信息，用于实现加法运算 |
| 指令寄存器 | 否 | 保存当前正在执行的指令 |
| 暂存寄存器 | 否 | 暂存从主存读的数据 |
| 存储器地址寄存器MAR | 否 | 存放所要访问的主存单元的地址 |
| 存储器数据寄存器MDR | 否 | 存放向主存写入的信息或从主存中读入的信息 |

#### 指令周期
1. 取址周期（**PC+1**）
2. 间址周期
3. 执行周期
4. 中断周期

####  控制器

| 控制方式 | 设计思想 | 特点 |
|:---:|:---:|:---:|
| 硬布线控制器 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序产生 | 速度快， 结构复杂，难扩展，常用于RISC |
| 微程序控制器 | 一条机器指令对应一个微程序，一个微程序包含若干微指令| 速度慢，结构简单，易扩展，常用于CISC |

#### 微指令的编码方式

| 编码方式 | 直接编码 | 字段直接编码 |
|:---:|:---:|:---:|
| 实现方法 | 微指令的控制字段中的每一位都代表一个微命令，选用某个微命令只要将该微命令对应的位设位1即可 | 将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同的字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关 |
| 特点 | 简单，但指令字过长，n个微命令就由n位操作字段 | 较复杂，每个小段不能包含太多的信息，否则会增加译码线路的复杂性和译码时间 |

#### 五段式指令流水线

1. 取指IF
2. 译码/取数ID
3. 执行EX
4. 访存M
5. 写回寄存器WB

| 指令类型 | 经历阶段 |
|:---:|:---:|
| 运算类 | IF、ID、EX、WB |
| 条件转移类 | IF、ID、EX、M |
| 无条件转移类 | IF、ID、EX |
| Load | IF、ID、EX、M、WB|
| Store | IF、ID、EX、M |

#### 流水线阻塞的原因
1. 结构相关
2. 控制相关
3. 数据相关
   - 读后写RAW
   - 写后读WAR
   - 写后写WAW

#### 超标量流水线
1. 超标量流水线技术：每个时钟周期内同时并发多条独立指令
2. 超流水线技术：将流水线在一个时钟周期内再分段
3. 超长指令字技术：在编译时挖掘指令间潜在的并行性，把多条能并行操作的的指令组合成一条具有多个操作码字段的超长指令

### 总线
#### 总线的分类

| 总线类型 | 定义 |
|:---:|:---:|
| 片内总线（局部总线） | CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共线路 |
| 系统总线 | 计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线 |
| 通信总线（设备总线） | 计算机系统之间或计算机系统与其他系统之间信息传递的总线 |

#### 总线事务
1. 定义：从请求总线到完成总线使用的操作序列称为总线事务
2. 典型的总线事务：请求操作、裁决操作（哪个主控设备使用总线）、地址传输、数据传输、总线释放

#### 总线的定时方式
1. 同步通信：采用统一的时钟信号
2. 异步通信：通过“握手”的方式实现控制
   - 不互锁
   - 半互锁
   - 全互锁

#### 总线性能指标
1. 总线传输周期：一次总线操作所需的时间，包含多个总线时钟周期
2. 总线工作频率：总线传输周期的倒数
3. 总线宽度：能同时传输的数据位数，通常是指数据总线的根数
4. 总线带宽：单位时间内总线上可传输数据的位数（总线带宽 = 总线宽度 $\displaystyle \times$ 总线工作频率）

#### 猝发传输方式
常规传输：一次传输一个地址和一个数据
猝发传输：在一个总线周期内，可以传输多个存储地址连续的数据，即一次传输一个地址和一批地址连续的数据

#### 总线标准

| 总线标准 | 特点 |
|:---:|:---:|
| **ISA** | 系统总线 |
| **EISA** | 系统总线 |
| FBS | 系统总线 |
| QPI | 系统总线 |
| VESA | 局部总线 |
| **PCI** | 局部总线 |
| AGP | 局部总线 |
| **PCI-E** | 串行局部总线 |
| RS-232C | 串行通信总线 |
| SCSI | 并行通信总线 |
| PCMCIA（存储卡） | 通信总线（计算机之间） |
| **USB** | 串行通信总线 |
| SATA | 串行通信总线 |

### I/O系统
#### 显示器
1. 分辨率：显示器能表示的像素个数
2. 灰度级（颜色深度）
   - 黑白显示器像素点亮暗差别：深色级8位，可显示256中亮度的像素
   - 彩色显示器像素点颜色不同：色深8位，可现实256种颜色的像素
3. 刷新频率：单位时间内扫描整个屏幕内容的次数
4. 显示存储器（刷新存储器VRAM）
   - $\displaystyle VRAM容量=分辨率\times 灰度级位数$
   - $\displaystyle VRAM容量=分辨率\times 灰度级位数 \times 帧率$

#### I/O端口编址
1. 统一编址：把I/O端口看作存储器的单元进行地址分配
   - 优点：不需要专门的I/O指令
   - 缺点：执行速度慢，占用了存储器地址

2. 独立编址：I/O端口地址与存储器地址无关，需要设置专门的I/O指令访问端口
   - 优点：程序编址清晰，容易理解
   - 缺点：I/O指令少，一般只能对端口进行操作；增加了控制的复杂性

#### DMA
1. DMA传送方式：当I/O设备与CPU同时访问主存时，可能产生冲突
   - 停止CPU访问：要求CPU放弃对相关总线的使用权，且在整个数据块传送期间不可以访问主存
   - DMA与CPU交替访存：将CPU周期分为两个周期，一个供CPU访存，一个供DMA访存
   - 周期挪用：DMA挪用一个或几个存取周期

**DMA使用系统总线的优先级高于CPU，因为若不能及时响应，可能会导致数据丢失**  

2. DMA传送过程
   - 预处理：完成准备工作，请求总线使用权
   - 数据传送：DMA直接控制总线
   - 后处理：发送中断请求，CPU执行中断服务程序

### 纠错

---

## 操作系统
### 操作系统基础知识
#### 操作系统结构

| | 特性/思想 | 优点 | 缺点 |
|:---:|:---:|:---:|:---:|
| 分层结构 | 内核分为多层，每层可**单向调用更低层**提供的接口 | ①便于调试，自底向上逐层调试<br>②易于扩充和维护 | ①难以合理定义各层的边界<br>②效率低，系统调用时间长 |
| 模块化 | 将内核分为多个模块，各模块相互协作<br>内核=主模块+可加载内核模块<br>主模块：只负责核心功能，如调度，内存管理 | ①模块间逻辑清晰易于维护<br>②支持动态加载新的内核模块，增强OS适应性<br>③任何模块都可以直接调用其他模块，无需采用消息传递通信，效率高| ①接口间的定义未必合理 | 
| 宏内核（大内核） | 所有系统功能都放入内核（大内核通常也采用模块化思想） | 性能高，内核中各功能可以相互调用 | ①内核庞大功能复杂，难以维护<br>②大内核中某模块出错，可能导致整个系统崩溃 |
| 微内核 | 只把中断、原语、进程通信等最核心的功能放入内核。进程管理，文件管理等功能以用户进程的形式运行在用户态 | ①内核小，功能少，易于维护，可靠性高<br>②内核外的某个功能模块出错不会导致整个系统崩溃 | ①性能低，需要在管态/目态间频繁切换<br>②目态下各功能模块不能直接调用，只能通过内核的”消息传递“来间接通信 |
| 外核 | 内核负责进程调度等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全 | ①外核可以直接给用户分配未经抽象的硬件资源，故用户进程可以更灵活的使用硬件资源<br>②减少了虚拟硬件资源的抽象层，效率提高 | ①降低了系统的一致性<br>②系统变得更复杂 |

#### 中断

1. 中断隐指令
   - 关中断
   - 保存断点（PC的内容）
   - 中断服务程序寻址
2. 中断服务程序
   - 保存现场
   - 开中断（多级中断）
   - 执行中断服务程序
   - 关中断（多级中断）
   - 恢复现场
   - 开中断
   - 中断返回

### 进程管理

#### 进程
##### 进程映像与地址空间
   - 代码段
   - 数据段
   - 进程控制块PCB
   - 堆
   - 栈

> 操作系统通过内存管理部件MMU将进程使用的虚拟地址转换为物理地址
> 共享库用来存放进程用到的共享库函数代码

![](https://s2.loli.net/2021/12/18/jxGBcXVba8TF4ht.png)

##### 进程的特点
   - 资源分配和拥有的基本单位
   - 在没有线程的操作系统中，是调度的基本单位
   - 进程的地址空间相互独立
   - 通信方式：PV操作、共享存储、消息传递、管道
   - 进程切换时系统开销较大（如Cache失效，TLB失效，页表寄存器内容保存至PCB）

##### 闲逛进程
在进程切换时，若系统中没有就绪进程，则会调度闲逛进程（idle）运行，若没有其他进程就绪，该进程会一直运行，并在执行过程中测试中断，**闲逛进程优先级最低，没有就绪进程便会运行，但只要有进程就绪便会立刻让出CPU，且闲逛进程不需要CPU外的任何资源，故不会被阻塞**

#### 线程
##### 线程的状态与切换
   - 执行状态：获得处理机并在运行中
   - 就绪状态：已具备执行条件，等待CPU
   - 阻塞状态：因某事件受阻而处于阻塞状态

##### 用户级线程与内核级线程

| | 用户级线程 | 内核级线程 |
|:---:|:---:|:---:| 
| 定义 | 存在于用户空间中，线程的创建、撤销、切换（同一进程的下的不同线程）等功能均在用户空间完成，内核不知道用户级线程的存在（通过**线程库**管理） | 在内核支持下运行，线程的创建、撤销、切换等功能均在内核空间完成。内核根据**线程控制块**感知线程的存在 |
| 优点 | ①同一进程下的线程线程切换不需要转换到内存空间，开销小<br>②调度算法可以是进程专用的<br>③用户级线程的实现与操作系统无关，对于线程的管理代码都属于用户程序 | ①在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行<br>②一个线程阻塞，可以调度进程中的其他线程或其他进程中的线程运行<br>③内核本身爷可以采用多线程技术，提高系统效率 |
| 缺点 | ①一个线程阻塞，同一进程内的所有线程都会阻塞，故无法充分利用多处理器系统有点<br>②内核以进程为单位分配CPU，因此同一时刻，一个进程中只有一个线程在运行 | 同一个进程中的线程切换时，需要从目态转换为管态，系统开销较大 |

##### 线程库
   - 定义：为程序员提供创建和管理线程的API
   - 实现方式有两种
     - ①在用户空间提供一个没有内核支持的库，库中的代码和数据结构都位于用户空间，此时调用库内的函数实质是，调用用户空间的一个本地函数
     - ②由操作系统直接支持的内核级的库提供，此时库中的代码和数据结构均位于内核空间，调用库内的函数实质是，对内核的系统调用
   - 三种主要线程库
     - POSIX Pthread：可以提供用户级或内核级的库
     - Windows线程库：Windows内核级线程库
     - JAVA线程API：依赖于宿主系统实现（如在Windows系统就是由Windows线程库实现）

##### 线程的组织与控制
   - 线程控制块TCB，主要包括
     - 线程标识符
     - 寄存器信息：程序计数器、状态寄存器和通用寄存器
     - 线程运行状态
     - 优先级
     - 线程专有存储区（用于线程切换时保护线程等功能）
     - 堆栈指针
   - 线程的创建：线程的创建函数执行完成后，返回一个线程标识符
   - 线程的终止：通常，线程被终止后不立即释放所占有的资源，只有当进程中其他线程执行了分离函数，被终止的线程才与资源分离，此时这些资源才能被其他线程利用（被终止但未释放资源的线程仍可被其他线程调用）

##### 特点
   - 线程自己基本不拥有系统资源，但可以访问所属进程内的所有资源
   - 在引入进程的操作系统中，线程是调度的基本单位
   - 通信方式：同一进程内的各线程直接读写进程的数据段（一个线程可以读写，甚至清除另一个线程的堆栈），不同进程内的线程通信属于进程间通信
   - 系统开销，线程切换只保存少量寄存器信息，开销小（保存程序计数器、寄存器、堆栈）

#### CPU调度
1. 调度器与调度程序
   - 排队器：将就绪进程按一定策略排成一个或多个队列，以便调度程序选择
   - 分派器：依据调度程序所选的进程，将其从就绪队列取出并上处理机
   - 上下文切换器：在进程切换时，保存当前进程的上下文，将即将到来的进程的上下文恢复到CPU寄存器中

> **上下文切换时会执行大量Load/Store指令，用于保存寄存器的内容，故时间开销较大**  

![](https://s2.loli.net/2021/12/18/OdBioqexzltUHaW.png)

1. 调度算法的评测标准
   - CPU利用率
     - $\begin{aligned}
         CPU利用率=\frac{CPU运行时间}{总时间}
      \end{aligned}$
   - 系统吞吐量
     - $\begin{aligned}
         系统吞吐量=\frac{总共完成的作业数}{总共消耗的时间}
      \end{aligned}$
   - 周转时间
     - $\begin{aligned}
         周转时间=作业完成时间-作业提交时间
      \end{aligned}$
     - $\begin{aligned}
         平均周转时间=\frac{各作业周转时间之和}{作业数}
      \end{aligned}$
     - $\begin{aligned}
         带权周转时间=\frac{作业周转时间}{作业实际运行时间}
      \end{aligned}$
     - $\begin{aligned}
         平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}
      \end{aligned}$
   - 等待时间
     - $进程/作业等待时间=等待被服务的时间之和$
     - $进程/作业平均等待时间=各进程/作业等待时间的平均值$
   - 响应时间
     - $响应时间=首次响应时间-用户提交请求时间$


2. 不能进行调度的情况
   - 在处理中断的过程中：由于中断处理过程复杂，故实际上很难做到进程切换，中断是操作系统的工作，不属于进程的一部分，不应剥夺处理机
   - 进程在操作系统**内核程序的临界区中**，进入临界区，需要独占式的访问共享资源，理论上需要加锁操作，解锁前不应剥夺处理机
   - 处于完全屏蔽中断的原子操作中

3. 调度算法

| 算法 | 进程/作业 |是否可抢占 | 饥饿现象 | 特点 |
|:---:|:---:|:---:|:---:|:-------:|
| 先来先服务调度算法 | 进程/作业 | 非抢占式 | 不会 | 优点：①公平，简单②利于长作业③利于CPU繁忙型<br>缺点：①效率低②不利于短作业③不利于I/O繁忙型 | 对短作业不利，效率低 |
| 短作业优先调度算法 | 进程/作业 | 默认非抢占式，也存在抢占式算法，即最短剩余时间算法（SRTN）| 会 | 优点：”最短”平均等待时间、平均周转时间<br>缺点：对长作业不利；②难以做到正确评估运行时间 |
| 高响应比优先调度算法 | 进程/作业 | 非抢占式 | 不会 | 优点：①有利于短作业②长作业不至于“饥饿”<br>$\displaystyle 相应比R_p = \frac{等待时间+要求服务时间}{要求服务时间}$ |
| 优先级调度算法 | 进程/作业 | 有抢占式也有非抢占式 | 会 | 适用于实时操作系统<br>缺点：可能导致饥饿 | 
| 时间片轮转调度算法 | 进程 | 抢占式 | 不会 | 适用于分时操作系统<br>优点：公平<br>时间片大：系统开销小，但交互性差<br>时间片大：有利于短作业，但系统开销大 |
| 多级反馈队列调度算法 | 进程 | 抢占式 | 会 | 均衡，融合了前几种算法的优点 |
| **多级队列调度算法** | 进程 | 抢占式 | 会 | 队列间可以按优先级划分，也可按时间片划分 |

**多级反馈队列中队列的划分原则是优先级，而多级队列中划分的原则则是进程的类型（各队列可设置优先级高低，也可设置时间片不同）**  

![](https://s2.loli.net/2021/12/18/ziynBqkoGE5D8g2.png)

**优先级设置的原则：①系统进程 > 用户进程 ②交互型进程 > 非交互型进程（或前台进程 > 后台进程） ③IO型进程 > 计算型进程**

#### 同步与互斥
1. 临界区互斥访问的软件方法
   - 单标志法：违反空闲让进原则
   - 双标志先检查：违反忙则等待原则
   - 双标志后检查：违反了空闲让进与有限等待原则，会产生饥饿
   - 皮特森算法：违反了让权等待原则，不会饥饿

2. 临界区互斥访问的硬件方法
   - 中断屏蔽法
   - 硬件指令：不满足让权等待，会导致忙等现象
     - TestAndSet
     - Swap
3. 锁（互斥）与条件变量（同步）
   - 锁：acquire()与release()必须是原子操作，故互斥锁常用硬件方式实现，主要**缺点**是忙等（需要连续循环忙等的互斥锁，可称为自旋锁），**优点**等待期间不用切换进程上下文，对于多处理器系统，若上锁时间段，其等待代价很低（其他核中的进程完成后释放临界区便解锁），故适用于多处理器系统，不适用于单处理器系统
   - 条件变量：类似于等待队列（**信号量机制有初值，条件变量没有**），包含两个操作：wait操作（类似于P操作），signal操作（类似于V操作），与锁配合使用

![](https://s2.loli.net/2021/12/18/z9HxOURt4yepNK7.png)

#### 死锁
1. 死锁产生的四个条件
   - 互斥条件
   - 不剥夺条件
   - 请求和保持条件
   - 循环等待条件

2. 死锁的的处理策略
   - 死锁预防：破坏死锁产生的四个条件之一
   - 死锁避免：银行家算法
   - 死锁检测：化简资源分配图

### 内存管理
#### 连续分配方式
1. 分配方式

| | 单一连续分配 | 固定分区分配 | 动态分区分配 |
|:---:|:---:|:---:|:---:|
| 方式 | 分为系统区与用户区，通常低地址部分是用户区 | 将用户空间划分为固定大小的区域 | 不预先对内存进行划分，而是在进程装入内存时动态建立分区，且分区大小刚好为进程所需大小 |
| 碎片 | 内部碎片 | 内部碎片 | 外部碎片 |
| 空间不足的解决办法 | 覆盖 | 覆盖/交换 | 交换 |

2. 动态分区分配算法
   - 首次适应算法：空闲分区按地址递增排序，找到第一个满足需求的分区使用（平均性能最好）
   - 循环首次适应算法：空闲分区按地址递增排序，分配内存时，从上一次查找结束的位置开始继续查找，直到找到满足需求的分区（性能比首次适应算法差）
   - 最佳适应算法：空闲分区按容量大小递增排序，找到第一个满足需求的分区使用（需要对分区大小排序，开销大，且产生大量外部碎片）
   - 最差适应算法：空闲分区按容量大小递减排序，找到第一个满足需求的分区使用（需要对分区大小排序，开销大，使系统缺少大块的连续空闲块）

#### 非连续分配管理方式
| | 简单分页管理 | 简单分段管理 | 段页式管理 |
|:---:|:------:|:-------:|:---:|
| 特点 | ①从计算机角度设计，旨在提高内存利用率与计算机性能<br>②通过硬件实现，页号与页内偏移对用户透明<br>③地址是一维的<br>④产生内部碎片<br>⑤页面大小一致 | ①从用户角度出发，旨在方便编程，信息保护与共享、动态连接等方面<br>②段号与段内偏移由用户显式提供<br>③地址是二维的<br>④产生外部碎片<br>⑤段长不等 | 对于一个进程，段表只有一个，而页表可以有多个 |

#### 虚拟页式存储管理
1. 虚拟存储器的实现方式
   - 请求分页
   - 请求分段
   - 请求段页式
2. 虚拟存储器的三个特征
   - 多次性
   - 对换性
   - 虚拟性
3. 页面置换算法
   - 最佳置换算法（OPT）
   - 先进先出置换算法（FIFO）
   - 最近最久未用置换算法（LRU）
   - 时钟置换算法（Clock/NRU）
     - 选择使用位u=0的页面，并将略过的页面的使用位改为u=0;
   - 改进型时钟置换算法
     - ①优先选择（u, m） = (0, 0)的页面，此轮不修改
     - ②选择（u, m） = (0, 1)，并对每个掠过的页面，将其使用位改为u=0
4. 内存共享：是指多个进程访问内存的同一部分，通过内存映射完成（可以是”页“映射，也可以是”段“映射）

![](https://s2.loli.net/2021/12/18/JCcBRHwOy7I5Dvb.png)

1. 内存映射文件
   - 方式：将磁盘中文件的全部或部分内容与进程的虚拟空间的某个区域建立映射
   - 优点：可以直接访问被映射的文件（可以简单理解为文件成为进程中data的一部分），而不用通过I/O操作访问，且多个进程可以共享内存映射文件
   - 映射的实际交互都是在内存中完成的（并不是进程与磁盘直接映射，内存是一个中转站），即，通过Open系统调用打开文件后，再通过mmap系统调用，**将文件页映射到进程的虚拟空间中时，操作系统页会自动分配一些内存空间保存这些文件页，故当进程修改了文件的数据之后，退出文件或解除文件映射，所有改动的页面会从内存中写回磁盘文件**

![](https://s2.loli.net/2021/12/18/zDhPUL1T9EmeZl3.png)

1. 虚拟纯初期性能的影响因素
   - 性能指标
     - **缺页率**
     - TLB命中率
     - Cache命中率
     - 页面置换速度
   - 影响性能的因素
     - 页面大小：影响缺页率与页面置换速度
     - 分配的页框数量：影响缺页率
     - 页面置换算法：影响缺页率
     - 程序局部性：影响缺页率，TLB命中率、Cache命中率
     - 存交换区读写速度：影响页面置换速度

2. 页面分配策略
   - 固定分配全局置换
   - 可变分配全局置换
   - 固定分配局部置换

3. 工作集合：任意时刻T，最近t次访问的页面（t=窗口大小）

### 文件管理

#### 文件目录
1. 文件控制块FCB
   - 基本信息：文件名、文件物理位置、文件逻辑结构、文件物理结构等
   - 存取控制信息：文件存取权限、存储位置等
   - 使用信息：文件建立时间、修改时间等
2. 文件目录
   - FCB的有序集合，目录中的一个FCB就是一个目录项
   - **目录永不未空，至少包含两个目录项，当前目录”.“和父目录项”..“**

3. 目录的操作
   - create系统调用：创建目录
   - delete系统调用：删除目录，只有空目录可以删除
   - opendir系统调用：打开目录，只是将目录文件的FCB读入内存
   - readdir系统调用：读目录
   - rename系统调用：重命名，本质是修改指向该目录文件的FCB
   - link系统调用：建立硬链接
   - unlink：解除硬链接，若共享计数器count=0，则删除文件数据 

4. 普通文件的操作
   - 打开open
   - 关闭close
   - 创建create
   - 删除delete
   - 读read
   - 写write
5. 文件元数据：即文件的属性，记录再FCB中

#### 文件共享与文件保护
1. 文件共享
   - 硬链接：采用索引节点方式，会导致链接计数器count变化
     - 优点：实现了异名共享
     - 缺点：文件拥有者不能删除与他人共享的文件（只有当链接计数器count=0才是真正的删除）
   - 软链接（符号链接）：创建了一个包含被共享文件的路径名的LINK型文件
     - 优点：文件拥有者可以直接删除共享文件
     - 缺点：其他用户读共享文件时，需要根据路径名访问，开销较大

2. 文件保护
   - 口令保护
   - 加密保护
   - 访问控制

#### 文件系统
1. 文件的分配方式
   - 连续分配：不利于文件拓展
   - 隐式链接分配：只能按链表的方式顺序读磁盘，开销大
   - 显式链接分配：内存中存放链接表显示的表示链接关系，减少了访问磁盘的次数，由于分配给文件的所有盘块号都存放于表中，故该表也称为文件分配表FAT
   - 索引分配：把每个文件的所有盘块号集中存放到一个索引块中
   - 混合索引方式：包含直接索引地址与间接索引地址，如下所示

![](https://s2.loli.net/2021/12/18/Lx354AKV7Syuvoc.png)

1. 虚拟文件系统VFS
   - 目的：向用户提供同一的系统调用接口，屏蔽下层不同文件系统的实现差异（若系统盘使用FAT文件系统，U盘使用NTFS文件系统，但并不影响在计算机中的访问）
   - 具体实现
     - 每打开一个文件，VFS舅在主存中新建一个Vnode，用统一的数据结构表示文件
     - Vnode结点除了记录文件系统的格式，还有一个函数功能指针指向文件系统实现的各种功能
   - 虚拟文件系统只存在于内存中，作为内核空间中的一个软件层（抽象层），在系统启动时建立，系统关闭时消亡

![][虚拟文件系统](https://s2.loli.net/2021/12/18/hB1IdVXAgeE6yUz.png)

1. 文件系统挂载（mounting）
   - 目的：将一个文件系统挂载到操作系统中（插U盘）
   - 过程：
     - 在VFS中注册挂载的文件系统，**内存中的挂载表**包含每个文件系统的相关信息，包括文件系统类型，容量大小等
     - 新挂载的文件系统，要向VFS提供一个函数地址列表
     - 新文件系统加载到挂载电，即挂载到某个父目录下
   - Windows系统会自动挂载，Linux需要手工挂载或配置西戎进行自动挂载（使用命令mount挂载，unmount卸载）

#### 两种文件系统在外存中的结构
1. FAT在外存中
![](https://s2.loli.net/2021/12/18/8oUnyh3scrxRI7P.png)

2. 混合索引在外存中
![](https://s2.loli.net/2021/12/18/dw3tFUj6eDY718T.png)

#### 文件系统在内存中的结构

![](https://s2.loli.net/2021/12/18/DS7BU32gnlqeQuv.png)

#### 磁盘
1. 磁盘读写时间
   - $\displaystyle 磁盘读写时间=寻道时间+延迟时间（\frac{1}{2\times转速}） + 传输时间$

2. 磁盘调度算法
   - 先来先服务FCFS：公平，对于局部性较好的访问序列有较好的性能
   - 最短寻找时间优先SSTF：平均寻找时间不一定最小，性能比FCFS更好，单会产生“饥饿”
   - 扫描算法SCAN（电梯算法）：不会“饥饿”但不利于远离磁头一端的访问请求
   - 循环扫描算法C-SCAN

3. 磁盘地址表示方法：（柱面号，盘面号，扇区号）
4. 提高磁盘I/O的方式
   - 提前读：在读磁盘当前块时，把下一个磁盘块也读入内存缓冲区
   - 延迟写：仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表尾部，当其他进程申请到此缓冲区时，才真正把缓冲区的信息写入磁盘
   - 虚拟盘：用内存仿真磁盘，又称RAM盘

### I/O管理
#### I/O软件的层次结构
1. 层次结构

| 层次 | 说明 |
|:---:|:---:|
|用户层I/O软件| 实现与用户交互的接口，用户可以使用I/O相关的库函数，用户软件层需要通过一组系统调用取得操作系统的服务 |
| 设备独立性软件 | 抽象层，向上提供统一的统一的接口，向下执行所有设备的共有操作 |
| 设备驱动程序 | 根据上层规定的抽象操作，实现具体的操作，并封装成标准接口提供给上层 |
| 中断处理程序 | 进程上下文的切换，对处理中断信号源进行测试 |
| 硬件设备 | 通常包括机械部件与电子部件，电子部件又称为设备控制器（适配器）|

2. 设备驱动程序的功能
   - 设备初始化：初次启动设备或传输数据时，预置设备和控制其及通道的状态
   - 执行设备驱动例程：负责启动设备，进行数据传输，对于具有通道的I/O系统，此例程还负责生成通道指令和通道程序，启动通道工作
   - 调用和执行中断处理程序：负责处理设备和控制器及通道发出的各种中断

3. 设备驱动程序接口：介于设备驱动程序与设备独立性软件之间，本质是按操作系统的要求将具体的功能封装好并提供统一的接口

4. 输入/输出应用程序接口：介于用户层I/O软件与设备独立性软件之间，根据设备类型的不同，又进一步分为若干接口
   - 字符设备接口：以字符为单位传输的设备，如键盘，特点是传输速率低，不可寻址（get/put系统调用）
   - 块设备接口：以块为单位传输的设备，如磁盘，特点是传输速率高，可寻址（read/write/seek系统调用）
   - 网络设备接口（网络套接字Socket接口）：用于通过网络与其他计算机进行通信
     - socket系统调用：创建一个网络套接字（类似于缓冲区），指明网络协议
     - bind系统调用：将套接字绑定到某个本地端口
     - connect系统调用：将套接字连接到远程地址
     - read/write系统调用：从套接字读写数据

4. 阻塞I/O与非阻塞I/O
   - 阻塞I/O：应用程序发出I/O系统调用，**进程需要转为阻塞态**
   - 非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，**进程无需阻塞**

#### I/O调度与缓冲区
1. I/O调度：确定一个合适的顺序处理I/O请求
2. CPU处理一块数据的时间：若磁盘把一块数据输入缓冲区的时间为T，缓冲区将数据传送到用户区的时间为M，CPU处理这块数据的时间为C，
   - 单缓冲区：每一块数据的处理时间为$\displaystyle Max(C，T)+C$
     - $\displaystyle 若T>C，则处理n块数据的时间为n(T+M)+C$
     - $\displaystyle 若T<C，则处理n块数据的时间为n(C+M)+T$
   - 双缓冲区：每一块数据的处理时间为$\displaystyle Max(C+M，T)$
     - $\displaystyle 若T>C+M，则处理n块数据的时间为nT+M+C$
     - $\displaystyle 若T<C+M，则处理n块数据的时间为n(C+M)+T$

#### SPOOLing系统
1. 组成
   - 预输入程序：将信息从输入设备送入磁盘的输入井
   - 缓输出程序：将信息从输出井送入输设备
   - 井管理程序：控制作业和磁盘输入井、输出井之间交换信息
2. 磁盘中
   - 输入井：用于收容I/O设备输入的数据
   - 输出井：用于收容需要输出的数据
3. 内存中
   - 输入缓冲区：暂存输入设备送来的数据，之后再送到输入井
   - 输出缓冲区：暂存输出井送来的数据，之后再送到输出设备

---

## 计网

### 基础知识

1. 各层功能
   - 物理层：在物理媒体上透明传输比特流
   - 链路层：组帧、差错控制、流量控制、介质访问控制（对共享信道访问的控制）
   - 网络层：拥塞控制、网际互连、路由与转发
   - 传输层：端到端管理、差错控制、流量控制、分用复用
   - 会话层：建立、管理进程间的会话
   - 表示层：数据压缩、加密解密
   - 应用层：用户与网络的界面

2. 各层设备
   - 物理层：集线器、中继器（转发器）、放大器
   - 链路层：交换机、网桥
   - 网络层：路由器

3. 广播域与冲突域 

| 设备名称 | 能否隔离冲突域 | 能否隔离广播域 |
|:---:|:---:|:--------:|
| 集线器 | 不能 | 不能 |
| 中继器 | 不能 | 不能 |
| 交换机 | 能 | 不能 | 
| 网桥 | 能 | 不能 |
| 路由器 | 能 | 能 |

### 物理层
1. 奈奎斯特定理  
$\displaystyle
\begin{aligned}
    &信道极限数据传输速率=2Wlog_2V \\
    &其中，W为理想低通信道的带宽，V为每个码元离散的电频数目（即V种不同的码元）
\end{aligned}$

2. 香农定理  
$\displaystyle
\begin{aligned}
    &信道极限数据传输速率=Wlog_2{(1+\frac{S}{N})} \\
    &其中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，\frac{S}{N}为信号的平均功率与噪声的平均功率之比，信噪比=10log_{10}{\frac{S}{N}}（db）
\end{aligned}$

3. 3种交换方式
   - 电路交换
   - 报文交换
   - 分组交换

4. 发送时延与传播时延
   - 发送（传输）时延：主机或路由器发送一个报文的时间，发送时延 = 报文长度/报文发送速率
   - 传播时延：电磁波在信道中的传播一定**距离**所花费的时间，传播时延 = 线路长度/信号传播速度

> **对于分组交换，发送时延 = n个分组在发送端的发送时延 + 1个分组从发送到被接收的时间（1 * m个中间结点发送时延 + 传播时延）**  

5. 物理层特性
   - 机械特性：定义规格、引线数目、引脚数目等
   - 电气特性：定义线路上信号的电压高低、传输速率、距离限制等
   - 功能特性：定义某条线路上的某一电平的电压表示什么意义
   - 过程特性（规程特性）：定义各功能中不同事件的出现顺序

### 数据链路层

#### 流量控制与可靠传输
1. 停止-等待协议
   - 发送窗口 = 接收窗口 = 1
   - 发送方每发送一个数据帧就必须停止并等待接收方确认

2. 后退N帧协议（GBN）
   - 若采用n比特对帧编号，则：$\displaystyle 1 \le 发送窗口 \le 2^n-1}\quad  \quad 接收窗口 = 1$
   - 接收方只允许按顺序接收数据帧，故即使收到了n号差错帧之后的所有数据帧，接收方也会将这些帧丢弃，并请求重传n号帧及其之后的帧
   - 通常采用累计确认机制，如发送方发送0~7 号帧，接收方返回0，2，3号帧的确认，表明接收方已经收到0~3 号帧，只需重传4~7 号帧

3. 选择重传协议（SR）
   - 若采用n比特对帧编号，则：$\displaystyle 发送窗口=接收窗口= 2^{n-1}\quad 且发送窗口+接收窗口 \le 2^n$
   - 选择重传不采用累计确认，而是对每个正确收到的帧都返回与之对应的确认帧

### 介质访问控制
1. 信道划分（静态）
   - 频分多路复用FDM
   - 时分多路复用TDM
   - 波分多路复用WDM
   - 码分多路复用CDM\CDMA

2. 随机访问（动态）
   1. ALPHA协议
   2. CSMA（载波侦听多路访问）
      - 1-坚持：发送数据时，先侦听信道，空闲则发，**忙则等待，且一直侦听信道直至信道空闲**，若发生冲突，则随机等待一段时间后，再重新侦听信道
      - 非坚持：发送数据时，先侦听信道，空闲则发，**忙则放弃，等待一个随机时间后再重复上述过程**
      - p-坚持：发送数据时，先侦听信道，**若信道忙，则等到下一时隙再侦听；若信道空闲，则以概率p发送数据，以概率1-p推迟到下一时隙，再重复上述过程**
   2. CSMA/CD（碰撞检测）
      - 侦听：发送前先侦听信道，若空闲则立即发送数据并进行冲突检测；若信道忙，则继续侦听信道，直至信道空闲
      - 碰撞检测：适配器发送数据时检测信道上信号电压变化情况，以判断是否发生冲突，若检测到冲突，适配器停止发送数据，并传输一个拥塞信号，随后采用截断二进制退避算法等待一段随机时间后重新侦听
      - 争用期：即碰撞窗口，设单程传播时延为$\displaystyle \tau$，则以太网端到端往返时间$\displaystyle 2\tau$称为争用期，其意义是，若发送站在发送帧后经过时间$\displaystyle 2\tau$，如果没有发生碰撞，则该帧就能顺利发送
      - $\displaystyle 最小帧长=总线传播时延 \times 数据传输速率 \times 2$
      - $\displaystyle \frac{帧长}{传输速率}\ge 2\tau$
   3. CSMA/CA(碰撞避免)
      - 帧时间间隔IFS
        - SIFS：最短的IFS，使用SIFS的帧有ACK帧，CTS帧、分片后的数据帧、所有回答AP探寻的帧
        - PIFS：中等长度的IFS，在PCF操作中使用
        - DIFS：最长的IFS，用于异步帧竞争访问（RTS预约信道）

3. 发送周期于信道利用率
   - $\displaystyle
        \begin{aligned}
            &发送周期T=\frac{帧长L}{数据传输速率V}+往返时延RTT+接收端发送确认帧的发送时延t \\
            &其中，确认帧很短，通常可将t1忽略
        \end{aligned}$
   - $\displaystyle
        \begin{aligned}
            &若发送周期为T，发送方的数据传输速率为V，发送方在周期T内共发送L比特的数据，则\\
            &信道利用率=\frac{L}{VT} \\
            &其中，确认帧很短，通常可将t1忽略
        \end{aligned}$

#### 局域网
1. 以太网 IEEE 802.3（逻辑拓扑为总线形，物理拓扑为星形或拓展星形）

| 目的地址 | 源地址 |  类型  | 数据  |  FCS | 
|:-----:|:-------:|:---:|:---:|:---:|
| 6B | 6B | 2B | 46~1500B | 4B |

- 前导码(8B，在物理层中添加的首部，不属于MAC帧)：前同步码(7B) + 帧开始定界符(1B)
- 目的地址(6B)：MAC地址
- 源地址码(6B)：MAC地址
- 类型(2B)：指出数据域中携带的数据应交给那个协议实体处理
- 数据(46~1500B)：包含高层协议信息，由于CSMA/CD算法的限制，由于以太网帧最小长度为64B，所以此部分最小长度为46B（64 - 首部地址14B - 尾部4B = 46B），若数据太少，则填充0~46B
- FCS(4B)：校验范围从目的地址到数据段末尾，算法采用32位CRC

**MTU最大传输单元是指MAC帧的数据最大载荷，而MAC帧本身最大长度为1518B**

1. 令牌环网（逻辑拓扑为环形，物理拓扑为星形）
2. 光线分布数字接口 FDDI（逻辑拓扑为环形，物理拓扑为双环形）

#### 无线局域网 IEEE 802.11

1. 802.11中MAC帧

| 功能 | To DS | From DS | Address1(接收端) | Address2(发送端) | Address3 | Address4 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| IBSS | 0 | 0 | DA | SA | BSSID | 未使用 |
| To AP | 1 | 0 | BSSID | SA | DA | 未使用 |
| Freom AP | 0 | 1 | DA | BSSID | SA | 未使用 |
| WDS(无线分布式系统) | 1 | 1 | RA | TA | DA | SA |

2. VLAN概念与原理
    - 性质：将局域网内的设备划分成与物理位置无关的逻辑组
    - 原理：查交换机中的VLAN表
      - 基于接口的VLAN技术：VLAN ID —— 端口
      - 基于MAC地址的VLAN技术：VLAN —— MAC地址 

3. VLAN的实现（添加VLAN标记） —— IEEE 802.1Q帧

| 目的地址 | 源地址 | VLAN标记 | 类型 | 数据 | FCS |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 6B | 6B | 4B | 2B | 46~1500B | 4B |

> 1.VLAN标记，**前两个字节**表示这是IEEE 802.1Q帧，**随后4位**没用，**最后12位**为VLAN标识符VID，用于唯一表示该帧属于哪个VLAN  
> 2.VID取值范围为1~4094  
> 3.IEEE 802.1Q帧由交换机处理

### 广域网与PPP协议
1. PPP协议的功能（如拨号上网）
   - 只支持全双工链路
   - 无需纠错，无需流量控制
   - 封装成帧
   - 实现透明传输
   - 实现差错检测（只检查不纠错）

2. PPP协议的三个部分
   - 将IP数据报封装到串行链路（同步串行/异步串行）的方法
   - 链路控制协议LCP：建立并维护数据链路连接（身份验证）
   - 网络控制协议NCP：PPP支持多种网络层协议，每个不同的网络层协议都需要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接

### 网络层 

1. IP数据报（首部固定部分**20B**，最大60B）
   - 固定部分（20B）
     - 第一行（32位）
       - 版本4位
       - 首部长度4位（单位4B）
       - 区分服务8位
       - 总长度16位（单位1B）
     - 第二行（32位）
       - 标识16位
       - 标志3位：最低位MF（之后是否还有分片）、中间位DF（是否可以分片
       - 片偏移13位（单位8B） 
     - 第三行（32位）
       - 生存时间8位
       - 协议8位（6表示TCP协议，17表示UDP协议）
       - 首部校验和16位（只校验分组首部，不校验数据部分）
     - 第四行（32位）
       - 源地址32位
     - 第五行（32位）
       - 目的地址32位
   - 可变部分（0~40B）

2. IPv4地址划分
   - A类（1~126）：网络号8位（0 + 后7位），主机号24位
   - B类（128~191）：网络号16位（10 + 后14位），主机号16位
   - C类（192~223）：网络号24位（110 + 后21位），主机号8位
   - D类（224~239）：1110 + 后28位多播地址
   - E类（240~255）：1111 + 后28位保留

- **主机号全0表示本网络本身，主机号全1表示本网络的广播地址**
- **127.0.0.0 保留为环回自检地址**
- **32位全0，即0.0.0.0 表示本网络上的本主机**
- **32位全1，即255.255.255.255 表示整个TCP/IP网络的广播地址，又称受限广播地址**

3. 路由表

4. ARP协议、ICMP协议、DHCP协议
   1. 地址解析协议ARP：完成IP地址到MAC地址的映射
   2. 网际控制报文协议ICMP：使主机与路由器报告差错和异常，具体可分为**ICMP差错报告报文（目标主机或路由器向源主机报告差错与异常）**与**ICMP询问报文**
      1. ICMP差错报告报文：分为5类
         - 终点不可达：当路由器或主机**不能交付数据报**时，向源点发送该报文
         - 源点抑制：当路由器或主机因**拥塞而丢弃数据报时**，向源点发送该报文
         - 时间超过：当路由器收到**生存时间TTL为0的数据报时**，丢弃该数据报，并向源点发送该报文
         - 参数问题：当路由器或主机**收到的数据报首部中有的字段的值不正确时**，丢弃该数据报，并向源点发送该报文
         - 改变路由（重定向）：**路由器把该报文发送给主机，让主机知道下次应将数据报发送给别的路由器**
      2. ICMP询问报文分为4类
         - 回送请求和回答报文
         - 时间戳请求和回答报文
         - 掩码地址请求和回答报文
         - 路由器询问和通告报文
   3. 动态主机配置协议DHCP：用于给主机动态分配IP地址
       - 是应用层协议
       - 是基于UDP的

5. 路由协议
   1. 内部网关协议
      1. 路由信息协议RIP：基于距离向量的路由选择协议
           - **应用层协议，使用UDP传送**
           - 网络中每个路由器都要维护从它自己到其他每个目的网络的距离记录
           - 从一个路由器到直接连接的网络跳数为1，每经过一个路由器，跳数+1
           - 一条路径最多包含15各路由器（即15跳），故距离大于等于16时，目的网络不可达
           - **跳数少的路径即为最佳路径**
      2. 开放最短路径优先协议（OSPF）：分布式链路状态路由算法
           - **是网络层协议，使用IP数据报传送**
           - **使用Dijkstra最短路径算法**
          - 向本自治系统内所有路由器发送信息，使用洪范法
           - 发送的信息就是与本路由器相邻的所有路由器的链路状态（包括本路由与哪些路由器相邻，该链路的代价等）
           - 只有当链路状态发生变化时，路由器才用洪范法向所有路由器发送信息，并且更新过程收敛快，不会出现RIP中“坏消息传得慢”的问题
           - **代价最低即为最佳路径**
   2. 外部网关协议
      1. 边界网关协议BGP：用于不同自治系统的路由器之间交换路由信息
          - **是应用层协议，使用TCP传送**
          - BGP-4使用4种报文
            - 打开报文Open：用来与另一个BGP发言人建立关系
            - 更新报文Update：用来发送某一路由的信息，以及要撤销的路由
            - 保活报文Keepalive：用来确认打开报文并周期性的证实邻站关系
            - 通知报文Notification：用来发送检测到的差错
          - **选则的路径不一定是最佳路径**

6. 路由器功能
   1. 转发：微观上控制数据报如何从该路由器的哪一个输出链路进行发送，通常使用硬件解决（对应数据平面）
   2. 路由选择：宏观上控制数据报从源主机到目的主机的路径（对应控制平面）

7. IPv6
   - 特点：
     - 采用无类别编制CIDR
     - 采用网络地址转换NAT
     - 128位
     - 支持单播、多播、任播

8. IP组播
   - 使用英特网组管理协议IGMP
   - 特点：
     - 不提供可靠交付
     - 不产生差错报文

9. 数据平面与控制平面
   1. 数据平面：通过转发表进行转发（转发表基于路由表生成，且不由数据平面维护）
   2. 控制平面
      1. 传统方法（每路由器法）：**路由选择算法运行在每台路由器中**，且在每台路由器中都包含转发和路由选择两种功能（由**路由选择处理器**执行相关功能）
      2. SDN方法：控制平面在**物理上**从路由器中分离，路由器仅实现**转发**功能，**远程控制器**计算和分发转发表给每台路由器使用，具体方式是路由器通过交换**包含转发表和其他路由选择信息的报文**与远程控制器通信，而远程控制器使用软件形式实现的，且是可编程的，（**路由选择处理器负责与远程控制器通信**）
   3. 对于SDN控制平面
      - 两个核心组成部分 
         - SDN控制器（向上有北向API与网络控制应用程序相连，向下有南向API与数据平面相连）
         - 网络控制应用程序
   4. 对于SDN控制器
      - 三个层次
        - 对于网络控制应用程序的接口：通过北向API与网络控制应用程序交互，允许网络控制应用程序在状态管理层之间读写网络状态
        - 网络范围状态管理层：SDN控制平面作出最终控制决定
        - 通信层：SDN控制器与受控网络设备之间的通信（OpenFlow协议），包含南向API
      

### 传输层
1. TCP协议（首部固定部分**20B**，最大60B，与IP数据报相同）
   - 固定部分（20B）
     - 第一行（32位）
       - 源端口16位
       - 目的端口16位
     - 第二行（32位）
       - 序号32位
     - 第三行（32位）
       - 确认号32位
     - 第四行（32位）
       - 数据偏移4位
       - 保留部分6位
       - 符号位6位
         - **确认位ACK**
         - **同步位SYN**
         - **终止位FIN**
         - 紧急位URG
         - 复位位RST
         - 推送为PSH
       - 窗口
     - 第五行（32位）
       - 检验和16位
       - 紧急指针16位
   - 可变部分（0~40B）

2. TCP可靠传输
   1. 序号：TCP面向字节流，故为数据流中的每个字节都编上一个序号，TCP首部中序号字段的值指出本报文段所发送的数据的第一个字节的序号
   2. 确认：TCP首部的确认号是指已接收到的数据中**最后一个字节的序号加1（加1是指期望收到的下一个报文段数据部分的第一个字节的序号）**，且TCP采用累计确认（确认号之前的都正确接收）
   3. 重传
        - 超时：计时器的重传时间到仍未收到确认，则重传
        - 冗余ACK：每当接收方收到比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待的序号，当连续收到队同一个报文段的3个冗余ACK，则重传

3. TCP流量控制与拥塞控制
   1. 流量控制：通过动态控制发送端发送窗口大小实现
        - 接收窗口：由接收端维护
        - 拥塞窗口：由发送端维护，发送端根据当前网络的拥塞程度确定
        - 发送窗口：由发送端维护，发送端在接收到下一个确认前能够发送的最大字节数，且**发送窗口 = min{接收窗口， 拥塞窗口}**
   2. 拥塞控制：
        - 慢开始与拥塞避免算法
        - 快开始和快恢复算法

3. UDP协议（首部8B）
   - 第一行（32位）
     - 源端口16位
     - 目的端口16位
   - 第二行（32位）
     - UDP长度16位
     - UDP校验和16位

4. TCP与UDP

|              | TCP  |   UDP  |
|:------------:|:------------:|:---------:|
| 可靠性 | 保证可靠传输 | 不保证可靠传输  |
| 是否建立连接 | 是 | 否  |
| 数据发送模式 | 面向字节流 | 面向报文 |
| 通信方式 | 点对点  | 一对一、一对多、多对一、多对多 |
| 首部开销 | 20B | 8B   |
| 拥塞控制机制 | 有 | 无  |
| 流量控制机制 | 有 | 无  |

### 应用层       
1. 域名系统DNS
   - 域名服务器
     - 根域名服务器
     - 顶级域名服务器
     - 权限域名服务器
     - 本地域名服务器
   - 域名解析过程
     - 递归查询方式
     - 迭代查询方式
2. 文件传输协议FTP
   1. 控制连接：**端口21，采用C/S工作方式，建立在TCP连接上**，用于传送FTP控制命令（如连接请求、传送请求、终止请求等），**整个会话期间一直保持打开状态，且传输文件时可以使用控制连接**
   2. 数据连接：**端口20，采用C/S工作方式，建立在TCP连接上**，用于连接客户端与服务器的数据传输进程，**每次数据传输完毕后就关闭**
3. 电子邮件
   1. SMTP协议：**采用C/S工作方式，建立在TCP连接上，端口号25**，采用“**推**“的通信方式，用于**用户代理向邮件服务器**与**邮件服务器之间**发送邮件，只支持传输ASCII码的内容
   2. POP协议（POP3）：**采用C/S工作方式，建立在TCP连接上，端口号110**，采用“**拉**“的通信方式，**用于用户代理从邮件服务器的用户邮箱中读取邮件**
   3. 英特网报文存取协议IMAP：一个更复杂的邮件读取协议

**多用途网际邮件扩充MIME：并未改动SMTP，而是增加了邮件主体的结构，并定义了传送非ASCII码的编码规则**

4. 万维网 WWW
   1. 构成
        - 统一资源定位符（URL）：负责表示万维网上的各种文档，并使其具有唯一的标识符URL
        - 超文本传输协议（HTTP）：应用层协议，使用TCP协议保证可靠传输
        - 超文本标记语言（HTML）：一种文档结构的标记语言，对页面上的各种信息（文字、声音、图像、视频等）格式进行描述
   2. 特点
        - 无状态的：同一个客户第二次访问同一个服务器的页面时，服务器并不记得该客户
        - 无连接的：虽然使用了TCP连接（保证可靠性），但通信的双方在交换HTTP报文之前不需要建立GTTP连接
        - 可采用非持久连接或持久连接（HTTP/1.1支持）
   3. 非持久连接与持久连接
      - 对于非持久连接：每个网页元素对象的传输都需要单独建立一个TCP连接，$\displaystyle 请求一个万维网对象所需的时间 = 2RTT+该对象传输时间$，其中一个RTT用于TCP连接，另一个RTT用于请求和接收文档
      - 对于持久连接，万维网服务器在发送相应后扔保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求和响应报文
   4. 流水线与非流水线（持久连接）
      - 非流水线：客户在收到前一个响应后才能发出下一个请求，在已建立连接的情况下，对于**每个文档** $\displaystyle 从发从请求到接收完毕的时间=RTT+文档的传输时间 $
      - 流水线：客户没遇到一个对象引用就发出一个请求，在已建立连接的情况下，当请求与响应都时连续发送时，$\displaystyle 完成请求的总耗时=RTT+n个文件的传输时间$ 
   5. cookie的运行过程
      - ①客户端在浏览器键入web服务器的URL，浏览器发送读取网页的请求
      - ②服务器接收请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话
      - ③客户端收到应答后，若要继续该次会话，则将Set-Cookie中的内容取出，形成一个Cookie.txt文件存放在客户端计算机中
      - ④当客户端再次向服务器发出请求时，浏览器在电脑中寻找对应该网站的Cookie.txt文件，若找到，则根据次Cookie.txt产生报头，放在HTTP请求中发给服务器
      - ⑤服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请求的页面应答给客户端，浏览器的每一次网页请求（如刷新）都可以传递已存在的Cookie文件

5. HTTP请求报文中常用的几个方法  

| 方法 | 意义 |
|:---:|:----:|
| GET | 请求读取由URL标识的信息 |
| HEAD | 请求读取由URL表示的信息的首部 |
| POST | 给服务器添加信息（如注释）|
| CONNECT | 用于代理服务器 |

6. 应用层协议小结  

| | FTP控制连接 | FTP数据连接 | DNS | HTTP | SMTP | POP3 | 远程终端协议TELNET | 简单文件传输协议TFTP | 简单网络管理协议SNMP | 边界网关协议BGP |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 使用协议 | TCP | TCP | UDP | TCP | TCP | TCP | TCP | UDP | UDP | IP |
| 熟知端口号 | 21 | 20 | 53 | 80 | 25 | 110 | 23 | 69 | 161 | - |

