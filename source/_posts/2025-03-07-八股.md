# C++
## 简述C++语言的特点

1. 在兼容C语言的基础上，支持多种范式，例如面向对象、泛型、函数式编程等
2. C++可以直接操作内存，且零成本抽象，配合模板，元编程等技术，不仅可以实现良好的底层控制，且运行效率高
3. C++更安全，通过RAII机制自动管理资源，减少内存泄漏风险
4. C++是一个不断发展的语言，C++11引入了右值，移动语义等特性，c++20引入了module、concept、ranges等特性

## 说说C语言和C++的区别

1. C是一门面向过程的语言，C++是一门面向对象为主，支持多范式编程的语言
2. C++的安全性更高，C语言更倾向手动管理内存，C++更倾向通过RAII（智能指针、容器）自动管理资源生命周期。
3. C++的函数支持函数重载，且利用虚函数支持动态多态
4. C++提供了更为强大的STL标准库

## 说说 C++中 struct 和 class 的区别
 1. C++对C中的struct进行了扩展，C中的struct不能有成员函数，无法进行访问控制，不支持继承
 2. C++中的strcut默认public访问权限，class默认private访问权限，包括private、protect和public三种访问权限，在继承关系中，struct默认公有继承，class默认私有继承
 3. C++中的struct常用于数据聚合，例如POD类型，class常用于更复杂的对象封装

## 说说include头文件的顺序以及双引号""和尖括号<>的区别
1. 尖括号的头文件是系统文件，双引号的头文件是自定义文件
2. 尖括号头文件的查找路径是编译器设置的头文件路径->系统变量；双引号头文件的查找路径是头文件目录->编译器设置的头文件目录->系统变量

## 导入C函数的关键字是什么，C++编译时和C有什么不同？
1. C++通过extern关键字导入C函数，通过extern "C"引入的C函数会按照C语言的规定进行编译
2. 编译的区别主要在函数上，C++由于支持函数重载，编译时不仅包括函数名，还包括参数类型，命名空间等信息，而C语言编译时通常只包括函数名

## 简述C++从代码到可执行二进制文件的过程
C++从源代码到二进制文件经历的过程包括：
1. 预处理，展开#include头文件，处理#define宏和#ifdef条件宏，过滤注释
2. 编译，进行词法/语法分析，语义分析，生成目标代码并优化
3. 汇编，讲目标代码转换为二进制代码
4. 链接，合并多个目标文件及库，生成可执行文件，链接阶段可以分为静态链接和动态链接，静态链接在链接阶段就把要调用的函数链接到可执行文件中，动态链接是在执行过程中寻找要链接的函数

## 说说 static关键字的作用
1. 对于全局变量，其生命周期不变，依然持续到程序结束，存储位置不变，依然为静态存储区，但作用域改变，从可被其他源文件通过extern引用变为只能在本文件可见，用于避免命名冲突
2. 对于局部变量，其生命周期延长至程序结束，存储位置从栈区变为静态存储区，作用域不变，依然是语句块内可见
3. 对于函数，类似于全局变量，只能在本文件中可见
4. 对于成员变量，该变量属于类本身，而不属于实例化的类对象，所有类对象都共享该变量，现在可以通过inline在类内完成初始化
5. 对于成员函数，类似与静态成员变量，属于类本身，而不属于实例化的类对象，静态成员函数只能使用静态成员变量，调用其他静态成员函数，不可以是虚函数

## 说说数组和指针的区别
1. 数组是一段连续的内存块，包含元素的类型和长度信息；指针是一个保存地址的变量，仅包含类型信息。在c++类型系统中属于不同的复合类型
2. 数组名是一个可隐式转换为常量指针的标识符，无法进行赋值，而指针变量可以进行赋值，对数组名的引用得到的是数组指针，对指针的引用得到的是指针变量的地址
3. 指针的大小在32为系统下固定为4字节，64位系统下位8字节
4. 数组在传参过程中会发生类型退化，退化为指针变量

## 简单说⼀下函数指针
1. 函数指针是一个指向函数的指针变量
2. 在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。函数指针最常用的地方是做回调函数

## 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？
1. 野指针是未初始化的指针，悬空指针是指向已被释放的内存或失效对象的指针
2. 避免的手段通常包括，初始化或资源释放后及时置nullptr，尽量使用智能指针

## 说说内联函数和宏函数的区别
1. 宏定义的函数并非真正的函数，只是预处理阶段的字符串展开，没有类型检查
2. 内联函数是真正的函数，具有类型检查，是一种编译期的优化，编译器会在内联的位置直接插入代码，避免函数调用带来的开销，内联函数通常是函数体内容简单的函数
3. inline关键字仅作为内联建议，一个函数是否为内联函数最终由编译器决议，C++17扩展了inline关键字的功能，inline函数允许函数定义出现在多个翻译单元

## 说说运算符i++和++i的区别
1. ++i返回的是一个左值，i++返回的是一个右值
2. 以int a = i++; int b = ++i; 这个例子中，a是先赋值为i，然后i自增，b是被赋值为i自增后的结果
3. 无优化的情况下，++i效率更高，在优化之后（RVO）效率差别不大

## new / delete ，malloc / free 区别
1. new和delete是C++运算符，支持重载，而malloc和free是C库函数，不可重载
2. new执行了两个过程，第一步是分配未初始化的内存空间，第二步是调用构造函数进行初始化，失败会抛出异常。delete也有两个过程，首先调用析构函数完成析构，最后调用解分配函数释放内存
3. malloc分配的内存大小需要手动计算，返回的指针需要进行强转，失败时返回null

##  说说const和define的区别
1. const用于定义常量，define可以用于定义宏，也可以用于定义常量
2. 当用于定义常量时，const常量是具有类型的，会进行类型检查，遵循C++的作用域规则，在编译期进行处理，const常量可能会分配相应的内存，也可能会被优化为立即数
3. define常量是无类型的，也没有类型检查，在预处理阶段进行处理，不涉及内存分配，只是简单的进行宏展开
## 说说const int *a, int const *a, int *const a, int *const a, const int *const a分别是什么，有什么特点
1. const int a定义了一个整型常量
2. const int* a定义了一个指针，其指向的内容是一个整型常量
3. int const* a同const int* a
4. int *const a定义了一个常量指针，指向一个整型数据
5. const int *const a定义了一个常量指针，指向一个整型常量

## C++有几种传值方式，之间的区别是什么？
1. C++有值传递，指针传递和引用传递三种方式，对于值传递，形参是实参的副本，所以修改形参不会影响实参。
2. 对于指针传递，传递的是指针的值，形参和实参指向同一内存，在不改变指针的值的情况下，解引用修改数据会影响实参。
3. 对于引用传递，分为左值引用和右值引用， 左值引用是实参的一个别名，修改左值引用会影响到实参，右值引用主要用于接收右值实参，实现移动语义和完美转发

## 简述一下堆和栈的区别
1. 在管理方式上，栈由编译器进行分配与释放，内存连续，分配速度快；堆由开发者手动管理分配与释放，分配可能碎片化
2. 在生命周期方面，栈变量随作用域结束自动销毁，堆对象需要手动释放，否则会导致资源泄漏
3. 在结构上，栈严格遵守先进后出，由于内存连续，缓存命中率会更高，堆分配通常地址不连续，易碎片化
## 简述C++的内存管理
1. C++的内存可以分为栈区，堆区，静态存储区，常量存储区和自由存储区
2. 栈区主要用于存放局部变量和函数参数，由编译器进行管理
3. 静态存储区用于存放静态变量和全局变量，分为初始化和未初始化两个区域
4. 常量存储区用于存放常量
5. 堆区用于存放动态分配的对象，自由存储区是C++中的一个抽象概念，当使用缺省的new和delete时，自由存储区和堆区共享同一块内存，但如果重载new运算符，自由存储区可以脱离堆

## 内存泄露及解决办法
1. 内存泄漏是指没有及时回收动态分配的内存，常见的造成内存泄漏的行为有使用new和malloc，没有正确使用delete和free释放资源；存在继承关系时，父类析构函数非虚，导致资源不能及时释放；windows句柄资源使用后没有释放
2. 可以通过使用智能指针，RAII技术来避免出现内存泄漏问题，当出现内存泄漏时，可以使用Dmalloc、Leaky等工具来进行检查

## 简述一个程序有哪些section
1. 通常包括.text段，.data段，.bss段，堆区，共享区，栈区等组成
2. .text段通常用于存放二进制代码
3. .data段用于存放用于存放已初始化的全局变量和静态变量
4. .bss段用于存放未初始化的全局变量和静态变量
5. 对于可执行程序，栈区用于存放局部变量和函数参数，对于用于存放动态分配的资源，栈区从高地址向低地址增长，堆区从低地址向高地址增长

## 简述一下程序启动的过程
1. 操作系统首先会创建新进程，并分配虚拟地址空间，然后加载器将代码段(.text)，已初始化的数据段(.data)映射到内存，然后.bss段清零，完成内存布局初始化
2. 对于静态链接库，直接嵌入可执行文件；对于动态链接库，加载器读取可执行文件的导入表，确定每一个依赖的动态链接库，对于基址与预设不符的，查询重定位表进行重定位，将导出函数的实际地址写入IAT表，供程序调用
3. C runtime库进行初始化，初始化堆管理器，调用全局对象的构造函数，并注册全局对象的析构函数
4. 进入程序入口main或WinMain，开始执行