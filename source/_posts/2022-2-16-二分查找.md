---
title: 二分查找
date: 2022-2-16 10:56:28
mathjax: true
categories: 
    - 算法
---

> **二分查找的思路非常简单，但在实际写算法的过程中发现有很多细节还需要多加理解，比如**  
> 
> ① 为什么有时right = nums.size()，有时却是right = nums.size() - 1  
> ② while循环中的条件，为什么有时是<=，有时是<  
> ③ 在区间划分时，为什么有时left = mid + 1，right = mid - 1; 有时却是left = mid + 1,right = mid


<!-- more -->

---

以最简单的二叉搜索为例
~~~c++
// 二分查找的基本用法
int BinarySearch(vector<int>& nums, int target){
    int left = 0;
    int right = nums.size() - 1;
    while(left <= right){
        // 取mid的另一种形式
        // mid = (left + right) / 2与mid = left + (right - left) / 2
        // 在形式上是等价的，区别是前者存在溢出的可能
        int mid = left + (right - left) / 2;    
        if(nums[mid] == targrt){
            return mid;
        }
        else if(nums[mid] < target){
            left = mid + 1;
        }
        else{
            right = mid - 1;
        }
    }
    return -1;
}
~~~

## 区间与循环终止的条件
### 区间

1. **两种比较常见的区间形式**
   - 两端都是闭区间：[left，right]，即**right = nums.size() - 1**
   - 左闭右开：[left，right)，即**right = nums.size()**（右边界在数组中越界）

2. **left = mid + 1，right = mid - 1与left = mid + 1，right = mid两种划分区间的方式有何区别**
   - 对于两端都是闭区间的[left，right]，因为mid已经搜索过，也就是将整个区间分为了三个部分，即[left，mid - 1]、[mid]、[mid + 1，right]，此时**left = mid + 1，right = mid - 1**
   - 对于左闭右开的[left，right)，因为mid已经搜索过，区间也分为了三个部分，为了保持区间形式的一致性，此时的三个区间应该是[left，mid)、[mid]、[mid + 1，right)，故**left = mid + 1，right = mid**
   - 同理，对于左开右闭的(left，right]，三个区间应该是(left，mid - 1]、[mid]、(mid，right]，故**left = mid，right = mid - 1**

### 循环终止条件
1. **为什么有时是<=，有时是<**
   - 对于**left <= right**，当循环结束时，left = right + 1，无论区间形式是[right，left]，还是[left，right)，此时整个序列都已经搜索完毕，待搜索区间为空（但后者会出现错误）
   - 对于**left < right**，当循环结束时，left = right，区间形式是[left，left]或[left，left)
     - 也就是说对于两端都是闭区间的[left，right]形式，当循环结束时，整个序列并没有搜索完毕，剩下了一个[left，left]尚未搜索，此时并不能直接返回，需要再做处理
     - 而对于左闭右开的[left，right)形式，当循环结束时，整个序列已经搜索完毕（不会出现错误）

~~~c++
// 对于left < right，且是[left, right]形，需要补充
return nums[left] == target? left : -1;
~~~

### 具体使用
1. **是否可以随意搭配使用**
   - 不可以，正如上面所说，**对于循环结束条件为left <= right**与**左闭右开的[left，right)形式**组合使用时，无论采取何种划分区间的方式，总是会出现错误

2. **以nums = {0，2，4，5}为例分析**
   - 当target在数组中确实存在时（如target = 2），此时可以正常工作
   - 当 $\displaystyle target \le  5$但不等于数组中的任一一个值时（如target = 3或target = -1）
     - 以**left = mid + 1，right = mid**方式划分区间，此时会造成while死循环，原因是区间收缩的**最后一步**总是右边界向左收缩，即right = mid，导致left = right恒成立，故无法跳出循环
     - 以**left = mid + 1，right = mid - 1**方式划分区间，此时可以正常工作
   - 当 $\displaystyle target >  5$时（如target = 7）
     - 以**left = mid + 1，right = mid**方式划分区间，可以正常工作
     - 以**left = mid + 1，right = mid - 1**方式划分区间，此时会造成数组越界，原因是区间收缩的过程**一直是**左边界向右收缩，即left = mid + 1，最终收缩到left = right，而区间形式是[left，right)的，此时无法在right处取到数据，故数组越界

3. **如何解决**
   - 上面已经分析了，只有**循环结束条件为left <= right**与**左闭右开的[left，right)形式**组合使用时会出错，那么只需要避免使用这种组合即可，也就是有3中正确的组合方式
     - **循环结束条件为left <= right**与**两端都是闭区间的[left，right]形式**组合
     - **循环结束条件为left < right**与**左闭右开的[left，right)形式**组合
     - **循环结束条件为left < right**与**两端都是闭区间的[left，right]形式**组合（循环结束会剩下[left，left]需要单独处理，因此最好是使用前两种固定组合）

## 二分查找的进阶运用

除了基础的使用二分查找在有序序列中搜索一个数，还有两种进阶的使用方式，代码也需要做一些小的修改

### 寻找左边界

1. **假如有一个有序序列[1, 2, 2, 2, 3, 4]，现在要找到第一个’2‘所在位置的下标**
   - 一个容易想到的办法是顺序遍历这个有序序列，就能轻松的找到一个’2‘的下标
   - 另一个办法就是使用二分查找来减少搜索的次数，但用上述的二分查找代码，我们得到并不是第一个’2‘的下标1，而是第二个’2‘的下标2，故此时需要对二分查找进行一定的改进

2. **怎么改进代码**
   - 在之前提到，对于**循环结束条件为left < right**的形式，循环结束时，left = right，而**左闭右开的[left，right)**形式，能保证在循环结束时完整的遍历整个序列，因此，最终需要确定的就是如何划分区间
   - 一个关键的地方在于，普通的查找，只要找到target就立刻返回（即存在nums[mid] = target就返回），但此时为了查找左边界就不应该这么操作，而是应该收缩右边界，即**right = mid**，此时二分查找会继续搜索[left，right)是否还有满足要求的target，最终找到左边界

3. **代码与例题**
    - 例题：[leetcode 278.第一个错误版本](https://leetcode-cn.com/problems/first-bad-version/)（原理相同）
    - 代码

~~~c++
int LeftBoundary(vector<int>& nums, int target)
    int left = 0;
    int right = nums.size();
    while(left < right){
        int mid = left + (right - left) / 2;    
        if(nums[mid] == targrt){
            right = mid;    // 收缩右边界
        }
        else if(nums[mid] < target){
            left = mid + 1;
        }
        else{
            right = mid;
        }
    }
    return left;
~~~

### 寻找右边界 
1. **怎么改进代码**
   - 根据寻找左边界的思想，不难想到，当找到target时，不立刻返回，而是收缩左边界，为了保证**左闭右开的[left，right)**形式，应该令**left = mid + 1**，需要注意的是，因为是左边界收缩到left = right，而right是开区间，故**实际的右边界是right - 1（或left - 1）**

2. **代码与例题**
   - 例题：指定一个target，要求找到其在非降序的数组nums中的插入位置的下标，要求插入后还要保持非降序的特性（例如target = 3， nums[1, 2, 2, 2, 4, 5]，此时应该返回下标4）
   - 代码

~~~c++
int RightBoundary(vector<int>& nums, int target)
    int left = 0;
    int right = nums.size();
    while(left < right){
        int mid = left + (right - left) / 2;    
        if(nums[mid] == targrt){
            left = mid + 1;    // 收缩右边界
        }
        else if(nums[mid] < target){
            left = mid + 1;
        }
        else{
            right = mid;
        }
    }
    return left;        // 实际的右边界是left - 1
                        // 但插入位置是右边界之后的位置，故直接返回left即可
~~~

### Tips
1. 二分查找的使用并不严格要求所求序列有序，如：[852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)
 
2. 二分查找的重点在于理解，并明确所求，如何时是查找左边界，何时是查找有边界，对于两种常见的组合形式
   - **循环结束条件为left <= right**与**两端都是闭区间的[left，right]形式**组合
   - **循环结束条件为left < right**与**左闭右开的[left，right)形式**组合

最后都可以完成**利用二分查找搜索数**、**寻找左边界**、**寻找右边界**的功能，不同的组合只需要根据不同的应用场合做一定的边界处理即可  


