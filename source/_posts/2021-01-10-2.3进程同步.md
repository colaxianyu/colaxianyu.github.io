---
title: 进程同步
date: 2021-01-27 22:45:47
categories: 
    - 考研
---

### 进程同步与互斥

#### 临界资源
1. 临界资源：一次仅允许一个进程使用的资源
2. 临界区：访问临界资源的代码 

~~~c++ {.line-numbers .highlight=3}
while(1){
    entry section;      //进入区,检查是否可进入临界区，若可进入则需“上锁”
    critical section；  //临界区，访问临界资源的代码
    exit section；      //退出区，负责“解锁”
    remainder section； //剩余区，其余代码
}
~~~

<!--more-->

**注意区分临界区与临界资源** 

#### 同步
- 因进程间相互合作产生的直接制约关系

#### 互斥

1. 访问临界资源产生的间接制约关系
2. 进入临界区应遵循的原则：
   - 空闲让进：临界资源空闲时，可以允许一个请求进入临界区的进程立即进入临界区
   - 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
   - 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区
   - 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待

---

### 实现临界区互斥的方法

#### 软件方法

**在进入区设置并检查一些标志来表明是否有进程在临界区中**

1. 单标志法（标志turn用于指示允许进入临界区的进程）
   - 在进入区只做“检查”，不“上锁”
   - 在退出区把临界区的使用权交给另一个进程（即在退出区对自己”上锁“，对另一个进程“解锁”）
   - 主要问题：不满足**空闲让进**原则（某个进程不进入临界区，则另一个进程也无法进入）

2. 双标志先检查法（标志flag[i]用来指示i进程是否进入临界区，进入为True，否则为False）
   - 在进入区先“检查”后“上锁”，退出区“解锁”
   - 主要问题：不满足**忙则等待**原则
3. 双标志后检查法
   - 在进入区先“上锁”后“检查”，退出区“解锁”
   - 主要问题：不满足**空闲让进**与**有限等待**，可能导致**饥饿**
4. peterson算法（设置turn与flag[i]，每个进程先设置自己的标志后再设置turn标志，这时再同时检查另一个进程的标志和turn标志）
   - 整个过程可以概括为”主动争取--谦让对方--检查对方是否想进，己方是否谦让“
   - 主要问题：不满足**让权等待**，会发生**忙等**

#### 硬件方法
1. 中断屏蔽方法
2. TestAndSet（TS指令/TSL指令）
3. SWAP指令（XCHG指令）

---

### 信号量机制

#### 信号量的类型
1. 整型信号量
   - 用一个整型变量作为信号量，数值表示资源数
   - 与普通整型变量的区别：只支持初始化、P操作、V操作
   - 存在的问题：不满足让权等待原则
2. 记录型信号量
   - S.value表示资源数、S.L指向等待该资源的队列

#### 信号量实现同步
1. 确定同步关系（一前一后）
2. 设置同步信号量并设初值为0
3. 在“先操作”之后对信号量执行V操作
4. 在“后操作”之前对信号量执行P操作

#### 信号量实现互斥
1. 确定临界区
2. 设置互斥信号量并设初值为1
3. 临界区前对信号量执行P操作
4. 临界区后对信号量执行V操作

#### 信号量实现前驱关系
1. 画出前驱图，每一对前驱关系即为一个同步关系
2. 为每一个同步关系设置信号量并设初值为0
3. 按同步关系处理即可

---

### 管程
1. 定义：由一组**数据**和一组定义在这组数据之上的**对这组数据的操作**所组成的软件模块（类似于Class）
2. 组成
   - 局部于管程内部的共享数据结构
   - 对该组数据结构的初始化语句
   - 访问数据结构的一组过程（函数）

3. 基本特征
   - 局部与管程内部的数据，只能由管程中的一组过程访问
   - 一个进程/线程只能通过调用管程中的过程才能访问管程中的共享数据
   - 每次仅允许一个进程在管程内执行某个内部过程 
4. 目的：解决信号量机制编程麻烦、易出错的问题
   