---
title: 死锁
date: 2021-01-26 22:45:47
categories: 
    - 考研
---


### 死锁的概念与产生的必要条件

#### 死锁的定义
- 死锁：各进程相互等待对方已有资源，导致各进程都被阻塞，无法向前推进

#### 死锁产生的必要条件
1. 互斥条件：对必须互斥使用的资源进行争抢才会导致死锁
2. 不剥夺条件：进程保持的资源只能主动释放，不可强行剥夺
3. 请求保持条件：进程保持资源的同时，又请求别的资源
4. 循环等待条件：存在某种进程资源的的循环等待链（循环等待未必死锁，死锁必定存在循环等待）

<!--more-->

---

### 死锁的处理策略

#### 预防死锁
- 思想：破坏死锁产生的4个必要条件之一即可

1. 破环互斥条件
   - 将临界资源改造为可共享使用的资源（SPOOLing技术）
   - 缺点：可行性不高，大多数情况无法破坏资源的互斥性
2. 破坏不剥夺条件
   - 方案一：申请的资源得不到满足时，进程主动释放自己所拥有的资源
   - 方案二：申请的资源被别的进程所占有时，操作系统协助剥夺该资源（考虑优先级）
   - 缺点：实现复杂；剥夺或释放资源可能导致前一阶段的工作失效；反复申请和释放资源导致系统开销大，降低系统吞吐量；可能导致饥饿
3. 破坏请求保持条件
   - 采用预先静态分配的方法，在进程运行前一次申请完其所需的全部资源，之后一直保持这些资源
   - 缺点：资源利用率低，可能导致饥饿
4. 破坏循环等待条件
   - 给资源编号，规定每个进程必须按编号递增的顺序申请资源，同类资源一次申请完
   - 缺点：不方便增加新设备；会导致资源的浪费；用户编程麻烦

#### 避免死锁
- 思想：在资源动态分配的过程中，防止系统进入不安全状态，以避免死锁的发生

1. 系统安全状态：能找到一个资源分配序列让所有进程都顺利推进下去
   - 系统处于不安全状态不一定发生死锁，系统处于安全状态一定能避免死锁发生
2. 银行家算法
   - 检查此次申请的资源量是否超过了声明的最大需求数
   - 检查此时系统剩余可用资源是否能满足这次请求
   - 试探性分配，并更改相应数据结构中的数值
   - 用安全性算法检查此次分配是否会导致系统进入不安全状态
3. 安全性算法：检查当前的剩余可用资源是否能满足某个进程的组大需求，如果可以，就把该进程加入安全序列，重复这个过程，判断是否能让所有进程都加入安全序列中

---

### 死锁的检测及解除
- 思想：在资源分配后进行检测，若发生死锁则采用相应手段解除死锁 

#### 死锁的检测
1. 资源分配图
   - 进程节点
   - 资源节点
   - 请求边（进程节点→资源节点）
   - 分配边（资源节点→进程节点）
2. 死锁检测算法
   - 找出既不阻塞又不孤点的进程节点，消去它所有的请求边与分配边，使其成为一个孤点，按上述方法依次简化资源分配图，若能消除图中所有的边，则该图是可完全简化的
   - 既不阻塞又不孤点是指：其申请的资源数小于等于系统中已有的空闲资源数

3. 死锁定理：若资源分配图是不可完全简化的，则发生死锁

#### 死锁的解除
1. 资源剥夺法：挂起某些死锁进程并抢占其资源，将这些资源分配给其他死锁进程（应避免被挂起的进程长期得不到资源）
2. 撤销进程法：强制撤销部分或全部死锁进程，并剥夺这些进程的全部资源
3. 进程回退法：让一个或多个进程回退到足以回避死锁的步骤，进程回退时自愿释放资源
